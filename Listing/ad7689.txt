; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\ad7689.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\ad7689.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=537 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\ad7689.crf --no_multibyte_chars ..\drive\AD7689.c]
                          THUMB

                          AREA ||i.AD7689_Delay||, CODE, READONLY, ALIGN=2

                  AD7689_Delay PROC
;;;133    /************************************************************************/
;;;134    void AD7689_Delay(void)
000000  b508              PUSH     {r3,lr}
;;;135    {
;;;136    	vu16 count ;
;;;137      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
000006  bf00              NOP      
                  |L1.8|
000008  f8ad0000          STRH     r0,[sp,#0]
00000c  f8bd0000          LDRH     r0,[sp,#0]
000010  2800              CMP      r0,#0
000012  d003              BEQ      |L1.28|
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  1e40              SUBS     r0,r0,#1
00001a  e7f5              B        |L1.8|
                  |L1.28|
;;;138    }
00001c  bd08              POP      {r3,pc}
;;;139    void AD7689_Delay1(void)
                          ENDP


                          AREA ||i.AD7689_Delay1||, CODE, READONLY, ALIGN=2

                  AD7689_Delay1 PROC
;;;138    }
;;;139    void AD7689_Delay1(void)
000000  b508              PUSH     {r3,lr}
;;;140    {
;;;141    	vu16 count ;
;;;142      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
000006  bf00              NOP      
                  |L2.8|
000008  f8ad0000          STRH     r0,[sp,#0]
00000c  f8bd0000          LDRH     r0,[sp,#0]
000010  2800              CMP      r0,#0
000012  d003              BEQ      |L2.28|
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  1e40              SUBS     r0,r0,#1
00001a  e7f5              B        |L2.8|
                  |L2.28|
;;;143    }
00001c  bd08              POP      {r3,pc}
;;;144    void AD7689_Scan_CH(void)
                          ENDP


                          AREA ||i.AD7689_InitializeSPI1||, CODE, READONLY, ALIGN=2

                  AD7689_InitializeSPI1 PROC
;;;26     void Bubble_sort(vu16 *D_temp,vu8 num);
;;;27     void AD7689_InitializeSPI1(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;28     {
;;;29     	GPIO_InitTypeDef GPIO_InitStructure;
;;;30       SPI_InitTypeDef  SPI_InitStructure;
;;;31       /*!< SD_SPI_CS_GPIO, SD_SPI_MOSI_GPIO, SD_SPI_MISO_GPIO, SD_SPI_DETECT_GPIO 
;;;32            and SD_SPI_SCK_GPIO Periph clock enable 
;;;33     	// 	 RCC_AHBPeriphClockCmd(FLASH_CS_PIN_SCK|FLASH_SCK_PIN_SCK|FLASH_MISO_PIN_SCK | FLASH_MOSI_PIN_SCK, ENABLE);
;;;34       !< SD_SPI Periph clock enable */
;;;35     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);
000004  2101              MOVS     r1,#1
000006  b088              SUB      sp,sp,#0x20           ;28
000008  0308              LSLS     r0,r1,#12
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;36     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00000e  2502              MOVS     r5,#2
000010  f88d5005          STRB     r5,[sp,#5]
;;;37     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000014  2601              MOVS     r6,#1
;;;38     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;39     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//inv
000016  2004              MOVS     r0,#4
;;;40     	GPIO_Init(GPIOD, &GPIO_InitStructure);//
000018  f8df80ac          LDR      r8,|L3.200|
00001c  f88d6004          STRB     r6,[sp,#4]            ;37
000020  2400              MOVS     r4,#0                 ;38
000022  9000              STR      r0,[sp,#0]
000024  f88d4006          STRB     r4,[sp,#6]            ;38
000028  4669              MOV      r1,sp
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       GPIO_Init
;;;41       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;//PB3~5复用功能输出	
;;;42       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000030  f88d5004          STRB     r5,[sp,#4]
;;;43       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000034  f88d4006          STRB     r4,[sp,#6]
;;;44       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000038  2003              MOVS     r0,#3
00003a  f88d0005          STRB     r0,[sp,#5]
;;;45       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
;;;46       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
00003e  4d23              LDR      r5,|L3.204|
000040  2738              MOVS     r7,#0x38              ;41
000042  9700              STR      r7,[sp,#0]            ;42
000044  f88d6007          STRB     r6,[sp,#7]            ;45
000048  4669              MOV      r1,sp
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       GPIO_Init
;;;47     	
;;;48       GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1); //PC2复用为 SPI1
000050  2205              MOVS     r2,#5
000052  2103              MOVS     r1,#3
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;49     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1); //PBC3复用为 SPI1
00005a  2205              MOVS     r2,#5
00005c  2104              MOVS     r1,#4
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       GPIO_PinAFConfig
;;;50     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1); //PB13复用为 SPI1
000064  2205              MOVS     r2,#5
000066  4611              MOV      r1,r2
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       GPIO_PinAFConfig
;;;51     	
;;;52     	AD7689_CNV_1;
00006e  2104              MOVS     r1,#4
000070  4640              MOV      r0,r8
000072  f7fffffe          BL       GPIO_SetBits
;;;53     	AD7689_Delay();
000076  f7fffffe          BL       AD7689_Delay
;;;54     	AD7689_CNV_0;
00007a  2104              MOVS     r1,#4
00007c  4640              MOV      r0,r8
00007e  f7fffffe          BL       GPIO_ResetBits
;;;55     	//这里只针对SPI口初始化
;;;56       SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000082  f8ad4008          STRH     r4,[sp,#8]
;;;57     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000086  f44f7082          MOV      r0,#0x104
00008a  f8ad000a          STRH     r0,[sp,#0xa]
;;;58     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;		//设置SPI的数据大小:SPI发送接收16位帧结构
00008e  14e8              ASRS     r0,r5,#19
000090  f8ad000c          STRH     r0,[sp,#0xc]
;;;59     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为高电平
;;;60     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000094  f8ad4010          STRH     r4,[sp,#0x10]
;;;61     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000098  1080              ASRS     r0,r0,#2
;;;62     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
00009a  f8ad7014          STRH     r7,[sp,#0x14]
00009e  f8ad400e          STRH     r4,[sp,#0xe]          ;59
0000a2  f8ad0012          STRH     r0,[sp,#0x12]         ;61
;;;63     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
0000a6  f8ad4016          STRH     r4,[sp,#0x16]
;;;64     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
0000aa  2007              MOVS     r0,#7
;;;65     	SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
0000ac  4c08              LDR      r4,|L3.208|
0000ae  f8ad0018          STRH     r0,[sp,#0x18]         ;64
0000b2  a902              ADD      r1,sp,#8
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       SPI_Init
;;;66     	
;;;67     	SPI_Cmd(SPI1, ENABLE); //使能SPI外设
0000ba  2101              MOVS     r1,#1
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       SPI_Cmd
;;;68     }
0000c2  b008              ADD      sp,sp,#0x20
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;69     
                          ENDP

                  |L3.200|
                          DCD      0x40020c00
                  |L3.204|
                          DCD      0x40020400
                  |L3.208|
                          DCD      0x40013000

                          AREA ||i.AD7689_Scan_CH||, CODE, READONLY, ALIGN=2

                  AD7689_Scan_CH PROC
;;;143    }
;;;144    void AD7689_Scan_CH(void)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;145    {
;;;146    // 	vu8 i,f,d;
;;;147    // 	vu32 sum1;
;;;148    // 	vu16 var_chI,var_chV;
;;;149    // 	static vu8 I_cont,V_cont;
;;;150    // 	for(i=0;i<7;i++)
;;;151    // 	{
;;;152    // 		AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
;;;153    // 		R1mon_value=AD7689_Buffer[0];
;;;154    // 		R2mon_value=AD7689_Buffer[1];
;;;155    // 		Vmon_Load_value=AD7689_Buffer[2];
;;;156    // 		Imon_Load_value=AD7689_Buffer[3];
;;;157    // 		Rmon_value=AD	7689_Buffer[4];
;;;158    // 		Vmon_POWE_value=AD7689_Buffer[5];
;;;159    // 		Imon_POWE_value=AD7689_Buffer[6];
;;;160    
;;;161    	vu8 i,f,d;
;;;162    	vu32 sum1;
;;;163    	vu16 var_chI,var_chI1,var_chV,var_chV1,var_chR;
;;;164    	static vu8 I_cont,I1_cont,V_cont,R_cont,V1_cont;
;;;165    	for(i=0;i<7;i++)
000004  2500              MOVS     r5,#0
000006  f88d5004          STRB     r5,[sp,#4]
;;;166    	{
;;;167    		AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
00000a  4c43              LDR      r4,|L4.280|
;;;168    		R1mon_value=AD7689_Buffer[0];
00000c  4e43              LDR      r6,|L4.284|
;;;169    		R2mon_value=AD7689_Buffer[1];
00000e  4f44              LDR      r7,|L4.288|
;;;170    		Vmon_Load_value=AD7689_Buffer[2];
000010  f8df8110          LDR      r8,|L4.292|
;;;171    		var_chI=AD7689_Buffer[3];
;;;172    //		Imon_Load_value = AD7689_Buffer[3];
;;;173    		var_chR=AD7689_Buffer[4];
;;;174    		Vmon_POWE_value=AD7689_Buffer[5];
000014  f8df9110          LDR      r9,|L4.296|
;;;175    		Imon_POWE_value=AD7689_Buffer[6];
000018  f8dfa110          LDR      r10,|L4.300|
00001c  e021              B        |L4.98|
00001e  bf00              NOP                            ;167
                  |L4.32|
000020  f89d1004          LDRB     r1,[sp,#4]            ;167
000024  2001              MOVS     r0,#1                 ;167
000026  f7fffffe          BL       SPI_AD7689_Read
00002a  f89d1004          LDRB     r1,[sp,#4]            ;167
00002e  f8240011          STRH     r0,[r4,r1,LSL #1]     ;167
000032  8820              LDRH     r0,[r4,#0]            ;168  ; AD7689_Buffer
000034  8030              STRH     r0,[r6,#0]            ;168
000036  8860              LDRH     r0,[r4,#2]            ;169  ; AD7689_Buffer
000038  8038              STRH     r0,[r7,#0]            ;169
00003a  88a1              LDRH     r1,[r4,#4]            ;170  ; AD7689_Buffer
00003c  f8a81000          STRH     r1,[r8,#0]            ;170
000040  88e0              LDRH     r0,[r4,#6]            ;171  ; AD7689_Buffer
000042  f8ad0008          STRH     r0,[sp,#8]            ;171
000046  8920              LDRH     r0,[r4,#8]            ;173  ; AD7689_Buffer
000048  f8ad000c          STRH     r0,[sp,#0xc]          ;173
00004c  8961              LDRH     r1,[r4,#0xa]          ;174  ; AD7689_Buffer
00004e  f8a91000          STRH     r1,[r9,#0]            ;174
000052  89a1              LDRH     r1,[r4,#0xc]  ; AD7689_Buffer
000054  f8aa1000          STRH     r1,[r10,#0]
000058  f89d0004          LDRB     r0,[sp,#4]            ;165
00005c  1c40              ADDS     r0,r0,#1              ;165
00005e  f88d0004          STRB     r0,[sp,#4]            ;165
                  |L4.98|
000062  f89d0004          LDRB     r0,[sp,#4]            ;165
000066  2807              CMP      r0,#7                 ;165
000068  d3da              BCC      |L4.32|
;;;176    	}
;;;177    	
;;;178    	Ad7689_Fit_Rmon[R_cont++]=var_chR;
00006a  f8bd100c          LDRH     r1,[sp,#0xc]
00006e  4c30              LDR      r4,|L4.304|
000070  7860              LDRB     r0,[r4,#1]  ; R_cont
000072  4e29              LDR      r6,|L4.280|
000074  36d8              ADDS     r6,r6,#0xd8
000076  eb060240          ADD      r2,r6,r0,LSL #1
00007a  1c40              ADDS     r0,r0,#1
00007c  7060              STRB     r0,[r4,#1]
00007e  8011              STRH     r1,[r2,#0]
;;;179    	if(R_cont==100)
000080  7860              LDRB     r0,[r4,#1]  ; R_cont
000082  2864              CMP      r0,#0x64
000084  d11e              BNE      |L4.196|
;;;180    	{
;;;181    		R_cont=0;
000086  7065              STRB     r5,[r4,#1]
;;;182    		sum1=0;
;;;183    		BubbleSort(Ad7689_Fit_Rmon, 100);
000088  2164              MOVS     r1,#0x64
00008a  4630              MOV      r0,r6
00008c  9501              STR      r5,[sp,#4]
00008e  f7fffffe          BL       BubbleSort
;;;184    		for(f=40;f<50;f++)
000092  2028              MOVS     r0,#0x28
000094  e00a              B        |L4.172|
;;;185    		{
;;;186    			sum1 +=Ad7689_Fit_Rmon[f];
000096  bf00              NOP      
                  |L4.152|
000098  f89d0000          LDRB     r0,[sp,#0]
00009c  9901              LDR      r1,[sp,#4]
00009e  f8360010          LDRH     r0,[r6,r0,LSL #1]
0000a2  4408              ADD      r0,r0,r1
0000a4  9001              STR      r0,[sp,#4]            ;184
0000a6  f89d0000          LDRB     r0,[sp,#0]            ;184
0000aa  1c40              ADDS     r0,r0,#1              ;184
                  |L4.172|
0000ac  f88d0000          STRB     r0,[sp,#0]            ;184
0000b0  f89d0000          LDRB     r0,[sp,#0]            ;184
0000b4  2832              CMP      r0,#0x32              ;184
0000b6  d3ef              BCC      |L4.152|
;;;187    		}
;;;188    		Rmon_value=sum1/10;//
0000b8  9801              LDR      r0,[sp,#4]
0000ba  210a              MOVS     r1,#0xa
0000bc  fbb0f0f1          UDIV     r0,r0,r1
0000c0  491c              LDR      r1,|L4.308|
0000c2  8008              STRH     r0,[r1,#0]
                  |L4.196|
;;;189    	}
;;;190    
;;;191    	Ad7689_Fit_Imon[I_cont++] = var_chI;
0000c4  f8bd2008          LDRH     r2,[sp,#8]
0000c8  7820              LDRB     r0,[r4,#0]  ; I_cont
0000ca  4913              LDR      r1,|L4.280|
0000cc  3110              ADDS     r1,r1,#0x10
0000ce  eb010340          ADD      r3,r1,r0,LSL #1
0000d2  1c40              ADDS     r0,r0,#1
0000d4  7020              STRB     r0,[r4,#0]
0000d6  801a              STRH     r2,[r3,#0]
;;;192    	if(I_cont==30)
0000d8  7820              LDRB     r0,[r4,#0]  ; I_cont
0000da  281e              CMP      r0,#0x1e
0000dc  d11a              BNE      |L4.276|
;;;193    	{
;;;194    		I_cont=0;
0000de  7025              STRB     r5,[r4,#0]
;;;195    		sum1=0;
;;;196    		for(f=0;f<30;f++)
0000e0  9501              STR      r5,[sp,#4]
0000e2  f88d5000          STRB     r5,[sp,#0]
0000e6  e00b              B        |L4.256|
                  |L4.232|
;;;197    		{
;;;198    			sum1 +=Ad7689_Fit_Imon[f];
0000e8  f89d0000          LDRB     r0,[sp,#0]
0000ec  f8310010          LDRH     r0,[r1,r0,LSL #1]
0000f0  9a01              LDR      r2,[sp,#4]
0000f2  4410              ADD      r0,r0,r2
0000f4  9001              STR      r0,[sp,#4]            ;196
0000f6  f89d0000          LDRB     r0,[sp,#0]            ;196
0000fa  1c40              ADDS     r0,r0,#1              ;196
0000fc  f88d0000          STRB     r0,[sp,#0]            ;196
                  |L4.256|
000100  f89d0000          LDRB     r0,[sp,#0]            ;196
000104  281e              CMP      r0,#0x1e              ;196
000106  d3ef              BCC      |L4.232|
;;;199    		}
;;;200    		Imon_Load_value=sum1/30;//
000108  9801              LDR      r0,[sp,#4]
00010a  211e              MOVS     r1,#0x1e
00010c  fbb0f0f1          UDIV     r0,r0,r1
000110  4909              LDR      r1,|L4.312|
000112  8008              STRH     r0,[r1,#0]
                  |L4.276|
;;;201    	}
;;;202    //	if(I_cont==10)
;;;203    //	{
;;;204    //		I_cont=0;
;;;205    //		sum1=0;
;;;206    //		for(f=0;f<10;f++)
;;;207    //		{
;;;208    //			sum1 +=Ad7689_Fit_Imon[f];
;;;209    //		}
;;;210    //		Imon_Load_value=sum1/10;//
;;;211    //	}
;;;212    }
000114  e8bd87ff          POP      {r0-r10,pc}
                          ENDP

                  |L4.280|
                          DCD      ||.bss||
                  |L4.284|
                          DCD      R1mon_value
                  |L4.288|
                          DCD      R2mon_value
                  |L4.292|
                          DCD      Vmon_Load_value
                  |L4.296|
                          DCD      Vmon_POWE_value
                  |L4.300|
                          DCD      Imon_POWE_value
                  |L4.304|
                          DCD      ||.data||
                  |L4.308|
                          DCD      Rmon_value
                  |L4.312|
                          DCD      Imon_Load_value

                          AREA ||i.AD7689_TransferByte||, CODE, READONLY, ALIGN=2

                  AD7689_TransferByte PROC
;;;93     /************************************************************************/
;;;94     vu16 AD7689_TransferByte(vu16 uiTxData1)
000000  b511              PUSH     {r0,r4,lr}
;;;95     {
;;;96     	vu16 uiRxData;
;;;97     	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  4c0d              LDR      r4,|L5.56|
000004  b081              SUB      sp,sp,#4              ;95
                  |L5.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L5.6|
;;;98     	SPI_I2S_SendData(SPI1,uiTxData1);
000012  f8bd1004          LDRH     r1,[sp,#4]
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_I2S_SendData
                  |L5.28|
;;;99     	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L5.28|
;;;100    	uiRxData = SPI_I2S_ReceiveData(SPI1);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;101    	return uiRxData;
000032  f8bd0000          LDRH     r0,[sp,#0]
;;;102    }
000036  bd1c              POP      {r2-r4,pc}
;;;103    
                          ENDP

                  |L5.56|
                          DCD      0x40013000

                          AREA ||i.BubbleSort||, CODE, READONLY, ALIGN=1

                  BubbleSort PROC
;;;111    //冒泡排序
;;;112    void BubbleSort(uint16_t A[], uint16_t n)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;113    {
;;;114    	int i,j;
;;;115        for (j = 0; j < n - 1; j++)         // 每次最大元素就像气泡一样"浮"到数组的最后
000004  2500              MOVS     r5,#0
000006  4689              MOV      r9,r1                 ;113
000008  4680              MOV      r8,r0                 ;113
00000a  1e4f              SUBS     r7,r1,#1
00000c  e015              B        |L6.58|
                  |L6.14|
;;;116        {
;;;117            for (i = 0; i < n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移
00000e  2400              MOVS     r4,#0
000010  eba90605          SUB      r6,r9,r5
000014  1e76              SUBS     r6,r6,#1
000016  e00d              B        |L6.52|
                  |L6.24|
;;;118            {
;;;119                if (A[i] > A[i + 1])            // 如果条件改成A[i] >= A[i + 1],则变为不稳定的排序算法
000018  eb080044          ADD      r0,r8,r4,LSL #1
00001c  f8381014          LDRH     r1,[r8,r4,LSL #1]
000020  8840              LDRH     r0,[r0,#2]
000022  4281              CMP      r1,r0
000024  d905              BLS      |L6.50|
;;;120                {
;;;121                    Swap(A, i, i + 1);
000026  1c60              ADDS     r0,r4,#1
000028  b282              UXTH     r2,r0
00002a  b2a1              UXTH     r1,r4
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       Swap
                  |L6.50|
000032  1c64              ADDS     r4,r4,#1
                  |L6.52|
000034  42a6              CMP      r6,r4                 ;117
000036  dcef              BGT      |L6.24|
000038  1c6d              ADDS     r5,r5,#1              ;117
                  |L6.58|
00003a  42bd              CMP      r5,r7                 ;115
00003c  dbe7              BLT      |L6.14|
;;;122                }
;;;123            }
;;;124        }
;;;125    }
00003e  e8bd83f0          POP      {r4-r9,pc}
;;;126    /************************************************************************/
                          ENDP


                          AREA ||i.SPI_AD7689_Read||, CODE, READONLY, ALIGN=2

                  SPI_AD7689_Read PROC
;;;69     
;;;70     vu16 SPI_AD7689_Read(vu16 AD7689_CFG, vu16 AD7689_INx)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;71     {
000002  b082              SUB      sp,sp,#8
;;;72     	vu16 AD7689_Config=0;
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;73     	vu16 AD7689_Data;
;;;74     	vu8 i;
;;;75     	AD7689_Config = AD7689_CFG<<13|AD7689_INCC<<10|AD7689_INx<<7|AD7689_BW<<6|AD7689_REF<<3|AD7689_SEQ<<1|AD7689_RB;//写入配置参数
00000a  f8bd0008          LDRH     r0,[sp,#8]
00000e  f8bd100c          LDRH     r1,[sp,#0xc]
000012  0340              LSLS     r0,r0,#13
000014  ea4010c1          ORR      r0,r0,r1,LSL #7
000018  f6410159          MOV      r1,#0x1859
00001c  4308              ORRS     r0,r0,r1
00001e  f8ad0000          STRH     r0,[sp,#0]
;;;76     	AD7689_Config <<=2;
000022  f8bd0000          LDRH     r0,[sp,#0]
000026  f64f71ff          MOV      r1,#0xffff
00002a  ea010080          AND      r0,r1,r0,LSL #2
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;77     	AD7689_CNV_0;
000032  4c0b              LDR      r4,|L7.96|
000034  2104              MOVS     r1,#4
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       GPIO_ResetBits
;;;78       AD7689_Data=AD7689_TransferByte(AD7689_Config);
00003c  f8bd0000          LDRH     r0,[sp,#0]
000040  f7fffffe          BL       AD7689_TransferByte
000044  f8ad0000          STRH     r0,[sp,#0]
;;;79     	AD7689_Delay(); 
000048  f7fffffe          BL       AD7689_Delay
;;;80     	AD7689_CNV_1;
00004c  2104              MOVS     r1,#4
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       GPIO_SetBits
;;;81     	AD7689_Delay(); 
000054  f7fffffe          BL       AD7689_Delay
;;;82     	return AD7689_Data;
000058  f8bd0000          LDRH     r0,[sp,#0]
;;;83     }
00005c  b004              ADD      sp,sp,#0x10
00005e  bd10              POP      {r4,pc}
;;;84     
                          ENDP

                  |L7.96|
                          DCD      0x40020c00

                          AREA ||i.Swap||, CODE, READONLY, ALIGN=1

                  Swap PROC
;;;103    
;;;104    void Swap(uint16_t A[], uint16_t i, uint16_t j)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106        int temp = A[i];
000002  f8303011          LDRH     r3,[r0,r1,LSL #1]
;;;107        A[i] = A[j];
000006  f8304012          LDRH     r4,[r0,r2,LSL #1]
00000a  f8204011          STRH     r4,[r0,r1,LSL #1]
;;;108        A[j] = temp;
00000e  f8203012          STRH     r3,[r0,r2,LSL #1]
;;;109    }
000012  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  AD7689_Buffer
                          %        16
                  Ad7689_Fit_Imon
                          %        200
                  Ad7689_Fit_Rmon
                          %        200

                          AREA ||area_number.11||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.11||, ||.bss||
                  Ad7689_Fit_Vmon
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  I_cont
000000  00                DCB      0x00
                  R_cont
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\AD7689.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_AD7689_c_5bab55e0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REVSH|
#line 144
|__asm___8_AD7689_c_5bab55e0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
