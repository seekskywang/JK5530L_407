; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\ad7689.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\ad7689.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=537 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\ad7689.crf --no_multibyte_chars ..\drive\AD7689.c]
                          THUMB

                          AREA ||i.AD7689_Delay||, CODE, READONLY, ALIGN=1

                  AD7689_Delay PROC
;;;133    /************************************************************************/
;;;134    void AD7689_Delay(void)
000000  b508              PUSH     {r3,lr}
;;;135    {
;;;136    	vu16 count ;
;;;137      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
                  |L1.6|
000006  f8ad0000          STRH     r0,[sp,#0]
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L1.26|
000012  f8bd0000          LDRH     r0,[sp,#0]
000016  1e40              SUBS     r0,r0,#1
000018  e7f5              B        |L1.6|
                  |L1.26|
;;;138    }
00001a  bd08              POP      {r3,pc}
;;;139    void AD7689_Delay1(void)
                          ENDP


                          AREA ||i.AD7689_Delay1||, CODE, READONLY, ALIGN=1

                  AD7689_Delay1 PROC
;;;138    }
;;;139    void AD7689_Delay1(void)
000000  b508              PUSH     {r3,lr}
;;;140    {
;;;141    	vu16 count ;
;;;142      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
                  |L2.6|
000006  f8ad0000          STRH     r0,[sp,#0]
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L2.26|
000012  f8bd0000          LDRH     r0,[sp,#0]
000016  1e40              SUBS     r0,r0,#1
000018  e7f5              B        |L2.6|
                  |L2.26|
;;;143    }
00001a  bd08              POP      {r3,pc}
;;;144    void AD7689_Scan_CH(void)
                          ENDP


                          AREA ||i.AD7689_InitializeSPI1||, CODE, READONLY, ALIGN=2

                  AD7689_InitializeSPI1 PROC
;;;26     void Bubble_sort(vu16 *D_temp,vu8 num);
;;;27     void AD7689_InitializeSPI1(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;28     {
;;;29     	GPIO_InitTypeDef GPIO_InitStructure;
;;;30       SPI_InitTypeDef  SPI_InitStructure;
;;;31       /*!< SD_SPI_CS_GPIO, SD_SPI_MOSI_GPIO, SD_SPI_MISO_GPIO, SD_SPI_DETECT_GPIO 
;;;32            and SD_SPI_SCK_GPIO Periph clock enable 
;;;33     	// 	 RCC_AHBPeriphClockCmd(FLASH_CS_PIN_SCK|FLASH_SCK_PIN_SCK|FLASH_MISO_PIN_SCK | FLASH_MOSI_PIN_SCK, ENABLE);
;;;34       !< SD_SPI Periph clock enable */
;;;35     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);
000004  2101              MOVS     r1,#1
000006  b088              SUB      sp,sp,#0x20           ;28
000008  0308              LSLS     r0,r1,#12
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;36     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00000e  2602              MOVS     r6,#2
000010  f88d6005          STRB     r6,[sp,#5]
;;;37     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000014  2701              MOVS     r7,#1
;;;38     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;39     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//inv
000016  2004              MOVS     r0,#4
;;;40     	GPIO_Init(GPIOD, &GPIO_InitStructure);//
000018  f8df80ac          LDR      r8,|L3.200|
00001c  f88d7004          STRB     r7,[sp,#4]            ;37
000020  2400              MOVS     r4,#0                 ;38
000022  9000              STR      r0,[sp,#0]
000024  f88d4006          STRB     r4,[sp,#6]            ;38
000028  4669              MOV      r1,sp
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       GPIO_Init
;;;41       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;//PB3~5复用功能输出	
;;;42       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000030  f88d6004          STRB     r6,[sp,#4]
;;;43       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000034  f88d4006          STRB     r4,[sp,#6]
;;;44       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000038  2003              MOVS     r0,#3
00003a  f88d0005          STRB     r0,[sp,#5]
;;;45       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
;;;46       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
00003e  4e23              LDR      r6,|L3.204|
000040  2538              MOVS     r5,#0x38              ;41
000042  9500              STR      r5,[sp,#0]            ;42
000044  f88d7007          STRB     r7,[sp,#7]            ;45
000048  4669              MOV      r1,sp
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       GPIO_Init
;;;47     	
;;;48       GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1); //PC2复用为 SPI1
000050  2205              MOVS     r2,#5
000052  2103              MOVS     r1,#3
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;49     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1); //PBC3复用为 SPI1
00005a  2205              MOVS     r2,#5
00005c  2104              MOVS     r1,#4
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       GPIO_PinAFConfig
;;;50     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1); //PB13复用为 SPI1
000064  2205              MOVS     r2,#5
000066  4611              MOV      r1,r2
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       GPIO_PinAFConfig
;;;51     	
;;;52     	AD7689_CNV_1;
00006e  2104              MOVS     r1,#4
000070  4640              MOV      r0,r8
000072  f7fffffe          BL       GPIO_SetBits
;;;53     	AD7689_Delay();
000076  f7fffffe          BL       AD7689_Delay
;;;54     	AD7689_CNV_0;
00007a  2104              MOVS     r1,#4
00007c  4640              MOV      r0,r8
00007e  f7fffffe          BL       GPIO_ResetBits
;;;55     	//这里只针对SPI口初始化
;;;56       SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000082  f8ad4008          STRH     r4,[sp,#8]
;;;57     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000086  f44f7082          MOV      r0,#0x104
00008a  f8ad000a          STRH     r0,[sp,#0xa]
;;;58     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;		//设置SPI的数据大小:SPI发送接收16位帧结构
00008e  14f0              ASRS     r0,r6,#19
000090  f8ad000c          STRH     r0,[sp,#0xc]
;;;59     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为高电平
;;;60     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000094  f8ad4010          STRH     r4,[sp,#0x10]
;;;61     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000098  1080              ASRS     r0,r0,#2
;;;62     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
00009a  f8ad5014          STRH     r5,[sp,#0x14]
00009e  f8ad400e          STRH     r4,[sp,#0xe]          ;59
0000a2  f8ad0012          STRH     r0,[sp,#0x12]         ;61
;;;63     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
0000a6  f8ad4016          STRH     r4,[sp,#0x16]
;;;64     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
0000aa  2007              MOVS     r0,#7
;;;65     	SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
0000ac  4c08              LDR      r4,|L3.208|
0000ae  f8ad0018          STRH     r0,[sp,#0x18]         ;64
0000b2  a902              ADD      r1,sp,#8
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       SPI_Init
;;;66     	
;;;67     	SPI_Cmd(SPI1, ENABLE); //使能SPI外设
0000ba  2101              MOVS     r1,#1
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       SPI_Cmd
;;;68     }
0000c2  b008              ADD      sp,sp,#0x20
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;69     
                          ENDP

                  |L3.200|
                          DCD      0x40020c00
                  |L3.204|
                          DCD      0x40020400
                  |L3.208|
                          DCD      0x40013000

                          AREA ||i.AD7689_Scan_CH||, CODE, READONLY, ALIGN=2

                  AD7689_Scan_CH PROC
;;;143    }
;;;144    void AD7689_Scan_CH(void)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;145    {
;;;146    // 	vu8 i,f,d;
;;;147    // 	vu32 sum1;
;;;148    // 	vu16 var_chI,var_chV;
;;;149    // 	static vu8 I_cont,V_cont;
;;;150    // 	for(i=0;i<7;i++)
;;;151    // 	{
;;;152    // 		AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
;;;153    // 		R1mon_value=AD7689_Buffer[0];
;;;154    // 		R2mon_value=AD7689_Buffer[1];
;;;155    // 		Vmon_Load_value=AD7689_Buffer[2];
;;;156    // 		Imon_Load_value=AD7689_Buffer[3];
;;;157    // 		Rmon_value=AD	7689_Buffer[4];
;;;158    // 		Vmon_POWE_value=AD7689_Buffer[5];
;;;159    // 		Imon_POWE_value=AD7689_Buffer[6];
;;;160    
;;;161    	vu8 i,f,d;
;;;162    	vu32 sum1;
;;;163    	vu16 var_chI,var_chI1,var_chV,var_chV1,var_chR;
;;;164    	static vu8 I_cont,I1_cont,V_cont,R_cont,V1_cont;
;;;165    	for(i=0;i<7;i++)
000004  2500              MOVS     r5,#0
000006  f88d5000          STRB     r5,[sp,#0]
;;;166    	{
;;;167    		AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
00000a  4c42              LDR      r4,|L4.276|
;;;168    		R1mon_value=AD7689_Buffer[0];
00000c  4e42              LDR      r6,|L4.280|
;;;169    		R2mon_value=AD7689_Buffer[1];
00000e  4f43              LDR      r7,|L4.284|
;;;170    		Vmon_Load_value=AD7689_Buffer[2];
000010  f8df810c          LDR      r8,|L4.288|
;;;171    		var_chI=AD7689_Buffer[3];
;;;172    //		Imon_Load_value = AD7689_Buffer[3];
;;;173    		var_chR=AD7689_Buffer[4];
;;;174    		Vmon_POWE_value=AD7689_Buffer[5];
000014  f8df910c          LDR      r9,|L4.292|
;;;175    		Imon_POWE_value=AD7689_Buffer[6];
000018  f8dfa10c          LDR      r10,|L4.296|
00001c  e020              B        |L4.96|
                  |L4.30|
00001e  f89d1000          LDRB     r1,[sp,#0]            ;167
000022  2001              MOVS     r0,#1                 ;167
000024  f7fffffe          BL       SPI_AD7689_Read
000028  f89d1000          LDRB     r1,[sp,#0]            ;167
00002c  f8240011          STRH     r0,[r4,r1,LSL #1]     ;167
000030  8820              LDRH     r0,[r4,#0]            ;168  ; AD7689_Buffer
000032  8030              STRH     r0,[r6,#0]            ;168
000034  8860              LDRH     r0,[r4,#2]            ;169  ; AD7689_Buffer
000036  8038              STRH     r0,[r7,#0]            ;169
000038  88a1              LDRH     r1,[r4,#4]            ;170  ; AD7689_Buffer
00003a  f8a81000          STRH     r1,[r8,#0]            ;170
00003e  88e0              LDRH     r0,[r4,#6]            ;171  ; AD7689_Buffer
000040  f8ad0008          STRH     r0,[sp,#8]            ;171
000044  8920              LDRH     r0,[r4,#8]            ;173  ; AD7689_Buffer
000046  f8ad000c          STRH     r0,[sp,#0xc]          ;173
00004a  8961              LDRH     r1,[r4,#0xa]          ;174  ; AD7689_Buffer
00004c  f8a91000          STRH     r1,[r9,#0]            ;174
000050  89a1              LDRH     r1,[r4,#0xc]  ; AD7689_Buffer
000052  f8aa1000          STRH     r1,[r10,#0]
000056  f89d0000          LDRB     r0,[sp,#0]            ;165
00005a  1c40              ADDS     r0,r0,#1              ;165
00005c  f88d0000          STRB     r0,[sp,#0]            ;165
                  |L4.96|
000060  f89d0000          LDRB     r0,[sp,#0]            ;165
000064  2807              CMP      r0,#7                 ;165
000066  d3da              BCC      |L4.30|
;;;176    	}
;;;177    	
;;;178    	Ad7689_Fit_Rmon[R_cont++]=var_chR;
000068  f8bd100c          LDRH     r1,[sp,#0xc]
00006c  4c2f              LDR      r4,|L4.300|
00006e  7860              LDRB     r0,[r4,#1]  ; R_cont
000070  4e28              LDR      r6,|L4.276|
000072  36d8              ADDS     r6,r6,#0xd8
000074  eb060240          ADD      r2,r6,r0,LSL #1
000078  1c40              ADDS     r0,r0,#1
00007a  7060              STRB     r0,[r4,#1]
00007c  8011              STRH     r1,[r2,#0]
;;;179    	if(R_cont==100)
00007e  7860              LDRB     r0,[r4,#1]  ; R_cont
000080  2864              CMP      r0,#0x64
000082  d11d              BNE      |L4.192|
;;;180    	{
;;;181    		R_cont=0;
000084  7065              STRB     r5,[r4,#1]
;;;182    		sum1=0;
;;;183    		BubbleSort(Ad7689_Fit_Rmon, 100);
000086  2164              MOVS     r1,#0x64
000088  4630              MOV      r0,r6
00008a  9500              STR      r5,[sp,#0]
00008c  f7fffffe          BL       BubbleSort
;;;184    		for(f=40;f<50;f++)
000090  2028              MOVS     r0,#0x28
000092  e009              B        |L4.168|
                  |L4.148|
;;;185    		{
;;;186    			sum1 +=Ad7689_Fit_Rmon[f];
000094  f89d0004          LDRB     r0,[sp,#4]
000098  9900              LDR      r1,[sp,#0]
00009a  f8360010          LDRH     r0,[r6,r0,LSL #1]
00009e  4408              ADD      r0,r0,r1
0000a0  9000              STR      r0,[sp,#0]            ;184
0000a2  f89d0004          LDRB     r0,[sp,#4]            ;184
0000a6  1c40              ADDS     r0,r0,#1              ;184
                  |L4.168|
0000a8  f88d0004          STRB     r0,[sp,#4]            ;184
0000ac  f89d0004          LDRB     r0,[sp,#4]            ;184
0000b0  2832              CMP      r0,#0x32              ;184
0000b2  d3ef              BCC      |L4.148|
;;;187    		}
;;;188    		Rmon_value=sum1/10;//
0000b4  9800              LDR      r0,[sp,#0]
0000b6  210a              MOVS     r1,#0xa
0000b8  fbb0f0f1          UDIV     r0,r0,r1
0000bc  491c              LDR      r1,|L4.304|
0000be  8008              STRH     r0,[r1,#0]
                  |L4.192|
;;;189    	}
;;;190    
;;;191    	Ad7689_Fit_Imon[I_cont++] = var_chI;
0000c0  f8bd2008          LDRH     r2,[sp,#8]
0000c4  7821              LDRB     r1,[r4,#0]  ; I_cont
0000c6  4813              LDR      r0,|L4.276|
0000c8  3010              ADDS     r0,r0,#0x10
0000ca  eb000341          ADD      r3,r0,r1,LSL #1
0000ce  1c49              ADDS     r1,r1,#1
0000d0  7021              STRB     r1,[r4,#0]
0000d2  801a              STRH     r2,[r3,#0]
;;;192    	if(I_cont==30)
0000d4  7821              LDRB     r1,[r4,#0]  ; I_cont
0000d6  291e              CMP      r1,#0x1e
0000d8  d11a              BNE      |L4.272|
;;;193    	{
;;;194    		I_cont=0;
0000da  7025              STRB     r5,[r4,#0]
;;;195    		sum1=0;
;;;196    		for(f=0;f<30;f++)
0000dc  9500              STR      r5,[sp,#0]
0000de  f88d5004          STRB     r5,[sp,#4]
0000e2  e00b              B        |L4.252|
                  |L4.228|
;;;197    		{
;;;198    			sum1 +=Ad7689_Fit_Imon[f];
0000e4  f89d1004          LDRB     r1,[sp,#4]
0000e8  f8301011          LDRH     r1,[r0,r1,LSL #1]
0000ec  9a00              LDR      r2,[sp,#0]
0000ee  4411              ADD      r1,r1,r2
0000f0  9100              STR      r1,[sp,#0]            ;196
0000f2  f89d1004          LDRB     r1,[sp,#4]            ;196
0000f6  1c49              ADDS     r1,r1,#1              ;196
0000f8  f88d1004          STRB     r1,[sp,#4]            ;196
                  |L4.252|
0000fc  f89d1004          LDRB     r1,[sp,#4]            ;196
000100  291e              CMP      r1,#0x1e              ;196
000102  d3ef              BCC      |L4.228|
;;;199    		}
;;;200    		Imon_Load_value=sum1/30;//
000104  9800              LDR      r0,[sp,#0]
000106  211e              MOVS     r1,#0x1e
000108  fbb0f0f1          UDIV     r0,r0,r1
00010c  4909              LDR      r1,|L4.308|
00010e  8008              STRH     r0,[r1,#0]
                  |L4.272|
;;;201    	}
;;;202    //	if(I_cont==10)
;;;203    //	{
;;;204    //		I_cont=0;
;;;205    //		sum1=0;
;;;206    //		for(f=0;f<10;f++)
;;;207    //		{
;;;208    //			sum1 +=Ad7689_Fit_Imon[f];
;;;209    //		}
;;;210    //		Imon_Load_value=sum1/10;//
;;;211    //	}
;;;212    }
000110  e8bd87ff          POP      {r0-r10,pc}
                          ENDP

                  |L4.276|
                          DCD      ||.bss||
                  |L4.280|
                          DCD      R1mon_value
                  |L4.284|
                          DCD      R2mon_value
                  |L4.288|
                          DCD      Vmon_Load_value
                  |L4.292|
                          DCD      Vmon_POWE_value
                  |L4.296|
                          DCD      Imon_POWE_value
                  |L4.300|
                          DCD      ||.data||
                  |L4.304|
                          DCD      Rmon_value
                  |L4.308|
                          DCD      Imon_Load_value

                          AREA ||i.AD7689_TransferByte||, CODE, READONLY, ALIGN=2

                  AD7689_TransferByte PROC
;;;93     /************************************************************************/
;;;94     vu16 AD7689_TransferByte(vu16 uiTxData1)
000000  b511              PUSH     {r0,r4,lr}
;;;95     {
;;;96     	vu16 uiRxData;
;;;97     	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  4c0d              LDR      r4,|L5.56|
000004  b081              SUB      sp,sp,#4              ;95
                  |L5.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L5.6|
;;;98     	SPI_I2S_SendData(SPI1,uiTxData1);
000012  f8bd1004          LDRH     r1,[sp,#4]
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_I2S_SendData
                  |L5.28|
;;;99     	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L5.28|
;;;100    	uiRxData = SPI_I2S_ReceiveData(SPI1);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;101    	return uiRxData;
000032  f8bd0000          LDRH     r0,[sp,#0]
;;;102    }
000036  bd1c              POP      {r2-r4,pc}
;;;103    
                          ENDP

                  |L5.56|
                          DCD      0x40013000

                          AREA ||i.BubbleSort||, CODE, READONLY, ALIGN=1

                  BubbleSort PROC
;;;111    //冒泡排序
;;;112    void BubbleSort(uint16_t A[], uint16_t n)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;113    {
000004  4688              MOV      r8,r1
000006  4606              MOV      r6,r0
;;;114    	int i,j;
;;;115        for (j = 0; j < n - 1; j++)         // 每次最大元素就像气泡一样"浮"到数组的最后
000008  2500              MOVS     r5,#0
00000a  f1a10901          SUB      r9,r1,#1
00000e  e015              B        |L6.60|
                  |L6.16|
;;;116        {
;;;117            for (i = 0; i < n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移
000010  2400              MOVS     r4,#0
000012  eba80705          SUB      r7,r8,r5
000016  1e7f              SUBS     r7,r7,#1
000018  e00d              B        |L6.54|
                  |L6.26|
;;;118            {
;;;119                if (A[i] > A[i + 1])            // 如果条件改成A[i] >= A[i + 1],则变为不稳定的排序算法
00001a  eb060144          ADD      r1,r6,r4,LSL #1
00001e  f8360014          LDRH     r0,[r6,r4,LSL #1]
000022  8849              LDRH     r1,[r1,#2]
000024  4288              CMP      r0,r1
000026  d905              BLS      |L6.52|
;;;120                {
;;;121                    Swap(A, i, i + 1);
000028  1c60              ADDS     r0,r4,#1
00002a  b282              UXTH     r2,r0
00002c  b2a1              UXTH     r1,r4
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       Swap
                  |L6.52|
000034  1c64              ADDS     r4,r4,#1
                  |L6.54|
000036  42a7              CMP      r7,r4                 ;117
000038  dcef              BGT      |L6.26|
00003a  1c6d              ADDS     r5,r5,#1              ;117
                  |L6.60|
00003c  454d              CMP      r5,r9                 ;115
00003e  dbe7              BLT      |L6.16|
;;;122                }
;;;123            }
;;;124        }
;;;125    }
000040  e8bd83f0          POP      {r4-r9,pc}
;;;126    /************************************************************************/
                          ENDP


                          AREA ||i.SPI_AD7689_Read||, CODE, READONLY, ALIGN=2

                  SPI_AD7689_Read PROC
;;;69     
;;;70     vu16 SPI_AD7689_Read(vu16 AD7689_CFG, vu16 AD7689_INx)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;71     {
000002  b082              SUB      sp,sp,#8
;;;72     	vu16 AD7689_Config=0;
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;73     	vu16 AD7689_Data;
;;;74     	vu8 i;
;;;75     	AD7689_Config = AD7689_CFG<<13|AD7689_INCC<<10|AD7689_INx<<7|AD7689_BW<<6|AD7689_REF<<3|AD7689_SEQ<<1|AD7689_RB;//写入配置参数
00000a  f8bd0008          LDRH     r0,[sp,#8]
00000e  f8bd100c          LDRH     r1,[sp,#0xc]
000012  0340              LSLS     r0,r0,#13
000014  ea4010c1          ORR      r0,r0,r1,LSL #7
000018  f6410159          MOV      r1,#0x1859
00001c  4308              ORRS     r0,r0,r1
00001e  f8ad0000          STRH     r0,[sp,#0]
;;;76     	AD7689_Config <<=2;
000022  f8bd0000          LDRH     r0,[sp,#0]
000026  f64f71ff          MOV      r1,#0xffff
00002a  ea010080          AND      r0,r1,r0,LSL #2
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;77     	AD7689_CNV_0;
000032  4c0b              LDR      r4,|L7.96|
000034  2104              MOVS     r1,#4
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       GPIO_ResetBits
;;;78       AD7689_Data=AD7689_TransferByte(AD7689_Config);
00003c  f8bd0000          LDRH     r0,[sp,#0]
000040  f7fffffe          BL       AD7689_TransferByte
000044  f8ad0000          STRH     r0,[sp,#0]
;;;79     	AD7689_Delay(); 
000048  f7fffffe          BL       AD7689_Delay
;;;80     	AD7689_CNV_1;
00004c  2104              MOVS     r1,#4
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       GPIO_SetBits
;;;81     	AD7689_Delay(); 
000054  f7fffffe          BL       AD7689_Delay
;;;82     	return AD7689_Data;
000058  f8bd0000          LDRH     r0,[sp,#0]
;;;83     }
00005c  b004              ADD      sp,sp,#0x10
00005e  bd10              POP      {r4,pc}
;;;84     
                          ENDP

                  |L7.96|
                          DCD      0x40020c00

                          AREA ||i.Swap||, CODE, READONLY, ALIGN=1

                  Swap PROC
;;;103    
;;;104    void Swap(uint16_t A[], uint16_t i, uint16_t j)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106        int temp = A[i];
000002  f8303011          LDRH     r3,[r0,r1,LSL #1]
;;;107        A[i] = A[j];
000006  f8304012          LDRH     r4,[r0,r2,LSL #1]
00000a  f8204011          STRH     r4,[r0,r1,LSL #1]
;;;108        A[j] = temp;
00000e  f8203012          STRH     r3,[r0,r2,LSL #1]
;;;109    }
000012  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  AD7689_Buffer
                          %        16
                  Ad7689_Fit_Imon
                          %        200
                  Ad7689_Fit_Rmon
                          %        200

                          AREA ||area_number.11||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.11||, ||.bss||
                  Ad7689_Fit_Vmon
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  I_cont
000000  00                DCB      0x00
                  R_cont
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\AD7689.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_AD7689_c_5bab55e0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REVSH|
#line 144
|__asm___8_AD7689_c_5bab55e0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
