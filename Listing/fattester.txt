; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\fattester.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\fattester.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\fattester.crf ..\FATFS\exfuns\fattester.c]
                          THUMB

                          AREA ||i.mf_close||, CODE, READONLY, ALIGN=2

                  mf_close PROC
;;;38     //返回值:执行结果
;;;39     u8 mf_close(void)
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41     	f_close(file);
000002  4803              LDR      r0,|L1.16|
000004  6800              LDR      r0,[r0,#0]  ; file
000006  f7fffffe          BL       f_close
;;;42     	return 0;
00000a  2000              MOVS     r0,#0
;;;43     }
00000c  bd10              POP      {r4,pc}
;;;44     //读出数据
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      file

                          AREA ||i.mf_closedir||, CODE, READONLY, ALIGN=2

                  mf_closedir PROC
;;;109    //返回值:执行结果
;;;110    u8 mf_closedir(void)
000000  4801              LDR      r0,|L2.8|
;;;111    {
;;;112    	return f_closedir(&dir);	
000002  f7ffbffe          B.W      f_closedir
;;;113    }
;;;114    //打读取文件夹
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||dir||

                          AREA ||i.mf_fmkfs||, CODE, READONLY, ALIGN=1

                  mf_fmkfs PROC
;;;251    //返回值:执行结果
;;;252    u8 mf_fmkfs(u8* path,u8 mode,u16 au)
000000  f7ffbffe          B.W      f_mkfs
;;;253    {
;;;254    	return f_mkfs((const TCHAR*)path,mode,au);//格式化,drv:盘符;mode:模式;au:簇大小
;;;255    } 
;;;256    //删除文件/目录
                          ENDP


                          AREA ||i.mf_getlabel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  mf_getlabel PROC
;;;273    //path:磁盘路径，比如"0:"、"1:"  
;;;274    void mf_getlabel(u8 *path)
000000  b510              PUSH     {r4,lr}
;;;275    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;276    	u8 buf[20];
;;;277    	u32 sn=0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;278    	u8 res;
;;;279    	res=f_getlabel ((const TCHAR *)path,(TCHAR *)buf,(DWORD*)&sn);
00000a  466a              MOV      r2,sp
00000c  a901              ADD      r1,sp,#4
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       f_getlabel
000014  4601              MOV      r1,r0
;;;280    	if(res==FR_OK)
000016  b121              CBZ      r1,|L4.34|
;;;281    	{
;;;282    		printf("\r\n磁盘%s 的盘符为:%s\r\n",path,buf);
;;;283    		printf("磁盘%s 的序列号:%X\r\n\r\n",path,sn); 
;;;284    	}else printf("\r\n获取失败，错误码:%X\r\n",res);
000018  a007              ADR      r0,|L4.56|
00001a  f7fffffe          BL       __2printf
                  |L4.30|
;;;285    }
00001e  b006              ADD      sp,sp,#0x18
000020  bd10              POP      {r4,pc}
                  |L4.34|
000022  aa01              ADD      r2,sp,#4              ;282
000024  4621              MOV      r1,r4                 ;282
000026  a00a              ADR      r0,|L4.80|
000028  f7fffffe          BL       __2printf
00002c  4621              MOV      r1,r4                 ;283
00002e  a00e              ADR      r0,|L4.104|
000030  9a00              LDR      r2,[sp,#0]            ;283
000032  f7fffffe          BL       __2printf
000036  e7f2              B        |L4.30|
;;;286    //设置盘符（磁盘名字），最长11个字符！！，支持数字和大写字母组合以及汉字等
                          ENDP

                  |L4.56|
000038  0d0abbf1          DCB      "\r\n",187,241,200,161,202,167,176,220,163,172,180,237,206
00003c  c8a1caa7
000040  b0dca3ac
000044  b4edce  
000047  f3c2eb3a          DCB      243,194,235,":%X\r\n",0
00004b  25580d0a
00004f  00      
                  |L4.80|
000050  0d0ab4c5          DCB      "\r\n",180,197,197,204,"%s ",181,196,197,204,183,251,206
000054  c5cc2573
000058  20b5c4c5
00005c  ccb7fbce
000060  aa3a2573          DCB      170,":%s\r\n",0
000064  0d0a00  
000067  00                DCB      0
                  |L4.104|
000068  b4c5c5cc          DCB      180,197,197,204,"%s ",181,196,208,242,193,208,186,197,":"
00006c  257320b5
000070  c4d0f2c1
000074  d0bac53a
000078  25580d0a          DCB      "%X\r\n\r\n",0
00007c  0d0a00  
00007f  00                DCB      0

                          AREA ||i.mf_gets||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  mf_gets PROC
;;;299    //size:要读取的长度
;;;300    void mf_gets(u16 size)
000000  b510              PUSH     {r4,lr}
;;;301    {
;;;302     	TCHAR* rbuf;
;;;303    	rbuf=f_gets((TCHAR*)fatbuf,size,file);
000002  4601              MOV      r1,r0
000004  4a07              LDR      r2,|L5.36|
000006  4808              LDR      r0,|L5.40|
000008  6812              LDR      r2,[r2,#0]  ; file
00000a  6800              LDR      r0,[r0,#0]  ; fatbuf
00000c  f7fffffe          BL       f_gets
000010  4601              MOV      r1,r0
;;;304    	if(*rbuf==0)return  ;//没有数据读到
000012  7808              LDRB     r0,[r1,#0]
000014  2800              CMP      r0,#0
000016  d004              BEQ      |L5.34|
;;;305    	else
;;;306    	{
;;;307    		printf("\r\nThe String Readed Is:%s\r\n",rbuf);  	  
000018  e8bd4010          POP      {r4,lr}
00001c  a003              ADR      r0,|L5.44|
00001e  f7ffbffe          B.W      __2printf
                  |L5.34|
;;;308    	}			    	
;;;309    }
000022  bd10              POP      {r4,pc}
;;;310    //需要_USE_STRFUNC>=1
                          ENDP

                  |L5.36|
                          DCD      file
                  |L5.40|
                          DCD      fatbuf
                  |L5.44|
00002c  0d0a5468          DCB      "\r\nThe String Readed Is:%s\r\n",0
000030  65205374
000034  72696e67
000038  20526561
00003c  64656420
000040  49733a25
000044  730d0a00

                          AREA ||i.mf_lseek||, CODE, READONLY, ALIGN=2

                  mf_lseek PROC
;;;223    //返回值:执行结果.
;;;224    u8 mf_lseek(u32 offset)
000000  4601              MOV      r1,r0
;;;225    {
;;;226    	return f_lseek(file,offset);
000002  4802              LDR      r0,|L6.12|
000004  6800              LDR      r0,[r0,#0]  ; file
000006  f7ffbffe          B.W      f_lseek
;;;227    }
;;;228    //读取文件当前读写指针的位置.
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      file

                          AREA ||i.mf_mkdir||, CODE, READONLY, ALIGN=1

                  mf_mkdir PROC
;;;242    //返回值:执行结果
;;;243    u8 mf_mkdir(u8*pname)
000000  f7ffbffe          B.W      f_mkdir
;;;244    {
;;;245    	return f_mkdir((const TCHAR *)pname);
;;;246    }
;;;247    //格式化
                          ENDP


                          AREA ||i.mf_mount||, CODE, READONLY, ALIGN=2

                  mf_mount PROC
;;;22     //返回值:执行结果
;;;23     u8 mf_mount(u8* path,u8 mt)
000000  4603              MOV      r3,r0
;;;24     {		   
;;;25     	return f_mount(fs[2],(const TCHAR*)path,mt); 
000002  4803              LDR      r0,|L8.16|
000004  460a              MOV      r2,r1
000006  4619              MOV      r1,r3
000008  6880              LDR      r0,[r0,#8]  ; fs
00000a  f7ffbffe          B.W      f_mount
;;;26     }
;;;27     //打开路径下的文件
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      ||fs||

                          AREA ||i.mf_open||, CODE, READONLY, ALIGN=2

                  mf_open PROC
;;;30     //返回值:执行结果
;;;31     u8 mf_open(u8*path,u8 mode)
000000  460a              MOV      r2,r1
;;;32     {
;;;33     	u8 res;	 
;;;34     	res=f_open(file,(const TCHAR*)path,mode);//打开文件夹
000002  4601              MOV      r1,r0
000004  4801              LDR      r0,|L9.12|
000006  6800              LDR      r0,[r0,#0]  ; file
000008  f7ffbffe          B.W      f_open
;;;35     	return res;
;;;36     } 
;;;37     //关闭文件
                          ENDP

                  |L9.12|
                          DCD      file

                          AREA ||i.mf_opendir||, CODE, READONLY, ALIGN=2

                  mf_opendir PROC
;;;103    //返回值:执行结果
;;;104    u8 mf_opendir(u8* path)
000000  4601              MOV      r1,r0
;;;105    {
;;;106    	return f_opendir(&dir,(const TCHAR*)path);	
000002  4801              LDR      r0,|L10.8|
000004  f7ffbffe          B.W      f_opendir
;;;107    }
;;;108    //关闭目录 
                          ENDP

                  |L10.8|
                          DCD      ||dir||

                          AREA ||i.mf_putc||, CODE, READONLY, ALIGN=2

                  mf_putc PROC
;;;313    //返回值:执行结果
;;;314    u8 mf_putc(u8 c)
000000  b510              PUSH     {r4,lr}
;;;315    {
;;;316    	return f_putc((TCHAR)c,file);
000002  4903              LDR      r1,|L11.16|
000004  6809              LDR      r1,[r1,#0]  ; file
000006  f7fffffe          BL       f_putc
00000a  b2c0              UXTB     r0,r0
;;;317    }
00000c  bd10              POP      {r4,pc}
;;;318    //写字符串到文件
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      file

                          AREA ||i.mf_puts||, CODE, READONLY, ALIGN=2

                  mf_puts PROC
;;;320    //返回值:写入的字符串长度
;;;321    u8 mf_puts(u8*c)
000000  b510              PUSH     {r4,lr}
;;;322    {
;;;323    	return f_puts((TCHAR*)c,file);
000002  4903              LDR      r1,|L12.16|
000004  6809              LDR      r1,[r1,#0]  ; file
000006  f7fffffe          BL       f_puts
00000a  b2c0              UXTB     r0,r0
;;;324    }
00000c  bd10              POP      {r4,pc}
;;;325    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      file

                          AREA ||i.mf_read||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mf_read PROC
;;;46     //返回值:执行结果
;;;47     u8 mf_read(u16 len)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;48     {
000004  4680              MOV      r8,r0
;;;49     	u16 i,t;
;;;50     	u8 res=0;
000006  2700              MOVS     r7,#0
;;;51     	u16 tlen=0;
000008  2500              MOVS     r5,#0
;;;52     	printf("\r\nRead file data is:\r\n");
00000a  a031              ADR      r0,|L13.208|
00000c  f7fffffe          BL       __2printf
;;;53     	for(i=0;i<len/512;i++)
000010  2600              MOVS     r6,#0
;;;54     	{
;;;55     		res=f_read(file,fatbuf,512,&br);
000012  f8dfb0d4          LDR      r11,|L13.232|
000016  f8dfa0d4          LDR      r10,|L13.236|
00001a  f8df90d4          LDR      r9,|L13.240|
00001e  e023              B        |L13.104|
                  |L13.32|
000020  4b33              LDR      r3,|L13.240|
000022  f44f7200          MOV      r2,#0x200
000026  f8da1000          LDR      r1,[r10,#0]  ; fatbuf
00002a  f8db0000          LDR      r0,[r11,#0]  ; file
00002e  f7fffffe          BL       f_read
000032  4607              MOV      r7,r0
;;;56     		if(res)
000034  b127              CBZ      r7,|L13.64|
;;;57     		{
;;;58     			printf("Read Error:%d\r\n",res);
000036  4639              MOV      r1,r7
000038  a02e              ADR      r0,|L13.244|
00003a  f7fffffe          BL       __2printf
;;;59     			break;
00003e  e016              B        |L13.110|
                  |L13.64|
;;;60     		}else
;;;61     		{
;;;62     			tlen+=br;
000040  f8b90000          LDRH     r0,[r9,#0]  ; br
000044  4428              ADD      r0,r0,r5
000046  b285              UXTH     r5,r0
;;;63     			for(t=0;t<br;t++)printf("%c",fatbuf[t]); 
000048  2400              MOVS     r4,#0
00004a  e007              B        |L13.92|
                  |L13.76|
00004c  f8da0000          LDR      r0,[r10,#0]  ; fatbuf
000050  5d01              LDRB     r1,[r0,r4]
000052  a02c              ADR      r0,|L13.260|
000054  f7fffffe          BL       __2printf
000058  1c64              ADDS     r4,r4,#1
00005a  b2a4              UXTH     r4,r4
                  |L13.92|
00005c  f8d90000          LDR      r0,[r9,#0]  ; br
000060  4284              CMP      r4,r0
000062  d3f3              BCC      |L13.76|
000064  1c76              ADDS     r6,r6,#1              ;53
000066  b2b6              UXTH     r6,r6                 ;53
                  |L13.104|
000068  ebb62f58          CMP      r6,r8,LSR #9          ;53
00006c  d3d8              BCC      |L13.32|
                  |L13.110|
;;;64     		}
;;;65     	}
;;;66     	if(len%512)
00006e  ea5f50c8          LSLS     r0,r8,#23
000072  d021              BEQ      |L13.184|
;;;67     	{
;;;68     		res=f_read(file,fatbuf,len%512,&br);
000074  f3c80208          UBFX     r2,r8,#0,#9
000078  4b1d              LDR      r3,|L13.240|
00007a  f8da1000          LDR      r1,[r10,#0]  ; fatbuf
00007e  f8db0000          LDR      r0,[r11,#0]  ; file
000082  f7fffffe          BL       f_read
000086  4607              MOV      r7,r0
;;;69     		if(res)	//读数据出错了
000088  b127              CBZ      r7,|L13.148|
;;;70     		{
;;;71     			printf("\r\nRead Error:%d\r\n",res);   
00008a  4639              MOV      r1,r7
00008c  a01e              ADR      r0,|L13.264|
00008e  f7fffffe          BL       __2printf
000092  e011              B        |L13.184|
                  |L13.148|
;;;72     		}else
;;;73     		{
;;;74     			tlen+=br;
000094  f8b90000          LDRH     r0,[r9,#0]  ; br
000098  4428              ADD      r0,r0,r5
00009a  b285              UXTH     r5,r0
;;;75     			for(t=0;t<br;t++)printf("%c",fatbuf[t]); 
00009c  2400              MOVS     r4,#0
00009e  e007              B        |L13.176|
                  |L13.160|
0000a0  f8da0000          LDR      r0,[r10,#0]  ; fatbuf
0000a4  5d01              LDRB     r1,[r0,r4]
0000a6  a017              ADR      r0,|L13.260|
0000a8  f7fffffe          BL       __2printf
0000ac  1c64              ADDS     r4,r4,#1
0000ae  b2a4              UXTH     r4,r4
                  |L13.176|
0000b0  f8d90000          LDR      r0,[r9,#0]  ; br
0000b4  4284              CMP      r4,r0
0000b6  d3f3              BCC      |L13.160|
                  |L13.184|
;;;76     		}	 
;;;77     	}
;;;78     	if(tlen)printf("\r\nReaded data len:%d\r\n",tlen);//读到的数据长度
0000b8  b11d              CBZ      r5,|L13.194|
0000ba  4629              MOV      r1,r5
0000bc  a017              ADR      r0,|L13.284|
0000be  f7fffffe          BL       __2printf
                  |L13.194|
;;;79     	printf("Read data over\r\n");	 
0000c2  a01c              ADR      r0,|L13.308|
0000c4  f7fffffe          BL       __2printf
;;;80     	return res;
0000c8  4638              MOV      r0,r7
;;;81     }
0000ca  e8bd9ff0          POP      {r4-r12,pc}
;;;82     //写入数据
                          ENDP

0000ce  0000              DCW      0x0000
                  |L13.208|
0000d0  0d0a5265          DCB      "\r\nRead file data is:\r\n",0
0000d4  61642066
0000d8  696c6520
0000dc  64617461
0000e0  2069733a
0000e4  0d0a00  
0000e7  00                DCB      0
                  |L13.232|
                          DCD      file
                  |L13.236|
                          DCD      fatbuf
                  |L13.240|
                          DCD      ||br||
                  |L13.244|
0000f4  52656164          DCB      "Read Error:%d\r\n",0
0000f8  20457272
0000fc  6f723a25
000100  640d0a00
                  |L13.260|
000104  256300            DCB      "%c",0
000107  00                DCB      0
                  |L13.264|
000108  0d0a5265          DCB      "\r\nRead Error:%d\r\n",0
00010c  61642045
000110  72726f72
000114  3a25640d
000118  0a00    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L13.284|
00011c  0d0a5265          DCB      "\r\nReaded data len:%d\r\n",0
000120  61646564
000124  20646174
000128  61206c65
00012c  6e3a2564
000130  0d0a00  
000133  00                DCB      0
                  |L13.308|
000134  52656164          DCB      "Read data over\r\n",0
000138  20646174
00013c  61206f76
000140  65720d0a
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0

                          AREA ||i.mf_readdir||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  mf_readdir PROC
;;;115    //返回值:执行结果
;;;116    u8 mf_readdir(void)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
;;;118    	u8 res;
;;;119    	char *fn;			 
;;;120    #if _USE_LFN
;;;121     	fileinfo.lfsize = _MAX_LFN * 2 + 1;
000002  4c2a              LDR      r4,|L14.172|
000004  f24011ff          MOV      r1,#0x1ff
000008  61e1              STR      r1,[r4,#0x1c]  ; fileinfo
;;;122    	fileinfo.lfname = mymalloc(SRAMIN,fileinfo.lfsize);
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       mymalloc
000010  61a0              STR      r0,[r4,#0x18]  ; fileinfo
;;;123    #endif		  
;;;124    	res=f_readdir(&dir,&fileinfo);//读取一个文件的信息
000012  4621              MOV      r1,r4
000014  4826              LDR      r0,|L14.176|
000016  f7fffffe          BL       f_readdir
00001a  4605              MOV      r5,r0
;;;125    	if(res!=FR_OK||fileinfo.fname[0]==0)
00001c  b92d              CBNZ     r5,|L14.42|
00001e  7a60              LDRB     r0,[r4,#9]  ; fileinfo
000020  b118              CBZ      r0,|L14.42|
;;;126    	{
;;;127    		myfree(SRAMIN,fileinfo.lfname);
;;;128    		return res;//读完了.
;;;129    	}
;;;130    #if _USE_LFN
;;;131    	fn=*fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;
000022  69a6              LDR      r6,[r4,#0x18]  ; fileinfo
000024  7830              LDRB     r0,[r6,#0]
000026  b940              CBNZ     r0,|L14.58|
000028  e005              B        |L14.54|
                  |L14.42|
00002a  2000              MOVS     r0,#0                 ;127
00002c  69a1              LDR      r1,[r4,#0x18]         ;127  ; fileinfo
00002e  f7fffffe          BL       myfree
000032  4628              MOV      r0,r5                 ;128
;;;132    #else
;;;133    	fn=fileinfo.fname;;
;;;134    #endif	
;;;135    	printf("\r\n DIR info:\r\n");
;;;136    
;;;137    	printf("dir.id:%d\r\n",dir.id);
;;;138    	printf("dir.index:%d\r\n",dir.index);
;;;139    	printf("dir.sclust:%d\r\n",dir.sclust);
;;;140    	printf("dir.clust:%d\r\n",dir.clust);
;;;141    	printf("dir.sect:%d\r\n",dir.sect);	  
;;;142    
;;;143    	printf("\r\n");
;;;144    	printf("File Name is:%s\r\n",fn);
;;;145    	printf("File Size is:%d\r\n",fileinfo.fsize);
;;;146    	printf("File data is:%d\r\n",fileinfo.fdate);
;;;147    	printf("File time is:%d\r\n",fileinfo.ftime);
;;;148    	printf("File Attr is:%d\r\n",fileinfo.fattrib);
;;;149    	printf("\r\n");
;;;150    	myfree(SRAMIN,fileinfo.lfname);
;;;151    	return 0;
;;;152    }			 
000034  bd70              POP      {r4-r6,pc}
                  |L14.54|
000036  4e1d              LDR      r6,|L14.172|
000038  3609              ADDS     r6,r6,#9              ;131
                  |L14.58|
00003a  a01e              ADR      r0,|L14.180|
00003c  f7fffffe          BL       __2printf
000040  4d1b              LDR      r5,|L14.176|
000042  a020              ADR      r0,|L14.196|
000044  88a9              LDRH     r1,[r5,#4]            ;137  ; dir
000046  f7fffffe          BL       __2printf
00004a  88e9              LDRH     r1,[r5,#6]            ;138  ; dir
00004c  a020              ADR      r0,|L14.208|
00004e  f7fffffe          BL       __2printf
000052  a023              ADR      r0,|L14.224|
000054  68a9              LDR      r1,[r5,#8]            ;139  ; dir
000056  f7fffffe          BL       __2printf
00005a  a025              ADR      r0,|L14.240|
00005c  68e9              LDR      r1,[r5,#0xc]          ;140  ; dir
00005e  f7fffffe          BL       __2printf
000062  a027              ADR      r0,|L14.256|
000064  6929              LDR      r1,[r5,#0x10]         ;141  ; dir
000066  f7fffffe          BL       __2printf
00006a  a015              ADR      r0,|L14.192|
00006c  f7fffffe          BL       __2printf
000070  4631              MOV      r1,r6                 ;144
000072  a027              ADR      r0,|L14.272|
000074  f7fffffe          BL       __2printf
000078  a02a              ADR      r0,|L14.292|
00007a  6821              LDR      r1,[r4,#0]            ;145  ; fileinfo
00007c  f7fffffe          BL       __2printf
000080  88a1              LDRH     r1,[r4,#4]            ;146  ; fileinfo
000082  a02d              ADR      r0,|L14.312|
000084  f7fffffe          BL       __2printf
000088  88e1              LDRH     r1,[r4,#6]            ;147  ; fileinfo
00008a  a030              ADR      r0,|L14.332|
00008c  f7fffffe          BL       __2printf
000090  7a21              LDRB     r1,[r4,#8]            ;148  ; fileinfo
000092  a033              ADR      r0,|L14.352|
000094  f7fffffe          BL       __2printf
000098  a009              ADR      r0,|L14.192|
00009a  f7fffffe          BL       __2printf
00009e  2000              MOVS     r0,#0                 ;150
0000a0  69a1              LDR      r1,[r4,#0x18]         ;150  ; fileinfo
0000a2  f7fffffe          BL       myfree
0000a6  2000              MOVS     r0,#0                 ;151
0000a8  bd70              POP      {r4-r6,pc}
;;;153    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L14.172|
                          DCD      fileinfo
                  |L14.176|
                          DCD      ||dir||
                  |L14.180|
0000b4  0d0a2044          DCB      "\r\n DIR info:"
0000b8  49522069
0000bc  6e666f3a
                  |L14.192|
0000c0  0d0a00            DCB      "\r\n",0
0000c3  00                DCB      0
                  |L14.196|
0000c4  6469722e          DCB      "dir.id:%d\r\n",0
0000c8  69643a25
0000cc  640d0a00
                  |L14.208|
0000d0  6469722e          DCB      "dir.index:%d\r\n",0
0000d4  696e6465
0000d8  783a2564
0000dc  0d0a00  
0000df  00                DCB      0
                  |L14.224|
0000e0  6469722e          DCB      "dir.sclust:%d\r\n",0
0000e4  73636c75
0000e8  73743a25
0000ec  640d0a00
                  |L14.240|
0000f0  6469722e          DCB      "dir.clust:%d\r\n",0
0000f4  636c7573
0000f8  743a2564
0000fc  0d0a00  
0000ff  00                DCB      0
                  |L14.256|
000100  6469722e          DCB      "dir.sect:%d\r\n",0
000104  73656374
000108  3a25640d
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L14.272|
000110  46696c65          DCB      "File Name is:%s\r\n",0
000114  204e616d
000118  65206973
00011c  3a25730d
000120  0a00    
000122  00                DCB      0
000123  00                DCB      0
                  |L14.292|
000124  46696c65          DCB      "File Size is:%d\r\n",0
000128  2053697a
00012c  65206973
000130  3a25640d
000134  0a00    
000136  00                DCB      0
000137  00                DCB      0
                  |L14.312|
000138  46696c65          DCB      "File data is:%d\r\n",0
00013c  20646174
000140  61206973
000144  3a25640d
000148  0a00    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L14.332|
00014c  46696c65          DCB      "File time is:%d\r\n",0
000150  2074696d
000154  65206973
000158  3a25640d
00015c  0a00    
00015e  00                DCB      0
00015f  00                DCB      0
                  |L14.352|
000160  46696c65          DCB      "File Attr is:%d\r\n",0
000164  20417474
000168  72206973
00016c  3a25640d
000170  0a00    
000172  00                DCB      0
000173  00                DCB      0

                          AREA ||i.mf_rename||, CODE, READONLY, ALIGN=1

                  mf_rename PROC
;;;267    //返回值:执行结果
;;;268    u8 mf_rename(u8 *oldname,u8* newname)
000000  f7ffbffe          B.W      f_rename
;;;269    {
;;;270    	return  f_rename((const TCHAR *)oldname,(const TCHAR *)newname);
;;;271    }
;;;272    //获取盘符（磁盘名字）
                          ENDP


                          AREA ||i.mf_scan_files||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mf_scan_files PROC
;;;156     //返回值:执行结果
;;;157    u8 mf_scan_files(u8 * path)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;158    {
000004  4607              MOV      r7,r0
;;;159    	FRESULT res;	  
;;;160        char *fn;   /* This function is assuming non-Unicode cfg. */
;;;161    #if _USE_LFN
;;;162     	fileinfo.lfsize = _MAX_LFN * 2 + 1;
000006  4d17              LDR      r5,|L16.100|
000008  f24011ff          MOV      r1,#0x1ff
00000c  61e9              STR      r1,[r5,#0x1c]  ; fileinfo
;;;163    	fileinfo.lfname = mymalloc(SRAMIN,fileinfo.lfsize);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       mymalloc
000014  61a8              STR      r0,[r5,#0x18]  ; fileinfo
;;;164    #endif		  
;;;165    
;;;166        res = f_opendir(&dir,(const TCHAR*)path); //打开一个目录
000016  4639              MOV      r1,r7
000018  4813              LDR      r0,|L16.104|
00001a  f7fffffe          BL       f_opendir
00001e  4604              MOV      r4,r0
;;;167        if (res == FR_OK) 
000020  b9cc              CBNZ     r4,|L16.86|
;;;168    	{	
;;;169    		printf("\r\n"); 
000022  a012              ADR      r0,|L16.108|
000024  f7fffffe          BL       __2printf
;;;170    		while(1)
;;;171    		{
;;;172    	        res = f_readdir(&dir, &fileinfo);                   //读取目录下的一个文件
;;;173    	        if (res != FR_OK || fileinfo.fname[0] == 0) break;  //错误了/到末尾了,退出
;;;174    	        //if (fileinfo.fname[0] == '.') continue;             //忽略上级目录
;;;175    #if _USE_LFN
;;;176            	fn = *fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;
000028  f1050609          ADD      r6,r5,#9
                  |L16.44|
00002c  490d              LDR      r1,|L16.100|
00002e  480e              LDR      r0,|L16.104|
000030  f7fffffe          BL       f_readdir
000034  4604              MOV      r4,r0                 ;172
000036  b974              CBNZ     r4,|L16.86|
000038  7a68              LDRB     r0,[r5,#9]            ;173  ; fileinfo
00003a  b160              CBZ      r0,|L16.86|
00003c  69ac              LDR      r4,[r5,#0x18]  ; fileinfo
00003e  7820              LDRB     r0,[r4,#0]
000040  b900              CBNZ     r0,|L16.68|
000042  4634              MOV      r4,r6
                  |L16.68|
;;;177    #else							   
;;;178            	fn = fileinfo.fname;
;;;179    #endif	                                              /* It is a file. */
;;;180    			printf("%s/", path);//打印路径	
000044  4639              MOV      r1,r7
000046  a00a              ADR      r0,|L16.112|
000048  f7fffffe          BL       __2printf
;;;181    			printf("%s\r\n",  fn);//打印文件名	  
00004c  4621              MOV      r1,r4
00004e  a009              ADR      r0,|L16.116|
000050  f7fffffe          BL       __2printf
000054  e7ea              B        |L16.44|
                  |L16.86|
;;;182    		} 
;;;183        }	  
;;;184    	myfree(SRAMIN,fileinfo.lfname);
000056  2000              MOVS     r0,#0
000058  69a9              LDR      r1,[r5,#0x18]  ; fileinfo
00005a  f7fffffe          BL       myfree
;;;185        return res;	  
00005e  4620              MOV      r0,r4
;;;186    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;187    //显示剩余容量
                          ENDP

                  |L16.100|
                          DCD      fileinfo
                  |L16.104|
                          DCD      ||dir||
                  |L16.108|
00006c  0d0a00            DCB      "\r\n",0
00006f  00                DCB      0
                  |L16.112|
000070  25732f00          DCB      "%s/",0
                  |L16.116|
000074  25730d0a          DCB      "%s\r\n",0
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.mf_setlabel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  mf_setlabel PROC
;;;287    //path:磁盘号+名字，比如"0:ALIENTEK"、"1:OPENEDV"  
;;;288    void mf_setlabel(u8 *path)
000000  b510              PUSH     {r4,lr}
;;;289    {
000002  4604              MOV      r4,r0
;;;290    	u8 res;
;;;291    	res=f_setlabel ((const TCHAR *)path);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_setlabel
00000a  4601              MOV      r1,r0
;;;292    	if(res==FR_OK)
00000c  b121              CBZ      r1,|L17.24|
;;;293    	{
;;;294    		printf("\r\n磁盘盘符设置成功:%s\r\n",path);
;;;295    	}else printf("\r\n磁盘盘符设置失败，错误码:%X\r\n",res);
00000e  e8bd4010          POP      {r4,lr}
000012  a004              ADR      r0,|L17.36|
000014  f7ffbffe          B.W      __2printf
                  |L17.24|
000018  4621              MOV      r1,r4                 ;294
00001a  e8bd4010          POP      {r4,lr}               ;294
00001e  a009              ADR      r0,|L17.68|
000020  f7ffbffe          B.W      __2printf
;;;296    } 
;;;297    
                          ENDP

                  |L17.36|
000024  0d0ab4c5          DCB      "\r\n",180,197,197,204,197,204,183,251,201,232,214,195,202
000028  c5ccc5cc
00002c  b7fbc9e8
000030  d6c3ca  
000033  a7b0dca3          DCB      167,176,220,163,172,180,237,206,243,194,235,":%X\r\n",0
000037  acb4edce
00003b  f3c2eb3a
00003f  25580d0a
000043  00      
                  |L17.68|
000044  0d0ab4c5          DCB      "\r\n",180,197,197,204,197,204,183,251,201,232,214,195,179
000048  c5ccc5cc
00004c  b7fbc9e8
000050  d6c3b3  
000053  c9b9a63a          DCB      201,185,166,":%s\r\n",0
000057  25730d0a
00005b  00      

                          AREA ||i.mf_showfree||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  mf_showfree PROC
;;;189    //返回值:剩余容量(字节)
;;;190    u32 mf_showfree(u8 *drv)
000000  b51c              PUSH     {r2-r4,lr}
;;;191    {
000002  4603              MOV      r3,r0
;;;192    	FATFS *fs1;
;;;193    	u8 res;
;;;194        u32 fre_clust=0, fre_sect=0, tot_sect=0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  2400              MOVS     r4,#0
;;;195        //得到磁盘信息及空闲簇数量
;;;196        res = f_getfree((const TCHAR*)drv,(DWORD*)&fre_clust, &fs1);
00000a  aa01              ADD      r2,sp,#4
00000c  4669              MOV      r1,sp
00000e  4618              MOV      r0,r3
000010  f7fffffe          BL       f_getfree
;;;197        if(res==0)
000014  b9a0              CBNZ     r0,|L18.64|
;;;198    	{											   
;;;199    	    tot_sect = (fs1->n_fatent - 2) * fs1->csize;//得到总扇区数
000016  9901              LDR      r1,[sp,#4]
000018  6948              LDR      r0,[r1,#0x14]
00001a  788c              LDRB     r4,[r1,#2]
00001c  1e80              SUBS     r0,r0,#2
00001e  4360              MULS     r0,r4,r0
;;;200    	    fre_sect = fre_clust * fs1->csize;			//得到空闲扇区数	   
000020  9900              LDR      r1,[sp,#0]
000022  434c              MULS     r4,r1,r4
;;;201    #if _MAX_SS!=512
;;;202    		tot_sect*=fs1->ssize/512;
;;;203    		fre_sect*=fs1->ssize/512;
;;;204    #endif	  
;;;205    		if(tot_sect<20480)//总容量小于10M
000024  f5b04fa0          CMP      r0,#0x5000
000028  d205              BCS      |L18.54|
;;;206    		{
;;;207    		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
;;;208    		    printf("\r\n磁盘总容量:%d KB\r\n"
00002a  0841              LSRS     r1,r0,#1
00002c  0862              LSRS     r2,r4,#1
00002e  a005              ADR      r0,|L18.68|
000030  f7fffffe          BL       __2printf
000034  e004              B        |L18.64|
                  |L18.54|
;;;209    		           "可用空间:%d KB\r\n",
;;;210    		           tot_sect>>1,fre_sect>>1);
;;;211    		}else
;;;212    		{
;;;213    		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
;;;214    		    printf("\r\n磁盘总容量:%d MB\r\n"
000036  0ac1              LSRS     r1,r0,#11
000038  0ae2              LSRS     r2,r4,#11
00003a  a00c              ADR      r0,|L18.108|
00003c  f7fffffe          BL       __2printf
                  |L18.64|
;;;215    		           "可用空间:%d MB\r\n",
;;;216    		           tot_sect>>11,fre_sect>>11);
;;;217    		}
;;;218    	}
;;;219    	return fre_sect;
000040  4620              MOV      r0,r4
;;;220    }		    
000042  bd1c              POP      {r2-r4,pc}
;;;221    //文件读写指针偏移
                          ENDP

                  |L18.68|
000044  0d0ab4c5          DCB      "\r\n",180,197,197,204,215,220,200,221,193,191,":%d KB\r"
000048  c5ccd7dc
00004c  c8ddc1bf
000050  3a256420
000054  4b420d  
000057  0abfc9d3          DCB      "\n",191,201,211,195,191,213,188,228,":%d KB\r\n",0
00005b  c3bfd5bc
00005f  e43a2564
000063  204b420d
000067  0a00    
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L18.108|
00006c  0d0ab4c5          DCB      "\r\n",180,197,197,204,215,220,200,221,193,191,":%d MB\r"
000070  c5ccd7dc
000074  c8ddc1bf
000078  3a256420
00007c  4d420d  
00007f  0abfc9d3          DCB      "\n",191,201,211,195,191,213,188,228,":%d MB\r\n",0
000083  c3bfd5bc
000087  e43a2564
00008b  204d420d
00008f  0a00    
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.mf_size||, CODE, READONLY, ALIGN=2

                  mf_size PROC
;;;235    //返回值:文件大小
;;;236    u32 mf_size(void)
000000  4801              LDR      r0,|L19.8|
;;;237    {
;;;238    	return f_size(file);
000002  6800              LDR      r0,[r0,#0]  ; file
000004  68c0              LDR      r0,[r0,#0xc]
;;;239    } 
000006  4770              BX       lr
;;;240    //创建目录
                          ENDP

                  |L19.8|
                          DCD      file

                          AREA ||i.mf_tell||, CODE, READONLY, ALIGN=2

                  mf_tell PROC
;;;229    //返回值:位置
;;;230    u32 mf_tell(void)
000000  4801              LDR      r0,|L20.8|
;;;231    {
;;;232    	return f_tell(file);
000002  6800              LDR      r0,[r0,#0]  ; file
000004  6880              LDR      r0,[r0,#8]
;;;233    }
000006  4770              BX       lr
;;;234    //读取文件大小
                          ENDP

                  |L20.8|
                          DCD      file

                          AREA ||i.mf_unlink||, CODE, READONLY, ALIGN=1

                  mf_unlink PROC
;;;258    //返回值:执行结果
;;;259    u8 mf_unlink(u8 *pname)
000000  f7ffbffe          B.W      f_unlink
;;;260    {
;;;261    	return  f_unlink((const TCHAR *)pname);
;;;262    }
;;;263    
                          ENDP


                          AREA ||i.mf_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  mf_write PROC
;;;85     //返回值:执行结果
;;;86     u8 mf_write(u8*dat,u16 len)
000000  b570              PUSH     {r4-r6,lr}
;;;87     {			    
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;88     	u8 res;	   					   
;;;89     
;;;90     	printf("\r\nBegin Write file...\r\n");
000006  a00f              ADR      r0,|L22.68|
000008  f7fffffe          BL       __2printf
;;;91     	printf("Write data len:%d\r\n",len);	 
00000c  4621              MOV      r1,r4
00000e  a013              ADR      r0,|L22.92|
000010  f7fffffe          BL       __2printf
;;;92     	res=f_write(file,dat,len,&bw);
000014  4817              LDR      r0,|L22.116|
000016  4b16              LDR      r3,|L22.112|
000018  4622              MOV      r2,r4
00001a  4629              MOV      r1,r5
00001c  6800              LDR      r0,[r0,#0]  ; file
00001e  f7fffffe          BL       f_write
000022  4604              MOV      r4,r0
;;;93     	if(res)
000024  b124              CBZ      r4,|L22.48|
;;;94     	{
;;;95     		printf("Write Error:%d\r\n",res);   
000026  4621              MOV      r1,r4
000028  a013              ADR      r0,|L22.120|
00002a  f7fffffe          BL       __2printf
00002e  e004              B        |L22.58|
                  |L22.48|
;;;96     	}else printf("Writed data len:%d\r\n",bw);
000030  480f              LDR      r0,|L22.112|
000032  6801              LDR      r1,[r0,#0]  ; bw
000034  a015              ADR      r0,|L22.140|
000036  f7fffffe          BL       __2printf
                  |L22.58|
;;;97     	printf("Write data over.\r\n");
00003a  a01a              ADR      r0,|L22.164|
00003c  f7fffffe          BL       __2printf
;;;98     	return res;
000040  4620              MOV      r0,r4
;;;99     }
000042  bd70              POP      {r4-r6,pc}
;;;100    
                          ENDP

                  |L22.68|
000044  0d0a4265          DCB      "\r\nBegin Write file...\r\n",0
000048  67696e20
00004c  57726974
000050  65206669
000054  6c652e2e
000058  2e0d0a00
                  |L22.92|
00005c  57726974          DCB      "Write data len:%d\r\n",0
000060  65206461
000064  7461206c
000068  656e3a25
00006c  640d0a00
                  |L22.112|
                          DCD      ||bw||
                  |L22.116|
                          DCD      file
                  |L22.120|
000078  57726974          DCB      "Write Error:%d\r\n",0
00007c  65204572
000080  726f723a
000084  25640d0a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L22.140|
00008c  57726974          DCB      "Writed data len:%d\r\n",0
000090  65642064
000094  61746120
000098  6c656e3a
00009c  25640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L22.164|
0000a4  57726974          DCB      "Write data over.\r\n",0
0000a8  65206461
0000ac  7461206f
0000b0  7665722e
0000b4  0d0a00  
0000b7  00                DCB      0

;*** Start embedded assembler ***

#line 1 "..\\FATFS\\exfuns\\fattester.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_fattester_c_mf_mount____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_fattester_c_mf_mount____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_fattester_c_mf_mount____REVSH|
#line 144
|__asm___11_fattester_c_mf_mount____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
