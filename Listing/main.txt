; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\main.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\main.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=537 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\main.crf --no_multibyte_chars ..\User\main.c]
                          THUMB

                          AREA ||i.Ds18b20Check||, CODE, READONLY, ALIGN=2

                  Ds18b20Check PROC
;;;136    //返回0:存在
;;;137    u8 Ds18b20Check(void) 	   
000000  b570              PUSH     {r4-r6,lr}
;;;138    {   
;;;139        u8 retry=0;
000002  2400              MOVS     r4,#0
;;;140        DS18B20_IN();//SET PA0 INPUT	 
000004  f7fffffe          BL       DS18B20_IN
;;;141        while (DS18B20_DQ_IN&&retry<200)
000008  f44f6580          MOV      r5,#0x400
00000c  4e12              LDR      r6,|L1.88|
00000e  e004              B        |L1.26|
                  |L1.16|
000010  1c64              ADDS     r4,r4,#1
;;;142        {
;;;143            retry++;
000012  b2e4              UXTB     r4,r4
;;;144            Delay_usS(3);
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       Delay_usS
                  |L1.26|
00001a  4629              MOV      r1,r5                 ;141
00001c  4630              MOV      r0,r6                 ;141
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  b110              CBZ      r0,|L1.42|
000024  2cc8              CMP      r4,#0xc8              ;141
000026  d3f3              BCC      |L1.16|
000028  e00f              B        |L1.74|
                  |L1.42|
;;;145        };	 
;;;146        if(retry>=200)
00002a  2cc8              CMP      r4,#0xc8
00002c  d20d              BCS      |L1.74|
;;;147    		return 1;
;;;148        else 
;;;149    		retry=0;
00002e  2400              MOVS     r4,#0
000030  e004              B        |L1.60|
                  |L1.50|
000032  1c64              ADDS     r4,r4,#1
;;;150        while (!DS18B20_DQ_IN&&retry<240)
;;;151        {
;;;152            retry++;
000034  b2e4              UXTB     r4,r4
;;;153            Delay_usS(3);
000036  2003              MOVS     r0,#3
000038  f7fffffe          BL       Delay_usS
                  |L1.60|
00003c  4629              MOV      r1,r5                 ;150
00003e  4630              MOV      r0,r6                 ;150
000040  f7fffffe          BL       GPIO_ReadInputDataBit
000044  b118              CBZ      r0,|L1.78|
;;;154        };
;;;155        if(retry>=240)
000046  2cf0              CMP      r4,#0xf0
000048  d304              BCC      |L1.84|
                  |L1.74|
;;;156    		return 1;	    
00004a  2001              MOVS     r0,#1
;;;157        return 0;
;;;158    }
00004c  bd70              POP      {r4-r6,pc}
                  |L1.78|
00004e  2cf0              CMP      r4,#0xf0              ;150
000050  d3ef              BCC      |L1.50|
000052  e7fa              B        |L1.74|
                  |L1.84|
000054  2000              MOVS     r0,#0                 ;157
000056  bd70              POP      {r4-r6,pc}
;;;159    
                          ENDP

                  |L1.88|
                          DCD      0x40020400

                          AREA ||i.Ds18b20GetTemp||, CODE, READONLY, ALIGN=2

                  Ds18b20GetTemp PROC
;;;252    //返回值：温度值 （-550~1250） 
;;;253    short Ds18b20GetTemp(void)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
;;;255        u8 temp;
;;;256        u8 TL,TH;
;;;257        short tem;
;;;258        Ds18b20Start ();                    // ds1820 start convert
000002  f7fffffe          BL       Ds18b20Start
;;;259        Ds18b20Rst();
000006  f7fffffe          BL       Ds18b20Rst
;;;260        Ds18b20Check();	 
00000a  f7fffffe          BL       Ds18b20Check
;;;261        Ds18b20WriteByte(0xcc);// skip rom
00000e  20cc              MOVS     r0,#0xcc
000010  f7fffffe          BL       Ds18b20WriteByte
;;;262        Ds18b20WriteByte(0xbe);// convert	    
000014  20be              MOVS     r0,#0xbe
000016  f7fffffe          BL       Ds18b20WriteByte
;;;263        TL=Ds18b20ReadByte(); // LSB   
00001a  f7fffffe          BL       Ds18b20ReadByte
00001e  4604              MOV      r4,r0
;;;264        TH=Ds18b20ReadByte(); // MSB  
000020  f7fffffe          BL       Ds18b20ReadByte
;;;265        
;;;266        if(TH>7)
000024  2807              CMP      r0,#7
000026  d905              BLS      |L2.52|
;;;267        {
;;;268            TH=~TH;
000028  43c0              MVNS     r0,r0
;;;269            TL=~TL; 
00002a  43e1              MVNS     r1,r4
00002c  b2c0              UXTB     r0,r0                 ;268
00002e  b2cc              UXTB     r4,r1
;;;270            temp=0;//温度为负  
000030  2500              MOVS     r5,#0
000032  e000              B        |L2.54|
                  |L2.52|
;;;271        }else temp=1;//温度为正	  	  
000034  2501              MOVS     r5,#1
                  |L2.54|
;;;272        tem=TH; //获得高八位
;;;273        tem<<=8;    
;;;274        tem+=TL;//获得底八位
000036  eb042000          ADD      r0,r4,r0,LSL #8
00003a  b200              SXTH     r0,r0
;;;275        tem=(short)((float)tem*0.625);//转换     
00003c  f7fffffe          BL       __aeabi_i2d
000040  ed9f1b06          VLDR     d1,|L2.92|
000044  ec532b11          VMOV     r2,r3,d1
000048  f7fffffe          BL       __aeabi_dmul
00004c  f7fffffe          BL       __aeabi_d2iz
000050  b200              SXTH     r0,r0
;;;276        if(temp)return tem; //返回温度值
000052  2d00              CMP      r5,#0
000054  d101              BNE      |L2.90|
;;;277        else return -tem;    
000056  4240              RSBS     r0,r0,#0
000058  b200              SXTH     r0,r0
                  |L2.90|
;;;278    } 
00005a  bd70              POP      {r4-r6,pc}
;;;279    
                          ENDP

                  |L2.92|
00005c  00000000          DCFD     0x3fe4000000000000 ; 0.625
000060  3fe40000

                          AREA ||i.Ds18b20Init||, CODE, READONLY, ALIGN=2

                  Ds18b20Init PROC
;;;162    //返回0:存在    	 
;;;163    u8 Ds18b20Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;164    {
;;;165        GPIO_InitTypeDef  GPIO_InitStructure;
;;;166        
;;;167       GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
000002  2002              MOVS     r0,#2
000004  f88d0005          STRB     r0,[sp,#5]
;;;168    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000008  2001              MOVS     r0,#1
00000a  f88d0004          STRB     r0,[sp,#4]
;;;169    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00000e  2000              MOVS     r0,#0
;;;170    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//DS18B20
;;;171    	GPIO_Init(GPIOB, &GPIO_InitStructure);//
000010  4d09              LDR      r5,|L3.56|
000012  f88d0006          STRB     r0,[sp,#6]            ;169
000016  f44f6480          MOV      r4,#0x400             ;170
00001a  4669              MOV      r1,sp
00001c  4628              MOV      r0,r5
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       GPIO_Init
;;;172        
;;;173        GPIO_SetBits(GPIOB,GPIO_Pin_10);    //输出1
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       GPIO_SetBits
;;;174        
;;;175        Ds18b20Rst();
00002c  f7fffffe          BL       Ds18b20Rst
;;;176        
;;;177        return Ds18b20Check();
000030  f7fffffe          BL       Ds18b20Check
;;;178    }  
000034  bd7c              POP      {r2-r6,pc}
;;;179    
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      0x40020400

                          AREA ||i.Ds18b20ReadBit||, CODE, READONLY, ALIGN=2

                  Ds18b20ReadBit PROC
;;;181    //返回值：1/0
;;;182    u8 Ds18b20ReadBit(void) 			 // read one bit
000000  b570              PUSH     {r4-r6,lr}
;;;183    {
;;;184        u8 data;
;;;185        DS18B20_OUT();//SET PA0 OUTPUT
000002  f7fffffe          BL       DS18B20_OUT
;;;186        DS18B20_DQ_OUT_0; 
000006  4d10              LDR      r5,|L4.72|
000008  f44f6480          MOV      r4,#0x400
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       GPIO_ResetBits
;;;187        Delay_usS(5);
000014  2005              MOVS     r0,#5
000016  f7fffffe          BL       Delay_usS
;;;188        DS18B20_DQ_OUT_1; 
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       GPIO_SetBits
;;;189        DS18B20_IN();//SET PA0 INPUT
000022  f7fffffe          BL       DS18B20_IN
;;;190        Delay_usS(30);
000026  201e              MOVS     r0,#0x1e
000028  f7fffffe          BL       Delay_usS
;;;191        if(DS18B20_DQ_IN)
00002c  4621              MOV      r1,r4
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       GPIO_ReadInputDataBit
000034  b108              CBZ      r0,|L4.58|
;;;192    		data=1;
000036  2401              MOVS     r4,#1
000038  e000              B        |L4.60|
                  |L4.58|
;;;193        else 
;;;194    		data=0;	 
00003a  2400              MOVS     r4,#0
                  |L4.60|
;;;195        Delay_usS(125);           
00003c  207d              MOVS     r0,#0x7d
00003e  f7fffffe          BL       Delay_usS
;;;196        return data;
000042  4620              MOV      r0,r4
;;;197    }
000044  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
                          DCD      0x40020400

                          AREA ||i.Ds18b20ReadByte||, CODE, READONLY, ALIGN=1

                  Ds18b20ReadByte PROC
;;;200    //返回值：读到的数据
;;;201    u8 Ds18b20ReadByte(void)    // read one byte
000000  b570              PUSH     {r4-r6,lr}
;;;202    {        
;;;203        u8 i,j,dat;
;;;204        dat=0;
000002  2500              MOVS     r5,#0
;;;205        for (i=1;i<=8;i++) 
000004  2401              MOVS     r4,#1
                  |L5.6|
;;;206        {
;;;207            j=Ds18b20ReadBit();
000006  f7fffffe          BL       Ds18b20ReadBit
;;;208            dat=(j<<7)|(dat>>1);
00000a  01c0              LSLS     r0,r0,#7
00000c  1c64              ADDS     r4,r4,#1
00000e  ea400055          ORR      r0,r0,r5,LSR #1
000012  b2e4              UXTB     r4,r4                 ;205
000014  b2c5              UXTB     r5,r0
000016  2c08              CMP      r4,#8                 ;205
000018  d9f5              BLS      |L5.6|
;;;209        }						    
;;;210        return dat;
00001a  4628              MOV      r0,r5
;;;211    }
00001c  bd70              POP      {r4-r6,pc}
;;;212    
                          ENDP


                          AREA ||i.Ds18b20Rst||, CODE, READONLY, ALIGN=2

                  Ds18b20Rst PROC
;;;124    //复位DS18B20
;;;125    void Ds18b20Rst(void)	   
000000  b570              PUSH     {r4-r6,lr}
;;;126    {                 
;;;127        DS18B20_OUT(); //SET PA0 OUTPUT
000002  f7fffffe          BL       DS18B20_OUT
;;;128        DS18B20_DQ_OUT_0; //拉低DQ
000006  4d0a              LDR      r5,|L6.48|
000008  f44f6480          MOV      r4,#0x400
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       GPIO_ResetBits
;;;129        Delay_usS(1250);    //拉低750us
000014  f24040e2          MOV      r0,#0x4e2
000018  f7fffffe          BL       Delay_usS
;;;130        DS18B20_DQ_OUT_1; //DQ=1 
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       GPIO_SetBits
;;;131        Delay_usS(38);     //15US
000024  e8bd4070          POP      {r4-r6,lr}
000028  2026              MOVS     r0,#0x26
00002a  f7ffbffe          B.W      Delay_usS
;;;132    }
;;;133    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40020400

                          AREA ||i.Ds18b20Start||, CODE, READONLY, ALIGN=1

                  Ds18b20Start PROC
;;;241    
;;;242    void Ds18b20Start(void)// ds1820 start convert
000000  b510              PUSH     {r4,lr}
;;;243    {   						               
;;;244        Ds18b20Rst();	   
000002  f7fffffe          BL       Ds18b20Rst
;;;245        Ds18b20Check();	 
000006  f7fffffe          BL       Ds18b20Check
;;;246        Ds18b20WriteByte(0xcc);// skip rom
00000a  20cc              MOVS     r0,#0xcc
00000c  f7fffffe          BL       Ds18b20WriteByte
;;;247        Ds18b20WriteByte(0x44);// convert
000010  e8bd4010          POP      {r4,lr}
000014  2044              MOVS     r0,#0x44
000016  f7ffbffe          B.W      Ds18b20WriteByte
;;;248    } 
;;;249    
                          ENDP


                          AREA ||i.Ds18b20WriteByte||, CODE, READONLY, ALIGN=2

                  Ds18b20WriteByte PROC
;;;214    //dat：要写入的字节
;;;215    void Ds18b20WriteByte(u8 dat)     
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;216    {             
000004  4605              MOV      r5,r0
;;;217        u8 j;
;;;218        u8 testb;
;;;219        DS18B20_OUT();//SET PA0 OUTPUT;
000006  f7fffffe          BL       DS18B20_OUT
;;;220        for (j=1;j<=8;j++) 
00000a  2401              MOVS     r4,#1
;;;221        {
;;;222            testb=dat&0x01;
;;;223            dat=dat>>1;
;;;224            if (testb) 
;;;225            {
;;;226                DS18B20_DQ_OUT_0;// Write 1
00000c  4e12              LDR      r6,|L8.88|
00000e  02a7              LSLS     r7,r4,#10
                  |L8.16|
000010  f0150f01          TST      r5,#1                 ;222
000014  ea4f0555          LSR      r5,r5,#1              ;223
;;;227                Delay_usS(5);                            
;;;228                DS18B20_DQ_OUT_1;
;;;229                Delay_usS(150);             
;;;230            }
;;;231            else 
;;;232            {
;;;233                DS18B20_DQ_OUT_0;// Write 0
000018  4639              MOV      r1,r7
00001a  4630              MOV      r0,r6
00001c  d00a              BEQ      |L8.52|
00001e  f7fffffe          BL       GPIO_ResetBits
000022  2005              MOVS     r0,#5                 ;227
000024  f7fffffe          BL       Delay_usS
000028  4639              MOV      r1,r7                 ;228
00002a  4630              MOV      r0,r6                 ;228
00002c  f7fffffe          BL       GPIO_SetBits
000030  2096              MOVS     r0,#0x96              ;229
000032  e009              B        |L8.72|
                  |L8.52|
000034  f7fffffe          BL       GPIO_ResetBits
;;;234                Delay_usS(150);             
000038  2096              MOVS     r0,#0x96
00003a  f7fffffe          BL       Delay_usS
;;;235                DS18B20_DQ_OUT_1;
00003e  4639              MOV      r1,r7
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       GPIO_SetBits
;;;236                Delay_usS(5);                          
000046  2005              MOVS     r0,#5
                  |L8.72|
000048  f7fffffe          BL       Delay_usS
00004c  1c64              ADDS     r4,r4,#1
00004e  b2e4              UXTB     r4,r4                 ;220
000050  2c08              CMP      r4,#8                 ;220
000052  d9dd              BLS      |L8.16|
;;;237            }
;;;238        }
;;;239    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;240    
                          ENDP

                  |L8.88|
                          DCD      0x40020400

                          AREA ||i.JumpBoot||, CODE, READONLY, ALIGN=2

                  JumpBoot PROC
;;;293    
;;;294    void JumpBoot(u8 flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;295    {
;;;296      	void (*pUserApp)(void);
;;;297      uint32_t JumpAddress;
;;;298    	if(flag==55)
000004  2837              CMP      r0,#0x37
000006  d17d              BNE      |L9.260|
;;;299      {		
;;;300    	__asm("CPSID  I");
;;;301            
;;;302    		JumpAddress = *(volatile uint32_t*) (0x08000000+4);
000008  f04f6400          MOV      r4,#0x8000000
00000c  b672              CPSID    i                     ;300
00000e  6865              LDR      r5,[r4,#4]
;;;303    		pUserApp = (void (*)(void)) JumpAddress;
;;;304    		TIM_Cmd(TIM1, DISABLE);	
000010  4e5c              LDR      r6,|L9.388|
000012  2100              MOVS     r1,#0
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       TIM_Cmd
;;;305    		TIM_DeInit(TIM1);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       TIM_DeInit
;;;306    		TIM_ITConfig(TIM1,TIM_IT_Update,DISABLE);
000020  2200              MOVS     r2,#0
000022  2101              MOVS     r1,#1
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       TIM_ITConfig
;;;307    		TIM_Cmd(TIM2, DISABLE);	
00002a  00e6              LSLS     r6,r4,#3
00002c  2100              MOVS     r1,#0
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       TIM_Cmd
;;;308    		TIM_DeInit(TIM2);
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       TIM_DeInit
;;;309    		TIM_ITConfig(TIM2,TIM_IT_Update,DISABLE);
00003a  2200              MOVS     r2,#0
00003c  2101              MOVS     r1,#1
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       TIM_ITConfig
;;;310    		TIM_Cmd(TIM3, DISABLE);	
000044  4e50              LDR      r6,|L9.392|
000046  2100              MOVS     r1,#0
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       TIM_Cmd
;;;311    		TIM_DeInit(TIM3);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       TIM_DeInit
;;;312    		TIM_ITConfig(TIM3,TIM_IT_Update,DISABLE);
000054  2200              MOVS     r2,#0
000056  2101              MOVS     r1,#1
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       TIM_ITConfig
;;;313    		TIM_Cmd(TIM4,DISABLE);
00005e  4e4b              LDR      r6,|L9.396|
000060  2100              MOVS     r1,#0
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       TIM_Cmd
;;;314    		TIM_DeInit(TIM4);
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       TIM_DeInit
;;;315    		TIM_ITConfig(TIM4,TIM_IT_Update,DISABLE);
00006e  2200              MOVS     r2,#0
000070  2101              MOVS     r1,#1
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       TIM_ITConfig
;;;316    	    TIM_Cmd(TIM5,DISABLE);
000078  4e45              LDR      r6,|L9.400|
00007a  2100              MOVS     r1,#0
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       TIM_Cmd
;;;317    		TIM_DeInit(TIM5);
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       TIM_DeInit
;;;318    		TIM_ITConfig(TIM5,TIM_IT_Update,DISABLE);
000088  2200              MOVS     r2,#0
00008a  2101              MOVS     r1,#1
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       TIM_ITConfig
;;;319    		TIM_Cmd(TIM6, DISABLE);	
000092  4e40              LDR      r6,|L9.404|
000094  2100              MOVS     r1,#0
000096  4630              MOV      r0,r6
000098  f7fffffe          BL       TIM_Cmd
;;;320    	    TIM_DeInit(TIM6);
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       TIM_DeInit
;;;321    		TIM_ITConfig(TIM6,TIM_IT_Update,DISABLE);
0000a2  2200              MOVS     r2,#0
0000a4  2101              MOVS     r1,#1
0000a6  4630              MOV      r0,r6
0000a8  f7fffffe          BL       TIM_ITConfig
;;;322    		USART_DeInit(USART1);
0000ac  4e3a              LDR      r6,|L9.408|
0000ae  4630              MOV      r0,r6
0000b0  f7fffffe          BL       USART_DeInit
;;;323    		USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);		
0000b4  f2405725          MOV      r7,#0x525
0000b8  2200              MOVS     r2,#0
0000ba  4639              MOV      r1,r7
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       USART_ITConfig
;;;324    		USART_Cmd(USART1,DISABLE);
0000c2  2100              MOVS     r1,#0
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       USART_Cmd
;;;325    		USART_DeInit(USART2);
0000ca  4e34              LDR      r6,|L9.412|
0000cc  4630              MOV      r0,r6
0000ce  f7fffffe          BL       USART_DeInit
;;;326    		USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);		
0000d2  2200              MOVS     r2,#0
0000d4  4639              MOV      r1,r7
0000d6  4630              MOV      r0,r6
0000d8  f7fffffe          BL       USART_ITConfig
;;;327    		USART_Cmd(USART2,DISABLE);
0000dc  2100              MOVS     r1,#0
0000de  4630              MOV      r0,r6
0000e0  f7fffffe          BL       USART_Cmd
;;;328    	    USART_DeInit(USART3);
0000e4  4e2e              LDR      r6,|L9.416|
0000e6  4630              MOV      r0,r6
0000e8  f7fffffe          BL       USART_DeInit
;;;329    		USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);		
0000ec  2200              MOVS     r2,#0
0000ee  4639              MOV      r1,r7
0000f0  4630              MOV      r0,r6
0000f2  f7fffffe          BL       USART_ITConfig
;;;330    		USART_Cmd(USART3,DISABLE);
0000f6  2100              MOVS     r1,#0
0000f8  4630              MOV      r0,r6
0000fa  f7fffffe          BL       USART_Cmd
;;;331    		RCC_DeInit();
0000fe  f7fffffe          BL       RCC_DeInit
;;;332    		RCC_RTCCLKCmd(DISABLE);
000102  e000              B        |L9.262|
                  |L9.260|
000104  e03b              B        |L9.382|
                  |L9.262|
000106  2000              MOVS     r0,#0
000108  f7fffffe          BL       RCC_RTCCLKCmd
;;;333    		EXTI_DeInit();
00010c  f7fffffe          BL       EXTI_DeInit
;;;334    		SysTick->CTRL = 0;
000110  f04f20e0          MOV      r0,#0xe000e000
000114  2600              MOVS     r6,#0
000116  6106              STR      r6,[r0,#0x10]
;;;335    		RTC_DeInit();
000118  f7fffffe          BL       RTC_DeInit
;;;336    		RTC_ITConfig(RTC_IT_WUT,DISABLE);//关闭WAKE UP 定时器中断
00011c  2100              MOVS     r1,#0
00011e  1360              ASRS     r0,r4,#13
000120  f7fffffe          BL       RTC_ITConfig
;;;337    		RTC_WakeUpCmd( DISABLE);//关闭WAKE UP 定时器　
000124  2000              MOVS     r0,#0
000126  f7fffffe          BL       RTC_WakeUpCmd
;;;338    		__disable_irq();
00012a  b672              CPSID    i
;;;339    		NVIC_DisableIRQ(OTG_FS_IRQn);
00012c  2043              MOVS     r0,#0x43
00012e  f7fffffe          BL       NVIC_DisableIRQ
;;;340    		NVIC_DisableIRQ(OTG_FS_WKUP_IRQn);
000132  202a              MOVS     r0,#0x2a
000134  f7fffffe          BL       NVIC_DisableIRQ
;;;341    		NVIC_DisableIRQ(OTG_HS_IRQn);
000138  204d              MOVS     r0,#0x4d
00013a  f7fffffe          BL       NVIC_DisableIRQ
;;;342    		NVIC_DisableIRQ(OTG_HS_WKUP_IRQn);
00013e  204c              MOVS     r0,#0x4c
000140  f7fffffe          BL       NVIC_DisableIRQ
;;;343    		ADC_DeInit();
000144  f7fffffe          BL       ADC_DeInit
;;;344    		DMA_Cmd(DMA2_Stream0, DISABLE);
000148  4f16              LDR      r7,|L9.420|
00014a  2100              MOVS     r1,#0
00014c  4638              MOV      r0,r7
00014e  f7fffffe          BL       DMA_Cmd
;;;345    		DMA_ITConfig(DMA2_Stream0,DMA_IT_TC,DISABLE);
000152  2200              MOVS     r2,#0
000154  2110              MOVS     r1,#0x10
000156  4638              MOV      r0,r7
000158  f7fffffe          BL       DMA_ITConfig
;;;346    		ADC_DMACmd(ADC1, DISABLE);  //使能DMA
00015c  2100              MOVS     r1,#0
00015e  4812              LDR      r0,|L9.424|
000160  f7fffffe          BL       ADC_DMACmd
;;;347    		__ASM volatile ("cpsid i");
000164  b672              CPSID    i
;;;348    		/* Initialize user application's Stack Pointer */
;;;349    		__set_PSP(*(volatile uint32_t*) 0x08000000);
000166  6820              LDR      r0,[r4,#0]
000168  f3808809          MSR      PSP,r0
00016c  f3868814          MSR      CONTROL,r6
;;;350    		__set_CONTROL(0);
;;;351    		__set_MSP(*(volatile uint32_t*) 0x08000000);
000170  6820              LDR      r0,[r4,#0]
000172  f3808808          MSR      MSP,r0
;;;352    		
;;;353            
;;;354    		
;;;355    //		NVIC_SystemReset();
;;;356    		pUserApp();
000176  46ac              MOV      r12,r5
000178  e8bd41f0          POP      {r4-r8,lr}
00017c  4760              BX       r12
                  |L9.382|
;;;357    	}
;;;358    }
00017e  e8bd81f0          POP      {r4-r8,pc}
;;;359    
                          ENDP

000182  0000              DCW      0x0000
                  |L9.388|
                          DCD      0x40010000
                  |L9.392|
                          DCD      0x40000400
                  |L9.396|
                          DCD      0x40000800
                  |L9.400|
                          DCD      0x40000c00
                  |L9.404|
                          DCD      0x40001000
                  |L9.408|
                          DCD      0x40011000
                  |L9.412|
                          DCD      0x40004400
                  |L9.416|
                          DCD      0x40004800
                  |L9.420|
                          DCD      0x40026410
                  |L9.424|
                          DCD      0x40012000

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_DisableIRQ PROC
;;;1479    */
;;;1480   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1481   {
;;;1482     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01180          STR      r1,[r0,#0x180]
;;;1483   }
000014  4770              BX       lr
;;;1484   
                          ENDP


                          AREA ||i.Off_GPOI_ResetSet||, CODE, READONLY, ALIGN=2

                  Off_GPOI_ResetSet PROC
;;;280    //关闭所有 -- 使用的
;;;281    void Off_GPOI_ResetSet(){
000000  b510              PUSH     {r4,lr}
;;;282    	
;;;283    	POWER_RECHARGE = 0;						
000002  4c06              LDR      r4,|L11.28|
000004  2000              MOVS     r0,#0
000006  7020              STRB     r0,[r4,#0]
;;;284    	C_DISCHARGE = 0;							
000008  7060              STRB     r0,[r4,#1]
;;;285    	OnOff_GPOI_ResetSet( 0,	POWER_RECHARGE );
00000a  7821              LDRB     r1,[r4,#0]  ; POWER_RECHARGE
00000c  f7fffffe          BL       OnOff_GPOI_ResetSet
;;;286    	OnOff_GPOI_ResetSet( 2, C_DISCHARGE );
000010  7861              LDRB     r1,[r4,#1]  ; C_DISCHARGE
000012  e8bd4010          POP      {r4,lr}
000016  2002              MOVS     r0,#2
000018  f7ffbffe          B.W      OnOff_GPOI_ResetSet
;;;287    }
;;;288    
                          ENDP

                  |L11.28|
                          DCD      ||area_number.24||

                          AREA ||i.OnOff_GPOI_ResetSet||, CODE, READONLY, ALIGN=2

                  OnOff_GPOI_ResetSet PROC
;;;62     //根据页面
;;;63     void OnOff_GPOI_ResetSet( vu8 _type, vu8 _value ){
000000  b403              PUSH     {r0,r1}
;;;64     	
;;;65     	switch( _type ){
000002  f89d0000          LDRB     r0,[sp,#0]
000006  2800              CMP      r0,#0                 ;63
000008  d019              BEQ      |L12.62|
00000a  2802              CMP      r0,#2
00000c  d117              BNE      |L12.62|
;;;66     		
;;;67     //		case 1024:   
;;;68     //			if( _value == 0 ){
;;;69     //					
;;;70     //				flag_Load_CC = 1;//CC模式
;;;71     //				GPIO_ResetBits(GPIOC,GPIO_Pin_12);   //CC		
;;;72     //			}
;;;73     //			else if( _value == 1 ){
;;;74     //					
;;;75     //				flag_Load_CC=0;//CV模式
;;;76     //				GPIO_SetBits(GPIOC,GPIO_Pin_12);   //CV
;;;77     //			}
;;;78     //		break;
;;;79     		
;;;80     		case 2:  //电子负载ON/OFF
;;;81     			if( _value == 0 ){
00000e  f89d3004          LDRB     r3,[sp,#4]
;;;82     				
;;;83     				Flag_Swtich_ON = 0;
000012  4a0c              LDR      r2,|L12.68|
;;;84     				GPIO_SetBits(GPIOC,GPIO_Pin_7);//OFF	  	
000014  480c              LDR      r0,|L12.72|
000016  6811              LDR      r1,[r2,#0]            ;81
000018  b153              CBZ      r3,|L12.48|
;;;85     			}
;;;86     			else if( _value == 1 ){
00001a  f89d3004          LDRB     r3,[sp,#4]
00001e  2b01              CMP      r3,#1
000020  d10d              BNE      |L12.62|
;;;87     				
;;;88     				Flag_Swtich_ON = 1;
000022  f0410140          ORR      r1,r1,#0x40
;;;89     				GPIO_ResetBits(GPIOC,GPIO_Pin_7);//On
000026  6011              STR      r1,[r2,#0]  ; flagA
000028  2180              MOVS     r1,#0x80
00002a  b002              ADD      sp,sp,#8
00002c  f7ffbffe          B.W      GPIO_ResetBits
                  |L12.48|
000030  f0210140          BIC      r1,r1,#0x40           ;83
000034  6011              STR      r1,[r2,#0]            ;84  ; flagA
000036  2180              MOVS     r1,#0x80              ;84
000038  b002              ADD      sp,sp,#8              ;84
00003a  f7ffbffe          B.W      GPIO_SetBits
                  |L12.62|
;;;90     			}
;;;91     		break;
;;;92     		
;;;93     		case 0:  //稳压电源ON/OFF
;;;94     		
;;;95     //			if( _value == 0 ){
;;;96     //				
;;;97     //				GPIO_ResetBits(GPIOC,GPIO_Pin_1); //关闭电源输出+
;;;98     //				Para.CSET_Voltage = 0;
;;;99     //				Para.CSET_Current = 0;
;;;100    //				GPIO_ResetBits(GPIOE,GPIO_Pin_2); //关闭电源输出继电器
;;;101    //			}
;;;102    //			else if( _value == 1 ){
;;;103    //				
;;;104    //				GPIO_SetBits(GPIOE,GPIO_Pin_2);   //打开电源输出继电器
;;;105    //				GPIO_SetBits(GPIOC,GPIO_Pin_1);   //打开电源输出
;;;106    //			}
;;;107    		break;
;;;108    		
;;;109    	}
;;;110    	
;;;111    }
00003e  b002              ADD      sp,sp,#8
000040  4770              BX       lr
;;;112    
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      ||area_number.24||+0x8
                  |L12.72|
                          DCD      0x40020800

                          AREA ||i.PLimit||, CODE, READONLY, ALIGN=1

                  PLimit PROC
;;;288    
;;;289    void PLimit(void)
000000  4770              BX       lr
;;;290    {
;;;291    	
;;;292    }
;;;293    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;112    
;;;113    void delay(vu32 i)
000000  b501              PUSH     {r0,lr}
                  |L14.2|
;;;114    {
;;;115    	do
;;;116    	{
;;;117    	__NOP();				/*????,??????,??????,?????intrins.h?,????????????.h??*/
000002  bf00              NOP      
;;;118    	__NOP();
000004  bf00              NOP      
;;;119    	__NOP();
000006  bf00              NOP      
;;;120    	i--;
000008  9800              LDR      r0,[sp,#0]
00000a  1e40              SUBS     r0,r0,#1
;;;121    	}while(i*28);
00000c  9000              STR      r0,[sp,#0]
00000e  ebc000c0          RSB      r0,r0,r0,LSL #3
000012  0080              LSLS     r0,r0,#2
000014  d1f5              BNE      |L14.2|
;;;122    }
000016  bd08              POP      {r3,pc}
;;;123    
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;360    
;;;361    int main(void)
000000  f44f3100          MOV      r1,#0x20000
;;;362    {
;;;363    		u8 i;
;;;364    	 int t=0;
;;;365    	u8 ret;
;;;366    	u16 len;	
;;;367    	u8 datatemp[30];
;;;368    	u8 len1 =0;
;;;369    		
;;;370     	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x20000);
000004  0288              LSLS     r0,r1,#10
000006  f7fffffe          BL       NVIC_SetVectorTable
;;;371    	__enable_irq();
00000a  b662              CPSIE    i
;;;372    	
;;;373    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC, ENABLE);//开启CRC时钟，STEMWIN授权使用
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;374    	RCC_Configuration();
000014  f7fffffe          BL       RCC_Configuration
;;;375    	SysTick_Init();
000018  f7fffffe          BL       SysTick_Init
;;;376    	GPIO_Conf();
00001c  f7fffffe          BL       GPIO_Conf
;;;377    
;;;378        abc_time = 0;
000020  4856              LDR      r0,|L15.380|
000022  f04f0800          MOV      r8,#0
000026  4644              MOV      r4,r8
000028  f8c08000          STR      r8,[r0,#0]  ; abc_time
;;;379        ms_time = 0;
00002c  4854              LDR      r0,|L15.384|
00002e  f8c08000          STR      r8,[r0,#0]  ; ms_time
;;;380    
;;;381    	TIM1_PWM_Config();
000032  f7fffffe          BL       TIM1_PWM_Config
;;;382    	TIM4_PWM_Config();
000036  f7fffffe          BL       TIM4_PWM_Config
;;;383    	TIM3_Int_Init(10-1,8400-1);
00003a  f24205cf          MOV      r5,#0x20cf
00003e  4629              MOV      r1,r5
000040  2009              MOVS     r0,#9
000042  f7fffffe          BL       TIM3_Int_Init
;;;384    //	TIM3_Int_Init(1,8400-1);
;;;385    	TIM5_Int_Init(90-1,8400-1);
000046  4629              MOV      r1,r5
000048  2059              MOVS     r0,#0x59
00004a  f7fffffe          BL       TIM5_Int_Init
;;;386    	TIM6_Config();
00004e  f7fffffe          BL       TIM6_Config
;;;387    	ADC1_DMA_Init();
000052  f7fffffe          BL       ADC1_DMA_Init
;;;388    	USART_Configuration();
000056  f7fffffe          BL       USART_Configuration
;;;389    	USART2_Configuration();
00005a  f7fffffe          BL       USART2_Configuration
;;;390    	USART3_Configuration();
00005e  f7fffffe          BL       USART3_Configuration
;;;391    	i2c_CfgGpio();//24C01引脚初始化
000062  f7fffffe          BL       i2c_CfgGpio
;;;392    	TM1650_GPIO_INT();		/*TM1650引脚初始化 */
000066  f7fffffe          BL       TM1650_GPIO_INT
;;;393    	AD5541_GPIOCoing();//DAC初始化
00006a  f7fffffe          BL       AD5541_GPIOCoing
;;;394    	AD7689_InitializeSPI1();//AD7689初始化
00006e  f7fffffe          BL       AD7689_InitializeSPI1
;;;395    //	LCD_Initializtion();//液晶屏初始化
;;;396    	//EEPROM_READ_Coeff();//读取校准参数
;;;397    	RCONT_SW = 0;
000072  4d44              LDR      r5,|L15.388|
000074  626c              STR      r4,[r5,#0x24]  ; Run_Control
;;;398    	Read_Flash_Bytes();
000076  f7fffffe          BL       Read_Flash_Bytes
;;;399    	Read_Boot_Flag();
00007a  f7fffffe          BL       Read_Boot_Flag
;;;400    	Off_GPOI_ResetSet();
00007e  f7fffffe          BL       Off_GPOI_ResetSet
;;;401    	LOAD_MODE = 0;//负载CC模式
000082  61ac              STR      r4,[r5,#0x18]  ; Run_Control
;;;402    	LOAD_V_SW = 0;
000084  61ec              STR      r4,[r5,#0x1c]  ; Run_Control
;;;403    	LOAD_I_SW = 0;
000086  622c              STR      r4,[r5,#0x20]  ; Run_Control
;;;404    	Flag_Swtich_ON = 0;
000088  f8dfb0fc          LDR      r11,|L15.392|
;;;405    	flag_CC_MODE = 1;
00008c  f10b0008          ADD      r0,r11,#8
000090  f8db1000          LDR      r1,[r11,#0]           ;404  ; flagA
000094  f0210140          BIC      r1,r1,#0x40           ;404
000098  f8cb1000          STR      r1,[r11,#0]  ; flagA
00009c  6801              LDR      r1,[r0,#0]  ; flagE
00009e  f0410180          ORR      r1,r1,#0x80
;;;406    	Temperature = Ds18b20Init();
0000a2  6001              STR      r1,[r0,#0]  ; flagE
0000a4  f7fffffe          BL       Ds18b20Init
0000a8  f1ab0608          SUB      r6,r11,#8
;;;407    	while(1)
;;;408    	{
;;;409    		if(tempflag == 20)
;;;410    		{
;;;411    			tempflag = 0;
;;;412    			Temperature = Ds18b20GetTemp();
;;;413    		}else{
;;;414    			tempflag ++;
;;;415    		}
;;;416    		if(readpowflag > 200/* && mainswitch == 1*/)
;;;417    		{
;;;418    			ReadPowData();
;;;419    			readpowflag = 0;
;;;420    		}
;;;421    //		PLimit();//功率限制保护
;;;422    		if(USART_RX_STA&0x8000)	   //判断是否接收完数据
;;;423    		{					   
;;;424    
;;;425    //			len1=USART_RX_STA&0x3f;
;;;426    			len1=USART_RX_CNT;
;;;427    			len = SerialRemoteHandleL(len1,USART_RX_BUF);
;;;428    			len1 =0;
;;;429    			for(t=0;t<len;t++)								  //通过长度进行循环
;;;430    			{
;;;431    				USART_SendData(USART2, USART_RX_BUF[t]);      //将数组采集好的数据 一次向串口1发送
0000ac  4f37              LDR      r7,|L15.396|
0000ae  f8df90e0          LDR      r9,|L15.400|
0000b2  80b0              STRH     r0,[r6,#4]            ;406
                  |L15.180|
0000b4  78f0              LDRB     r0,[r6,#3]            ;409  ; tempflag
0000b6  2814              CMP      r0,#0x14              ;409
0000b8  d016              BEQ      |L15.232|
0000ba  1c40              ADDS     r0,r0,#1              ;409
0000bc  70f0              STRB     r0,[r6,#3]            ;414
                  |L15.190|
0000be  6970              LDR      r0,[r6,#0x14]         ;416  ; readpowflag
0000c0  28c8              CMP      r0,#0xc8              ;416
0000c2  d903              BLS      |L15.204|
0000c4  f7fffffe          BL       ReadPowData
0000c8  f8c68014          STR      r8,[r6,#0x14]         ;419  ; readpowflag
                  |L15.204|
0000cc  f8b90000          LDRH     r0,[r9,#0]            ;422  ; USART_RX_STA
0000d0  0400              LSLS     r0,r0,#16             ;422
0000d2  d523              BPL      |L15.284|
0000d4  482f              LDR      r0,|L15.404|
0000d6  4930              LDR      r1,|L15.408|
0000d8  7800              LDRB     r0,[r0,#0]            ;426  ; USART_RX_CNT
0000da  f7fffffe          BL       SerialRemoteHandleL
0000de  4605              MOV      r5,r0                 ;427
0000e0  2400              MOVS     r4,#0                 ;429
0000e2  f8dfa0b4          LDR      r10,|L15.408|
0000e6  e011              B        |L15.268|
                  |L15.232|
0000e8  f8868003          STRB     r8,[r6,#3]            ;411
0000ec  f7fffffe          BL       Ds18b20GetTemp
0000f0  80b0              STRH     r0,[r6,#4]            ;412
0000f2  e7e4              B        |L15.190|
                  |L15.244|
0000f4  f81a1004          LDRB     r1,[r10,r4]
0000f8  4638              MOV      r0,r7
0000fa  f7fffffe          BL       USART_SendData
                  |L15.254|
;;;432    				while(USART_GetFlagStatus(USART2,USART_FLAG_TC)!=SET);//等待发送结束
0000fe  2140              MOVS     r1,#0x40
000100  4638              MOV      r0,r7
000102  f7fffffe          BL       USART_GetFlagStatus
000106  2801              CMP      r0,#1
000108  d1f9              BNE      |L15.254|
00010a  1c64              ADDS     r4,r4,#1
                  |L15.268|
00010c  42ac              CMP      r4,r5                 ;429
00010e  dbf1              BLT      |L15.244|
;;;433    			}
;;;434    			memset(USART_RX_BUF,0,USART_REC_LEN);
000110  21c8              MOVS     r1,#0xc8
000112  4821              LDR      r0,|L15.408|
000114  f7fffffe          BL       __aeabi_memclr
;;;435    			
;;;436    			USART_RX_STA=0;			  //清零 虚拟寄存器		  为一下次采集做准备
000118  f8a98000          STRH     r8,[r9,#0]
                  |L15.284|
;;;437    		}
;;;438    		if(USART3_Recive_flg == 1)
00011c  481f              LDR      r0,|L15.412|
00011e  7800              LDRB     r0,[r0,#0]  ; USART3_Recive_flg
000120  2801              CMP      r0,#1
000122  d101              BNE      |L15.296|
;;;439    		{
;;;440    			USART3HANDLE();
000124  f7fffffe          BL       USART3HANDLE
                  |L15.296|
;;;441    		}
;;;442    		TIM_SetCompare3(TIM4,Contr_Voltage);//稳压电源电流DAC
000128  481d              LDR      r0,|L15.416|
00012a  8801              LDRH     r1,[r0,#0]  ; Contr_Voltage
00012c  4c1d              LDR      r4,|L15.420|
00012e  4620              MOV      r0,r4
000130  f7fffffe          BL       TIM_SetCompare3
;;;443    		TIM_SetCompare4(TIM4,Contr_Current);//稳压电源电压DAC
000134  481c              LDR      r0,|L15.424|
000136  8801              LDRH     r1,[r0,#0]  ; Contr_Current
000138  4620              MOV      r0,r4
00013a  f7fffffe          BL       TIM_SetCompare4
;;;444    		AD5541_Send(Contr_Laod);//加载DAC值
00013e  481b              LDR      r0,|L15.428|
000140  8800              LDRH     r0,[r0,#0]  ; Contr_Laod
000142  f7fffffe          BL       AD5541_Send
;;;445    		MODE_CONT();//电压电流档位切换
000146  f7fffffe          BL       MODE_CONT
;;;446    		if(Flag_DAC_OFF==0 && calflag == 0)
00014a  480f              LDR      r0,|L15.392|
00014c  1d00              ADDS     r0,r0,#4
00014e  7800              LDRB     r0,[r0,#0]  ; flagB
000150  0700              LSLS     r0,r0,#28
000152  d403              BMI      |L15.348|
000154  78b0              LDRB     r0,[r6,#2]  ; calflag
000156  b908              CBNZ     r0,|L15.348|
;;;447    		{
;;;448    			Transformation_ADC();
000158  f7fffffe          BL       Transformation_ADC
                  |L15.348|
;;;449    		}
;;;450    		if(Flag_ADC_Full==1)
00015c  f8db0000          LDR      r0,[r11,#0]  ; flagA
000160  0782              LSLS     r2,r0,#30
000162  d505              BPL      |L15.368|
;;;451    		{
;;;452    			Flag_ADC_Full=0;
000164  f0200002          BIC      r0,r0,#2
;;;453    			ADC_CH_Scan();//ADC滤波
000168  f8cb0000          STR      r0,[r11,#0]  ; flagA
00016c  f7fffffe          BL       ADC_CH_Scan
                  |L15.368|
;;;454    		}
;;;455    		AD7689_Scan_CH();//读取AD7689各通道AD值
000170  f7fffffe          BL       AD7689_Scan_CH
;;;456    		Temp_Comapre();//风扇控制
000174  f7fffffe          BL       Temp_Comapre
000178  e79c              B        |L15.180|
;;;457    	}
;;;458    	//IWDG_Inte();
;;;459    //	MainTask();
;;;460    }
;;;461    
                          ENDP

00017a  0000              DCW      0x0000
                  |L15.380|
                          DCD      abc_time
                  |L15.384|
                          DCD      ms_time
                  |L15.388|
                          DCD      Run_Control
                  |L15.392|
                          DCD      ||area_number.24||+0x8
                  |L15.396|
                          DCD      0x40004400
                  |L15.400|
                          DCD      USART_RX_STA
                  |L15.404|
                          DCD      USART_RX_CNT
                  |L15.408|
                          DCD      USART_RX_BUF
                  |L15.412|
                          DCD      USART3_Recive_flg
                  |L15.416|
                          DCD      Contr_Voltage
                  |L15.420|
                          DCD      0x40000800
                  |L15.424|
                          DCD      Contr_Current
                  |L15.428|
                          DCD      Contr_Laod

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  CLists
                          %        144

                          AREA ||area_number.18||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.bss||
                  CalPara
                          %        184

                          AREA ||area_number.19||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.bss||
                  Para
                          %        164

                          AREA ||.data||, DATA, ALIGN=0

                  trig_flag_state
000000  00                DCB      0x00

                          AREA ||area_number.22||, DATA, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.data||
                  max_discahrgeNum
000000  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.23||, DATA, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.data||
                  old_I
000000  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.24||, DATA, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.data||
                  POWER_RECHARGE
000000  00                DCB      0x00
                  C_DISCHARGE
000001  00                DCB      0x00
                  calflag
000002  00                DCB      0x00
                  tempflag
000003  00                DCB      0x00
                  Temperature
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  flagA
                          DCD      0x00000000
                  flagB
                          DCD      0x00000000
                  flagE
                          DCD      0x00000000
                  readpowflag
                          DCD      0x00000000

                          AREA ||area_number.25||, DATA, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.data||
                  flagC
                          DCD      0x00000000

                          AREA ||area_number.26||, DATA, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.data||
                  flagD
                          DCD      0x00000000

                          AREA ||area_number.27||, DATA, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.data||
                  flagF
                          DCD      0x00000000

                          AREA ||area_number.28||, DATA, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.data||
                  flagG
                          DCD      0x00000000

                          AREA ||area_number.29||, DATA, ALIGN=0

                          EXPORTAS ||area_number.29||, ||.data||
                  bootflag
000000  00                DCB      0x00

                          AREA ||area_number.30||, DATA, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.data||
                  DISS_Voltage
                          DCD      0x00000000

                          AREA ||area_number.31||, DATA, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.data||
                  DISS_POW_Voltage
                          DCD      0x00000000

                          AREA ||area_number.32||, DATA, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.data||
                  DISS_Current
                          DCD      0x00000000

                          AREA ||area_number.33||, DATA, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.data||
                  DISS_POW_Current
                          DCD      0x00000000

                          AREA ||area_number.34||, DATA, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.data||
                  DISS_R
                          DCD      0x00000000

                          AREA ||area_number.35||, DATA, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.data||
                  CDC_CsumMah
                          DCD      0x00000000

                          AREA ||area_number.36||, DATA, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.data||
                  CDC_DCsumMah
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_c28ffc1e____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_c28ffc1e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_c28ffc1e____REVSH|
#line 144
|__asm___6_main_c_c28ffc1e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
