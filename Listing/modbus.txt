; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\modbus.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\modbus.crf --no_multibyte_chars ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=1

                  Hardware_CRC PROC
;;;1337   //-----------------------------CRC检测--------------------------------------------//
;;;1338   vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b513              PUSH     {r0,r1,r4,lr}
;;;1339   {
000002  b082              SUB      sp,sp,#8
;;;1340   	vu16 CRC_Result=0xffff;
000004  f64f71ff          MOV      r1,#0xffff
000008  f8ad1000          STRH     r1,[sp,#0]
;;;1341   	vu8 i;
;;;1342   	if(count==0)
00000c  f89d100c          LDRB     r1,[sp,#0xc]
000010  b911              CBNZ     r1,|L1.24|
;;;1343   	{
;;;1344   		count=1;
000012  2101              MOVS     r1,#1
000014  f88d100c          STRB     r1,[sp,#0xc]
                  |L1.24|
000018  2300              MOVS     r3,#0
;;;1345   	}
;;;1346   	while(count--)
;;;1347   	{
;;;1348   		CRC_Result^=*p_buffer;
;;;1349   		for(i=0;i<8;i++)
;;;1350   		{
;;;1351   			if(CRC_Result&1)
;;;1352   			{
;;;1353   				CRC_Result>>=1;
;;;1354   				CRC_Result^=0xA001;
00001a  f24a0201          MOV      r2,#0xa001
                  |L1.30|
00001e  f89d100c          LDRB     r1,[sp,#0xc]          ;1346
000022  1e4c              SUBS     r4,r1,#1              ;1346
000024  f88d400c          STRB     r4,[sp,#0xc]          ;1346
000028  d322              BCC      |L1.112|
00002a  7801              LDRB     r1,[r0,#0]            ;1348
00002c  f8bd4000          LDRH     r4,[sp,#0]            ;1348
000030  4061              EORS     r1,r1,r4              ;1348
000032  f8ad1000          STRH     r1,[sp,#0]            ;1348
000036  f88d3004          STRB     r3,[sp,#4]            ;1349
00003a  e013              B        |L1.100|
                  |L1.60|
00003c  f8bd1000          LDRH     r1,[sp,#0]            ;1351
000040  07c9              LSLS     r1,r1,#31             ;1351
;;;1355   			}
;;;1356   			else 
;;;1357   			{
;;;1358   				CRC_Result>>=1;
000042  f8bd1000          LDRH     r1,[sp,#0]
000046  ea4f0151          LSR      r1,r1,#1
00004a  d004              BEQ      |L1.86|
00004c  f8ad1000          STRH     r1,[sp,#0]            ;1353
000050  f8bd1000          LDRH     r1,[sp,#0]            ;1354
000054  4051              EORS     r1,r1,r2              ;1354
                  |L1.86|
000056  f8ad1000          STRH     r1,[sp,#0]
00005a  f89d1004          LDRB     r1,[sp,#4]            ;1349
00005e  1c49              ADDS     r1,r1,#1              ;1349
000060  f88d1004          STRB     r1,[sp,#4]            ;1349
                  |L1.100|
000064  f89d1004          LDRB     r1,[sp,#4]            ;1349
000068  2908              CMP      r1,#8                 ;1349
00006a  d3e7              BCC      |L1.60|
00006c  1c40              ADDS     r0,r0,#1              ;1349
;;;1359   			}
;;;1360   		}
;;;1361   		p_buffer++;
00006e  e7d6              B        |L1.30|
                  |L1.112|
;;;1362   	}
;;;1363   	return CRC_Result;
000070  f8bd0000          LDRH     r0,[sp,#0]
;;;1364   }
000074  b004              ADD      sp,sp,#0x10
000076  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;912    //===============================AD值转换成测量值============================================//
;;;913    void Transformation_ADC(void)  
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;914    {
;;;915    	vu32 var32;
;;;916    	vu32 var32a;
;;;917    /*****************************负载测量电压转换******************************************/
;;;918    	if(LOAD_V_SW==0)//低档
000004  4ffc              LDR      r7,|L2.1016|
000006  69fd              LDR      r5,[r7,#0x1c]  ; Run_Control
;;;919    	{
;;;920    		var32 = Vmon_Load_value;
000008  4cfc              LDR      r4,|L2.1020|
;;;921    		var32 = var32 * CalPara.TestLV[0] + CalPara.OffsetLV[0];  
;;;922    //		if ((CLists.CPolar0 & 0x01) == 0x01)		  
;;;923    //		{
;;;924    //			if (var32 < CLists.CREG_LoadV_Offset_LOW) 
;;;925    //			{
;;;926    //				var32 = 0;
;;;927    //			}
;;;928    //			else var32 = var32 - CLists.CREG_LoadV_Offset_LOW;
;;;929    //		}
;;;930    //		else var32 = var32 + CLists.CREG_LoadV_Offset_LOW;
;;;931    //		var32 = var32 >> 12;
;;;932    		if (var32 < 30) var32 = 0;				  //40mV以下清零
;;;933    		Para.CVoltage = var32;
;;;934    //		DISS_Voltage=Para.CVoltage;
;;;935    		DISS_Voltage=(float)Para.CVoltage/1000;//计算显示电压
00000a  4bfd              LDR      r3,|L2.1024|
00000c  ed9f0afd          VLDR     s0,|L2.1028|
000010  49fd              LDR      r1,|L2.1032|
000012  4afe              LDR      r2,|L2.1036|
;;;936    // 		if( DISS_Voltage >= 10 ){
;;;937    // 				CLists.CLOAD_V_SW  = 1;
;;;938    // 		}
;;;939    // 	//如果DISS_Voltage的值  >=10 CLists.CLOAD_V_SW  =1
;;;940    		var32 = 0;
;;;941    	}
;;;942    	else//高档
;;;943    	{
;;;944    		var32 = Vmon_Load_value;
000014  8824              LDRH     r4,[r4,#0]  ; Vmon_Load_value
000016  2000              MOVS     r0,#0                 ;933
000018  9400              STR      r4,[sp,#0]            ;914
00001a  b195              CBZ      r5,|L2.66|
;;;945    		var32 = var32 * CalPara.TestLV[1] + CalPara.OffsetLV[1]; 
00001c  ee014a10          VMOV     s2,r4
000020  edd10a05          VLDR     s1,[r1,#0x14]
000024  edd11a01          VLDR     s3,[r1,#4]
000028  eeb81a41          VCVT.F32.U32 s2,s2
00002c  ee410a21          VMLA.F32 s1,s2,s3
000030  eefc0ae0          VCVT.U32.F32 s1,s1
;;;946    //		if ((CLists.CPolar0 & 0x04) == 0x04)		  
;;;947    //		{
;;;948    //			if (var32 < CLists.CREG_LoadV_Offset_HIG) 
;;;949    //			{
;;;950    //				var32 = 0;
;;;951    //			}
;;;952    //			else var32 = var32 - CLists.CREG_LoadV_Offset_HIG;
;;;953    //		}
;;;954    //		else var32 = var32 + CLists.CREG_LoadV_Offset_HIG;
;;;955    //		var32 = var32 >> 12;
;;;956    		if (var32 < 10) var32 = 0;				  //40mV以下清零
000034  ee104a90          VMOV     r4,s1
000038  edcd0a00          VSTR     s1,[sp,#0]            ;945
00003c  2c0a              CMP      r4,#0xa
00003e  d312              BCC      |L2.102|
000040  e012              B        |L2.104|
                  |L2.66|
000042  ee014a10          VMOV     s2,r4                 ;921
000046  edd10a04          VLDR     s1,[r1,#0x10]         ;921
00004a  edd11a00          VLDR     s3,[r1,#0]            ;921
00004e  eeb81a41          VCVT.F32.U32 s2,s2                 ;921
000052  ee410a21          VMLA.F32 s1,s2,s3              ;921
000056  eefc0ae0          VCVT.U32.F32 s1,s1                 ;921
00005a  ee104a90          VMOV     r4,s1                 ;932
00005e  edcd0a00          VSTR     s1,[sp,#0]            ;921
000062  2c1e              CMP      r4,#0x1e              ;932
000064  d200              BCS      |L2.104|
                  |L2.102|
000066  9000              STR      r0,[sp,#0]            ;932
                  |L2.104|
;;;957    		Para.CVoltage = var32;
000068  9c00              LDR      r4,[sp,#0]
00006a  62d4              STR      r4,[r2,#0x2c]  ; Para
;;;958    //		DISS_Voltage=Para.CVoltage;
;;;959    		DISS_Voltage=(float)Para.CVoltage/1000;//计算显示电压
00006c  6ad4              LDR      r4,[r2,#0x2c]  ; Para
00006e  ee004a90          VMOV     s1,r4
000072  eef80a60          VCVT.F32.U32 s1,s1
000076  ee801a80          VDIV.F32 s2,s1,s0
00007a  ed831a00          VSTR     s2,[r3,#0]
;;;960    // 		if( DISS_Voltage < 12 ){
;;;961    // 				CLists.CLOAD_V_SW  = 0;
;;;962    // 		}
;;;963       //如果DISS_Voltage的值  <12  CLists.CLOAD_V_SW  = 0
;;;964    		var32 = 0;
;;;965    	}
;;;966    	
;;;967    	/*******************负载测量电流转换**************************************/
;;;968    	if(LOAD_I_SW==0)//低档
00007e  9000              STR      r0,[sp,#0]
000080  6a3e              LDR      r6,[r7,#0x20]  ; Run_Control
;;;969    	{
;;;970    		var32 = Imon_Load_value;
000082  4be4              LDR      r3,|L2.1044|
000084  2e00              CMP      r6,#0                 ;968
;;;971    		var32 = var32 * CalPara.TestLC[0] + CalPara.OffsetTestLC[0];  
;;;972    //		if ((CLists.CPolar2 & 0x01) == 0x01)		  
;;;973    //		{
;;;974    //			if (var32 < CLists.CREG_LoadA_Offset_LOW) 
;;;975    //			{
;;;976    //				var32 = 0;
;;;977    //			}
;;;978    //			else var32 = var32 - CLists.CREG_LoadA_Offset_LOW;
;;;979    //		}
;;;980    //		else var32 = var32 + CLists.CREG_LoadA_Offset_LOW;
;;;981    //		var32 = var32 >> 12;
;;;982    		Para.CLaod_Current = var32;
;;;983    		if(Para.CSET_Current_Laod >= 5000)
;;;984    		{
;;;985    			var32 = Imon_Load_value;
;;;986    			var32 = var32 * CalPara.TestLC[1] + CalPara.OffsetTestLC[1];
;;;987    			Para.CLaod_Current = var32;
;;;988    		}
;;;989    //		DISS_Current=Para.CLaod_Current;
;;;990    		DISS_Current=(float)Para.CLaod_Current/1000;//计算显示电流
000086  f8df8388          LDR      r8,|L2.1040|
;;;991    		var32 = 0;	
;;;992    	}
;;;993    	else//高档
;;;994    	{
;;;995    		var32 = Imon_Load_value;
00008a  881e              LDRH     r6,[r3,#0]  ; Imon_Load_value
00008c  f2413588          MOV      r5,#0x1388            ;983
;;;996    		var32 = var32 * CalPara.TestLC[2] + CalPara.OffsetTestLC[2];   
;;;997    //		if ((CLists.CPolar4 & 0x01) == 0x01)		  
;;;998    //		{
;;;999    //			if (var32 < CLists.CREG_LoadA_Offset_HIG) 
;;;1000   //			{
;;;1001   //				var32 = 0;
;;;1002   //			}
;;;1003   //			else var32 = var32 - CLists.CREG_LoadA_Offset_HIG;
;;;1004   //		}
;;;1005   //		else var32 = var32 + CLists.CREG_LoadA_Offset_HIG;
;;;1006   //		var32 = var32 >> 12;
;;;1007   		Para.CLaod_Current = var32;
;;;1008   		if(Para.CLaod_Current < 1000)
000090  f44f797a          MOV      r9,#0x3e8
;;;1009   		{
;;;1010   			Para.CLaod_Current = 0;
;;;1011   		}
;;;1012   		if(Para.CSET_Current_Laod >= 20000)
000094  f6446c20          MOV      r12,#0x4e20
;;;1013   		{
;;;1014   			var32 = Imon_Load_value;
;;;1015   			var32 = var32 * CalPara.TestLC[3] + CalPara.OffsetTestLC[3];
;;;1016   			Para.CLaod_Current = var32;
;;;1017   		}
;;;1018   		if(Para.CSET_Current_Laod >= 50000)
000098  f24c3450          MOV      r4,#0xc350
00009c  9600              STR      r6,[sp,#0]            ;964
00009e  d051              BEQ      |L2.324|
0000a0  ee006a90          VMOV     s1,r6                 ;996
0000a4  ed911a1f          VLDR     s2,[r1,#0x7c]         ;996
0000a8  edd11a11          VLDR     s3,[r1,#0x44]         ;996
0000ac  eef80a60          VCVT.F32.U32 s1,s1                 ;996
0000b0  ee001aa1          VMLA.F32 s2,s1,s3              ;996
0000b4  eefc0ac1          VCVT.U32.F32 s1,s2                 ;996
0000b8  ee106a90          VMOV     r6,s1                 ;1007
0000bc  edcd0a00          VSTR     s1,[sp,#0]            ;996
0000c0  6356              STR      r6,[r2,#0x34]         ;1007  ; Para
0000c2  6b56              LDR      r6,[r2,#0x34]         ;1008  ; Para
0000c4  454e              CMP      r6,r9                 ;1008
0000c6  d200              BCS      |L2.202|
0000c8  6350              STR      r0,[r2,#0x34]         ;1010  ; Para
                  |L2.202|
0000ca  6956              LDR      r6,[r2,#0x14]         ;1012  ; Para
0000cc  4566              CMP      r6,r12                ;1012
0000ce  d312              BCC      |L2.246|
0000d0  881e              LDRH     r6,[r3,#0]            ;1014  ; Imon_Load_value
0000d2  9600              STR      r6,[sp,#0]            ;1015
0000d4  ee016a10          VMOV     s2,r6                 ;1015
0000d8  edd10a20          VLDR     s1,[r1,#0x80]         ;1015
0000dc  edd11a12          VLDR     s3,[r1,#0x48]         ;1015
0000e0  eeb81a41          VCVT.F32.U32 s2,s2                 ;1015
0000e4  ee410a21          VMLA.F32 s1,s2,s3              ;1015
0000e8  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1015
0000ec  ee106a90          VMOV     r6,s1                 ;1016
0000f0  edcd0a00          VSTR     s1,[sp,#0]            ;1015
0000f4  6356              STR      r6,[r2,#0x34]         ;1016  ; Para
                  |L2.246|
0000f6  6956              LDR      r6,[r2,#0x14]  ; Para
0000f8  42a6              CMP      r6,r4
0000fa  d312              BCC      |L2.290|
;;;1019   		{
;;;1020   			var32 = Imon_Load_value;
0000fc  881b              LDRH     r3,[r3,#0]  ; Imon_Load_value
;;;1021   			var32 = var32 * CalPara.TestLC[4] + CalPara.OffsetTestLC[4];
0000fe  9300              STR      r3,[sp,#0]
000100  edd10a21          VLDR     s1,[r1,#0x84]
000104  edd11a13          VLDR     s3,[r1,#0x4c]
                  |L2.264|
000108  ee013a10          VMOV     s2,r3                 ;986
00010c  eeb81a41          VCVT.F32.U32 s2,s2                 ;986
000110  ee410a21          VMLA.F32 s1,s2,s3              ;986
000114  eefc0ae0          VCVT.U32.F32 s1,s1                 ;986
000118  ee103a90          VMOV     r3,s1                 ;987
00011c  edcd0a00          VSTR     s1,[sp,#0]            ;986
000120  6353              STR      r3,[r2,#0x34]         ;987  ; Para
                  |L2.290|
;;;1022   			Para.CLaod_Current = var32;
;;;1023   		}
;;;1024   //		DISS_Current=Para.CLaod_Current;
;;;1025   		DISS_Current=(float)Para.CLaod_Current/1000;//计算显示电流
000122  6b53              LDR      r3,[r2,#0x34]  ; Para
000124  ee003a90          VMOV     s1,r3
000128  eef80a60          VCVT.F32.U32 s1,s1
00012c  ee801a80          VDIV.F32 s2,s1,s0
000130  ed881a00          VSTR     s2,[r8,#0]
;;;1026   		var32 = 0;
;;;1027   	}
;;;1028   	
;;;1029   	/*************************负载电压和电流控制 转换**************************************/
;;;1030   	if(LOAD_MODE==0)//CC
000134  9000              STR      r0,[sp,#0]
000136  69be              LDR      r6,[r7,#0x18]  ; Run_Control
;;;1031   	{
;;;1032   		if(LOAD_I_SW==0)//低档
;;;1033   		{
;;;1034   			var32 = Para.CSET_Current_Laod;
;;;1035   			if(Para.CSET_Current_Laod < 5000)
;;;1036   			{
;;;1037   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[0] + CalPara.OffsetLC[0];
;;;1038   			}else{
;;;1039   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[1] + CalPara.OffsetLC[1];
;;;1040   			}
;;;1041   //			var32=var32<<12;   
;;;1042   //			if ((CLists.CPolar2 & 0x04) == 0)			   
;;;1043   //			{
;;;1044   //				if (var32 < CLists.CSET_LoadA_Offset_LOW) var32 = 0;
;;;1045   //				else var32 = var32 - CLists.CSET_LoadA_Offset_LOW;
;;;1046   //			}
;;;1047   //			else var32 = var32 + CLists.CSET_LoadA_Offset_LOW;
;;;1048   //			var32 = var32/CLists.CSET_Load_CorrectionA_LOW;
;;;1049   //			var32=var32>>1;
;;;1050   			Contr_Laod = var32;
000138  4bb7              LDR      r3,|L2.1048|
00013a  b1f6              CBZ      r6,|L2.378|
;;;1051   			if(Para.CSET_Current_Laod==0)
;;;1052   			{
;;;1053   				Contr_Laod=0;
;;;1054   			}
;;;1055   			var32 = 0;
;;;1056   		}
;;;1057   		else//高档
;;;1058   		{
;;;1059   			var32 = Para.CSET_Current_Laod;
;;;1060   			if(Para.CSET_Current_Laod < 20000)
;;;1061   			{
;;;1062   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[2] + CalPara.OffsetLC[2];  
;;;1063   			}else if(Para.CSET_Current_Laod >= 20000 && Para.CSET_Current_Laod < 50000){
;;;1064   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[3] + CalPara.OffsetLC[3];  
;;;1065   			}else if(Para.CSET_Current_Laod >= 50000){
;;;1066   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[4] + CalPara.OffsetLC[4];  
;;;1067   			}
;;;1068   //			if ((CLists.CPolar3 & 0x04) == 0)			   
;;;1069   //			{
;;;1070   //				if (var32 < CLists.CSET_LoadA_Offset_HIG) var32 = 0;
;;;1071   //				else var32 = var32 - CLists.CSET_LoadA_Offset_HIG;
;;;1072   //			}
;;;1073   //			else var32 = var32 + CLists.CSET_LoadA_Offset_HIG;
;;;1074   //			var32 = var32/CLists.CSET_Load_CorrectionA_HIG;
;;;1075   //			var32=var32>>1;
;;;1076   			Contr_Laod = var32;
;;;1077   			if(Para.CSET_Current_Laod==0)
;;;1078   			{
;;;1079   				Contr_Laod=0;
;;;1080   			}
;;;1081   			var32 = 0;
;;;1082   		}
;;;1083   		
;;;1084   	}
;;;1085   	else if(LOAD_MODE==1)//CV
00013c  69bc              LDR      r4,[r7,#0x18]  ; Run_Control
00013e  2c01              CMP      r4,#1
000140  d077              BEQ      |L2.562|
000142  e08c              B        |L2.606|
                  |L2.324|
000144  ee016a10          VMOV     s2,r6                 ;971
000148  edd10a1d          VLDR     s1,[r1,#0x74]         ;971
00014c  edd11a0f          VLDR     s3,[r1,#0x3c]         ;971
000150  eeb81a41          VCVT.F32.U32 s2,s2                 ;971
000154  ee410a21          VMLA.F32 s1,s2,s3              ;971
000158  eefc0ae0          VCVT.U32.F32 s1,s1                 ;971
00015c  ee106a90          VMOV     r6,s1                 ;982
000160  edcd0a00          VSTR     s1,[sp,#0]            ;971
000164  6356              STR      r6,[r2,#0x34]         ;982  ; Para
000166  6956              LDR      r6,[r2,#0x14]         ;983  ; Para
000168  42ae              CMP      r6,r5                 ;983
00016a  d3da              BCC      |L2.290|
00016c  881b              LDRH     r3,[r3,#0]            ;985  ; Imon_Load_value
00016e  9300              STR      r3,[sp,#0]            ;986
000170  edd10a1e          VLDR     s1,[r1,#0x78]         ;986
000174  edd11a10          VLDR     s3,[r1,#0x40]         ;986
000178  e7c6              B        |L2.264|
                  |L2.378|
00017a  6a3e              LDR      r6,[r7,#0x20]         ;1032  ; Run_Control
00017c  b176              CBZ      r6,|L2.412|
00017e  6955              LDR      r5,[r2,#0x14]         ;1059  ; Para
000180  9500              STR      r5,[sp,#0]            ;1060
000182  6955              LDR      r5,[r2,#0x14]         ;1060  ; Para
000184  4565              CMP      r5,r12                ;1060
000186  d22a              BCS      |L2.478|
000188  edd10a18          VLDR     s1,[r1,#0x60]         ;1062
00018c  6954              LDR      r4,[r2,#0x14]         ;1062  ; Para
00018e  edd11a0a          VLDR     s3,[r1,#0x28]         ;1062
000192  ee014a10          VMOV     s2,r4                 ;1062
000196  eeb81a41          VCVT.F32.U32 s2,s2                 ;1062
00019a  e03c              B        |L2.534|
                  |L2.412|
00019c  6954              LDR      r4,[r2,#0x14]         ;1034  ; Para
00019e  9400              STR      r4,[sp,#0]            ;1035
0001a0  6954              LDR      r4,[r2,#0x14]         ;1035  ; Para
0001a2  42ac              CMP      r4,r5                 ;1035
0001a4  d209              BCS      |L2.442|
0001a6  edd10a16          VLDR     s1,[r1,#0x58]         ;1037
0001aa  6954              LDR      r4,[r2,#0x14]         ;1037  ; Para
0001ac  edd11a08          VLDR     s3,[r1,#0x20]         ;1037
0001b0  ee014a10          VMOV     s2,r4                 ;1037
0001b4  eeb81a41          VCVT.F32.U32 s2,s2                 ;1037
0001b8  e008              B        |L2.460|
                  |L2.442|
0001ba  edd10a17          VLDR     s1,[r1,#0x5c]         ;1039
0001be  6954              LDR      r4,[r2,#0x14]         ;1039  ; Para
0001c0  edd11a09          VLDR     s3,[r1,#0x24]         ;1039
0001c4  ee014a10          VMOV     s2,r4                 ;1039
0001c8  eeb81a41          VCVT.F32.U32 s2,s2                 ;1039
                  |L2.460|
0001cc  ee410a21          VMLA.F32 s1,s2,s3              ;1039
0001d0  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1039
0001d4  edcd0a00          VSTR     s1,[sp,#0]            ;1039
0001d8  ee104a90          VMOV     r4,s1                 ;1050
0001dc  e022              B        |L2.548|
                  |L2.478|
0001de  6955              LDR      r5,[r2,#0x14]         ;1063  ; Para
0001e0  4565              CMP      r5,r12                ;1063
0001e2  d30c              BCC      |L2.510|
0001e4  6955              LDR      r5,[r2,#0x14]         ;1063  ; Para
0001e6  42a5              CMP      r5,r4                 ;1063
0001e8  d209              BCS      |L2.510|
0001ea  edd10a19          VLDR     s1,[r1,#0x64]         ;1064
0001ee  6954              LDR      r4,[r2,#0x14]         ;1064  ; Para
0001f0  edd11a0b          VLDR     s3,[r1,#0x2c]         ;1064
0001f4  ee014a10          VMOV     s2,r4                 ;1064
0001f8  eeb81a41          VCVT.F32.U32 s2,s2                 ;1064
0001fc  e00b              B        |L2.534|
                  |L2.510|
0001fe  6955              LDR      r5,[r2,#0x14]         ;1065  ; Para
000200  42a5              CMP      r5,r4                 ;1065
000202  d30e              BCC      |L2.546|
000204  edd10a1a          VLDR     s1,[r1,#0x68]         ;1066
000208  6954              LDR      r4,[r2,#0x14]         ;1066  ; Para
00020a  edd11a0c          VLDR     s3,[r1,#0x30]         ;1066
00020e  ee014a10          VMOV     s2,r4                 ;1066
000212  eeb81a41          VCVT.F32.U32 s2,s2                 ;1066
                  |L2.534|
000216  ee410a21          VMLA.F32 s1,s2,s3              ;1066
00021a  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1066
00021e  edcd0a00          VSTR     s1,[sp,#0]            ;1066
                  |L2.546|
000222  9c00              LDR      r4,[sp,#0]            ;1076
                  |L2.548|
000224  801c              STRH     r4,[r3,#0]            ;1076
000226  6954              LDR      r4,[r2,#0x14]         ;1077  ; Para
                  |L2.552|
000228  b904              CBNZ     r4,|L2.556|
00022a  8018              STRH     r0,[r3,#0]            ;1079
                  |L2.556|
;;;1086   	{
;;;1087   		if(LOAD_V_SW==0)//低档
;;;1088   		{
;;;1089   			var32 = Para.CSET_Voltage_Laod;
;;;1090   			var32 = Para.CSET_Voltage_Laod * CalPara.SetCV[0] + CalPara.OffsetCV[0];   
;;;1091   //			if ((CLists.CPolar2 & 0x04) == 0)			   
;;;1092   //			{
;;;1093   //				if (var32 < CLists.CSET_LoadV_Offset_LOW) var32 = 0;
;;;1094   //				else var32 = var32 - CLists.CSET_LoadV_Offset_LOW;
;;;1095   //			}
;;;1096   //			else var32 = var32 + CLists.CSET_LoadV_Offset_LOW;
;;;1097   //			var32 = var32/CLists.CSET_Load_CorrectionV_LOW;
;;;1098   //			var32=var32>>1;
;;;1099   			Contr_Laod = var32;
;;;1100   			if(Para.CSET_Voltage_Laod==0)
;;;1101   			{
;;;1102   				Contr_Laod=0;
;;;1103   			}
;;;1104   			var32 = 0;
00022c  9000              STR      r0,[sp,#0]
00022e  e016              B        |L2.606|
000230  e7ff              B        |L2.562|
                  |L2.562|
000232  69fc              LDR      r4,[r7,#0x1c]         ;1087  ; Run_Control
000234  2c00              CMP      r4,#0                 ;1087
;;;1105   		}
;;;1106   		else//高档
;;;1107   		{
;;;1108   			var32 = Para.CSET_Voltage_Laod;
000236  6914              LDR      r4,[r2,#0x10]  ; Para
000238  d048              BEQ      |L2.716|
;;;1109   			var32 = Para.CSET_Voltage_Laod * CalPara.SetCV[1] + CalPara.OffsetCV[1];  
00023a  edd10a1c          VLDR     s1,[r1,#0x70]
00023e  6914              LDR      r4,[r2,#0x10]  ; Para
000240  edd11a0e          VLDR     s3,[r1,#0x38]
000244  ee014a10          VMOV     s2,r4
000248  eeb81a41          VCVT.F32.U32 s2,s2
00024c  ee410a21          VMLA.F32 s1,s2,s3
000250  eefc0ae0          VCVT.U32.F32 s1,s1
;;;1110   //			if ((CLists.CPolar2 & 0x04) == 0)			   
;;;1111   //			{
;;;1112   //				if (var32 < CLists.CSET_LoadV_Offset_HIG) var32 = 0;
;;;1113   //				else var32 = var32 - CLists.CSET_LoadV_Offset_HIG;
;;;1114   //			}
;;;1115   //			else var32 = var32 + CLists.CSET_LoadV_Offset_HIG;
;;;1116   //			var32 = var32/CLists.CSET_Load_CorrectionV_HIG;
;;;1117   //			var32=var32>>1;
;;;1118   			Contr_Laod = var32;
000254  ee104a90          VMOV     r4,s1
000258  edcd0a00          VSTR     s1,[sp,#0]            ;1109
00025c  801c              STRH     r4,[r3,#0]
                  |L2.606|
;;;1119   //			if(Para.CSET_Voltage_Laod==0)
;;;1120   //			{
;;;1121   //				Contr_Laod=0;
;;;1122   //			}
;;;1123   //			var32 = 0;
;;;1124   		}
;;;1125   		
;;;1126   	}
;;;1127   /*****************************内阻值转换*******************************************/
;;;1128   	if(RCONT_SW==0)//低档
00025e  6a7c              LDR      r4,[r7,#0x24]  ; Run_Control
;;;1129   	{
;;;1130   		var32 = Rmon_value;
000260  4b6f              LDR      r3,|L2.1056|
000262  2c00              CMP      r4,#0                 ;1128
;;;1131   		var32 = var32 * CalPara.TestR[0] + CalPara.OffsetR[0];  
;;;1132   //		if ((CLists.CPolar4 & 0x01) == 0x01)		  
;;;1133   //		{
;;;1134   //			if (var32 < CLists.CREG_ReadR_Offset_LOW) 
;;;1135   //			{
;;;1136   //				var32 = 0;
;;;1137   //			}
;;;1138   //			else var32 = var32 - CLists.CREG_ReadR_Offset_LOW;
;;;1139   //		}
;;;1140   //		else var32 = var32 + CLists.CREG_ReadR_Offset_LOW;
;;;1141   //		var32 = var32 >> 12;
;;;1142   //		if (var32 < 1)
;;;1143   //		{
;;;1144   //			var32 = 0;				  //清零
;;;1145   //		}
;;;1146   		Para.CR_VLUE = var32;
;;;1147   		if(Rmon_value > 60000 && finishdelay == 0)
000264  4e6d              LDR      r6,|L2.1052|
;;;1148   		{
;;;1149   			if(finishflag == 1)
000266  4d6f              LDR      r5,|L2.1060|
;;;1150   			{
;;;1151   				finishflag = 0;
;;;1152   			}
;;;1153   		}
;;;1154   //		if(Para.CR_VLUE > 250)
;;;1155   //		{
;;;1156   //			Para.CR_VLUE = 0;
;;;1157   //		}
;;;1158   		var32 = 0;	
;;;1159   	}
;;;1160   	else//高档
;;;1161   	{
;;;1162   		var32 = Rmon_value;
000268  881c              LDRH     r4,[r3,#0]  ; Rmon_value
00026a  f64e2760          MOV      r7,#0xea60            ;1147
00026e  9400              STR      r4,[sp,#0]            ;1128
000270  d040              BEQ      |L2.756|
;;;1163   		var32 = var32 * CalPara.TestR[1] + CalPara.OffsetR[1];  
000272  ee014a10          VMOV     s2,r4
000276  edd10a2a          VLDR     s1,[r1,#0xa8]
00027a  edd11a25          VLDR     s3,[r1,#0x94]
00027e  eeb81a41          VCVT.F32.U32 s2,s2
000282  ee410a21          VMLA.F32 s1,s2,s3
000286  eefc0ae0          VCVT.U32.F32 s1,s1
;;;1164   //		if ((CLists.CPolar4 & 0x04) == 0x04)		  
;;;1165   //		{
;;;1166   //			if (var32 < CLists.CREG_ReadR_Offset_HIG) 
;;;1167   //			{
;;;1168   //				var32 = 0;
;;;1169   //			}
;;;1170   //			else var32 = var32 - CLists.CREG_ReadR_Offset_HIG;
;;;1171   //		}
;;;1172   //		else var32 = var32 + CLists.CREG_ReadR_Offset_HIG;
;;;1173   //		var32 = var32 >> 12;
;;;1174   //		if (var32 < 1)
;;;1175   //		{
;;;1176   //			var32 = 0;				  //清零
;;;1177   //		}
;;;1178   		Para.CR_VLUE = var32;
00028a  ee104a90          VMOV     r4,s1
00028e  edcd0a00          VSTR     s1,[sp,#0]            ;1163
000292  6394              STR      r4,[r2,#0x38]  ; Para
;;;1179   		if(Para.CR_VLUE > 1000)
000294  6b94              LDR      r4,[r2,#0x38]  ; Para
000296  454c              CMP      r4,r9
000298  d912              BLS      |L2.704|
;;;1180   		{
;;;1181   			var32 = Rmon_value;
00029a  881c              LDRH     r4,[r3,#0]  ; Rmon_value
;;;1182   			var32 = var32 * CalPara.TestR[2] + CalPara.OffsetR[2];
00029c  9400              STR      r4,[sp,#0]
00029e  edd10a2b          VLDR     s1,[r1,#0xac]
0002a2  edd11a26          VLDR     s3,[r1,#0x98]
                  |L2.678|
0002a6  ee014a10          VMOV     s2,r4                 ;1131
0002aa  eeb81a41          VCVT.F32.U32 s2,s2                 ;1131
0002ae  ee410a21          VMLA.F32 s1,s2,s3              ;1131
0002b2  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1131
0002b6  ee104a90          VMOV     r4,s1                 ;1146
0002ba  edcd0a00          VSTR     s1,[sp,#0]            ;1131
0002be  6394              STR      r4,[r2,#0x38]         ;1146  ; Para
                  |L2.704|
;;;1183   			Para.CR_VLUE = var32;
;;;1184   		}
;;;1185   		if(Rmon_value > 60000 && finishdelay == 0)
0002c0  881b              LDRH     r3,[r3,#0]  ; Rmon_value
0002c2  42bb              CMP      r3,r7
0002c4  d91f              BLS      |L2.774|
0002c6  6833              LDR      r3,[r6,#0]            ;1147  ; finishdelay
0002c8  b1cb              CBZ      r3,|L2.766|
0002ca  e01c              B        |L2.774|
                  |L2.716|
0002cc  edd10a1b          VLDR     s1,[r1,#0x6c]         ;1090
0002d0  6914              LDR      r4,[r2,#0x10]         ;1090  ; Para
0002d2  edd11a0d          VLDR     s3,[r1,#0x34]         ;1090
0002d6  ee014a10          VMOV     s2,r4                 ;1090
0002da  eeb81a41          VCVT.F32.U32 s2,s2                 ;1090
0002de  ee410a21          VMLA.F32 s1,s2,s3              ;1090
0002e2  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1090
0002e6  ee104a90          VMOV     r4,s1                 ;1099
0002ea  edcd0a00          VSTR     s1,[sp,#0]            ;1090
0002ee  801c              STRH     r4,[r3,#0]            ;1099
0002f0  6914              LDR      r4,[r2,#0x10]         ;1100  ; Para
0002f2  e799              B        |L2.552|
                  |L2.756|
0002f4  edd10a29          VLDR     s1,[r1,#0xa4]         ;1131
0002f8  edd11a24          VLDR     s3,[r1,#0x90]         ;1131
0002fc  e7d3              B        |L2.678|
                  |L2.766|
0002fe  782b              LDRB     r3,[r5,#0]            ;1149  ; finishflag
000300  2b01              CMP      r3,#1                 ;1149
000302  d100              BNE      |L2.774|
000304  7028              STRB     r0,[r5,#0]            ;1151
                  |L2.774|
;;;1186   		{
;;;1187   			if(finishflag == 1)
;;;1188   			{
;;;1189   				finishflag = 0;
;;;1190   			}
;;;1191   		}
;;;1192   		var32 = 0;	
;;;1193   	}
;;;1194   	
;;;1195   	/*****************************稳压电源测量电压转换*******************************************/
;;;1196   //	var32 = Vmon_POWE_value;
;;;1197   //	var32 = var32 * CalPara.TestPV[0] + CalPara.OffsetPV[0];  
;;;1198   //	//	if ((CLists.CPolar5 & 0x01) == 0x01)		  
;;;1199   //	//	{
;;;1200   //	//		if (var32 < CLists.CREG_POWERV_Offset) 
;;;1201   //	//		{
;;;1202   //	//			var32 = 0;
;;;1203   //	//		}
;;;1204   //	//		else var32 = var32 - CLists.CREG_POWERV_Offset;
;;;1205   //	//	}
;;;1206   //	//	else var32 = var32 + CLists.CREG_POWERV_Offset;
;;;1207   //	//	var32 = var32 >> 12;
;;;1208   //	//	if (var32 < 40) var32 = 0;				  //40mV以下清零
;;;1209   //	Para.CPOW_Voltage = var32;
;;;1210   //	//	DISS_POW_Voltage=Para.CPOW_Voltage;
;;;1211   	DISS_POW_Voltage=(float)Para.CPOW_Voltage/1000;//计算显示电压
000306  9000              STR      r0,[sp,#0]
000308  6a93              LDR      r3,[r2,#0x28]  ; Para
00030a  ee003a90          VMOV     s1,r3
00030e  4b46              LDR      r3,|L2.1064|
000310  eef80a60          VCVT.F32.U32 s1,s1
000314  ee801a80          VDIV.F32 s2,s1,s0
000318  ed831a00          VSTR     s2,[r3,#0]
;;;1212   //	var32 = 0;
;;;1213   /*****************************稳压电源测量电流转换*******************************************/
;;;1214   //	var32 = Imon_POWE_value;
;;;1215   //	if(flag_CC_MODE==1)
;;;1216   //	{
;;;1217   //		var32 = var32 * CalPara.TestPC[0] + CalPara.OffsetTestPC[0];	   
;;;1218   ////		if ((CLists.CPolar6 & 0x01) == 0x01)			   
;;;1219   ////		{
;;;1220   ////			if (var32 < CLists.CREG_POWERA_Offset_CC) var32 = 0;
;;;1221   ////			else var32 = var32 - CLists.CREG_POWERA_Offset_CC;
;;;1222   ////		}
;;;1223   ////		else
;;;1224   ////		{
;;;1225   ////			var32 = var32 + CLists.CREG_POWERA_Offset_CC;
;;;1226   ////		}	
;;;1227   ////		var32 = var32 >> 12;
;;;1228   //		Para.CCurrent = var32;
;;;1229   ////		DISS_POW_Current=Para.CCurrent;
;;;1230   		DISS_POW_Current=(float)Para.CCurrent/100;//计算显示电流
00031c  6b13              LDR      r3,[r2,#0x30]  ; Para
00031e  ee003a10          VMOV     s0,r3
000322  eeb80a40          VCVT.F32.U32 s0,s0
000326  eddf0a41          VLDR     s1,|L2.1068|
00032a  4b41              LDR      r3,|L2.1072|
00032c  ee801a20          VDIV.F32 s2,s0,s1
000330  ed831a00          VSTR     s2,[r3,#0]
;;;1231   //	}
;;;1232   //	else
;;;1233   //	{
;;;1234   //		var32 = var32 * CLists.CREG_POWER_CorrectionA_CV;	   
;;;1235   //		if ((CLists.CPolar6 & 0x08) == 0x08)			   
;;;1236   //		{
;;;1237   //			if (var32 < CLists.CREG_POWERA_Offset_CV) var32 = 0;
;;;1238   //			else var32 = var32 - CLists.CREG_POWERA_Offset_CV;
;;;1239   //		}
;;;1240   //		else
;;;1241   //		{
;;;1242   //			var32 = var32 + CLists.CREG_POWERA_Offset_CV;
;;;1243   //		}	
;;;1244   //		var32 = var32 >> 12;
;;;1245   //		Para.CCurrent = var32;;
;;;1246   ////		DISS_POW_Current=Para.CCurrent;
;;;1247   //		DISS_POW_Current=(float)Para.CCurrent/1000;//计算显示电流
;;;1248   //	}
;;;1249   /**************************稳压电源设置电压转换******************************************/
;;;1250   	var32 = Para.CSET_Voltage;
000334  6893              LDR      r3,[r2,#8]  ; Para
;;;1251   	var32 = var32 * CalPara.SetPV[0] + CalPara.OffsetSetPV[0];   
000336  9300              STR      r3,[sp,#0]
000338  ee003a10          VMOV     s0,r3
00033c  edd10a06          VLDR     s1,[r1,#0x18]
000340  ed911a02          VLDR     s2,[r1,#8]
000344  eeb80a40          VCVT.F32.U32 s0,s0
;;;1252   //	if ((CLists.CPolar5 & 0x04) == 0)			   
;;;1253   //	{
;;;1254   //		if (var32 < CLists.CSET_POWERV_Offset) var32 = 0;
;;;1255   //		else var32 = var32 - CLists.CSET_POWERV_Offset;
;;;1256   //	}
;;;1257   //	else var32 = var32 + CLists.CSET_POWERV_Offset;
;;;1258   //	var32 = var32/CLists.CSET_POWER_CorrectionV;
;;;1259   //	var32=var32>>1;
;;;1260   	Contr_Voltage = var32;
000348  4b3a              LDR      r3,|L2.1076|
00034a  ee400a01          VMLA.F32 s1,s0,s2              ;1251
00034e  eebc0ae0          VCVT.U32.F32 s0,s1                 ;1251
000352  ee104a10          VMOV     r4,s0
000356  ed8d0a00          VSTR     s0,[sp,#0]            ;1251
00035a  801c              STRH     r4,[r3,#0]
;;;1261   	if(Para.CSET_Voltage==0)
00035c  6894              LDR      r4,[r2,#8]  ; Para
00035e  b904              CBNZ     r4,|L2.866|
;;;1262   	{
;;;1263   		Contr_Voltage=0;
000360  8018              STRH     r0,[r3,#0]
                  |L2.866|
;;;1264   	}
;;;1265   	var32 = 0;
;;;1266   /**************************稳压电源设置电流转换**************************************/
;;;1267   	var32 = Para.CSET_Current;
000362  68d3              LDR      r3,[r2,#0xc]  ; Para
;;;1268   	var32 = var32 * CalPara.SetPC[0] + CalPara.OffsetPC[0];  
000364  9300              STR      r3,[sp,#0]
000366  ee003a90          VMOV     s1,r3
00036a  ed910a22          VLDR     s0,[r1,#0x88]
00036e  ed911a14          VLDR     s2,[r1,#0x50]
000372  eef80a60          VCVT.F32.U32 s1,s1
;;;1269   //	if ((CLists.CPolar6 & 0x04) == 0)			   
;;;1270   //	{
;;;1271   //		if (var32 < CLists.CSET_POWERA_Offset) var32 = 0;
;;;1272   //		else var32 = var32 - CLists.CSET_POWERA_Offset;
;;;1273   //	}
;;;1274   //	else var32 = var32 + CLists.CSET_POWERA_Offset;
;;;1275   //	var32 = var32/CLists.CSET_POWER_CorrectionA;
;;;1276   //	var32=var32>>1;
;;;1277   	Contr_Current = var32;
000376  4b30              LDR      r3,|L2.1080|
000378  ee000a81          VMLA.F32 s0,s1,s2              ;1268
00037c  eebc0ac0          VCVT.U32.F32 s0,s0                 ;1268
000380  ee104a10          VMOV     r4,s0
000384  ed8d0a00          VSTR     s0,[sp,#0]            ;1268
000388  801c              STRH     r4,[r3,#0]
;;;1278   	if(Para.CSET_Current==0)
00038a  68d4              LDR      r4,[r2,#0xc]  ; Para
00038c  b904              CBNZ     r4,|L2.912|
;;;1279   	{
;;;1280   		Contr_Current=0;
00038e  8018              STRH     r0,[r3,#0]
                  |L2.912|
;;;1281   	}
;;;1282   	var32 = 0;
;;;1283   	
;;;1284   /********************识别电阻1转换******************************/
;;;1285   //	var32=(R1mon_value*1000)/(65535-R1mon_value);
;;;1286   	var32 = (R1mon_value*1000)/(65535-R1mon_value);
000390  4b2a              LDR      r3,|L2.1084|
000392  881c              LDRH     r4,[r3,#0]  ; R1mon_value
000394  f44f757a          MOV      r5,#0x3e8
000398  436c              MULS     r4,r5,r4
00039a  881d              LDRH     r5,[r3,#0]  ; R1mon_value
00039c  f64f73ff          MOV      r3,#0xffff
0003a0  1b5d              SUBS     r5,r3,r5
0003a2  fbb4f4f5          UDIV     r4,r4,r5
;;;1287   	var32 = var32 * CalPara.TestR1[0] + CalPara.OffsetR1[0];  
0003a6  ee004a90          VMOV     s1,r4
0003aa  9400              STR      r4,[sp,#0]
0003ac  ed910a2c          VLDR     s0,[r1,#0xb0]
0003b0  eef80a60          VCVT.F32.U32 s1,s1
0003b4  ed911a27          VLDR     s2,[r1,#0x9c]
0003b8  ee000a81          VMLA.F32 s0,s1,s2
0003bc  eebc0ac0          VCVT.U32.F32 s0,s0
;;;1288   //	if ((CLists.CPolar7 & 0x01) == 0x01)		  
;;;1289   //	{
;;;1290   //		if (var32 < CLists.CREG_ReadR1_Offset) 
;;;1291   //		{
;;;1292   //			var32 = 0;
;;;1293   //		}
;;;1294   //		else var32 = var32 - CLists.CREG_ReadR1_Offset;
;;;1295   //	}
;;;1296   //	else var32 = var32 + CLists.CREG_ReadR1_Offset;
;;;1297   //	var32 = var32 >> 12;
;;;1298   //	if (var32 < 1)
;;;1299   //	{
;;;1300   //		var32 = 0;				  //清零
;;;1301   //	}
;;;1302   	Para.CR1_VLUE = var32;
0003c0  ee104a10          VMOV     r4,s0
0003c4  ed8d0a00          VSTR     s0,[sp,#0]            ;1287
0003c8  63d4              STR      r4,[r2,#0x3c]  ; Para
;;;1303   //	if(R1mon_value > 34000)
;;;1304   //	{
;;;1305   //		Para.CR1_VLUE = 100;
;;;1306   //	}
;;;1307   	var32 = 0;	
;;;1308   	
;;;1309   	
;;;1310   /********************识别电阻2转换******************************/	
;;;1311   	var32 = (R2mon_value*1000)/(65535-R2mon_value);
0003ca  4c1d              LDR      r4,|L2.1088|
0003cc  8825              LDRH     r5,[r4,#0]  ; R2mon_value
0003ce  f44f767a          MOV      r6,#0x3e8
0003d2  8824              LDRH     r4,[r4,#0]  ; R2mon_value
0003d4  4375              MULS     r5,r6,r5
0003d6  1b1b              SUBS     r3,r3,r4
0003d8  fbb5f3f3          UDIV     r3,r5,r3
;;;1312   	var32 = var32 * CalPara.TestR2[0] + CalPara.OffsetR2[0];   
0003dc  ee003a90          VMOV     s1,r3
0003e0  9300              STR      r3,[sp,#0]
0003e2  ed910a2d          VLDR     s0,[r1,#0xb4]
0003e6  eef80a60          VCVT.F32.U32 s1,s1
0003ea  ed911a28          VLDR     s2,[r1,#0xa0]
0003ee  ee000a81          VMLA.F32 s0,s1,s2
0003f2  eebc0ac0          VCVT.U32.F32 s0,s0
0003f6  e025              B        |L2.1092|
                  |L2.1016|
                          DCD      ||area_number.7||
                  |L2.1020|
                          DCD      Vmon_Load_value
                  |L2.1024|
                          DCD      DISS_Voltage
                  |L2.1028|
000404  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.1032|
                          DCD      CalPara
                  |L2.1036|
                          DCD      Para
                  |L2.1040|
                          DCD      DISS_Current
                  |L2.1044|
                          DCD      Imon_Load_value
                  |L2.1048|
                          DCD      Contr_Laod
                  |L2.1052|
                          DCD      finishdelay
                  |L2.1056|
                          DCD      Rmon_value
                  |L2.1060|
                          DCD      finishflag
                  |L2.1064|
                          DCD      DISS_POW_Voltage
                  |L2.1068|
00042c  42c80000          DCFS     0x42c80000 ; 100
                  |L2.1072|
                          DCD      DISS_POW_Current
                  |L2.1076|
                          DCD      Contr_Voltage
                  |L2.1080|
                          DCD      Contr_Current
                  |L2.1084|
                          DCD      R1mon_value
                  |L2.1088|
                          DCD      R2mon_value
                  |L2.1092|
;;;1313   //	if ((CLists.CPolar7 & 0x04) == 0x04)		  
;;;1314   //	{
;;;1315   //		if (var32 < CLists.CREG_ReadR2_Offset) 
;;;1316   //		{
;;;1317   //			var32 = 0;
;;;1318   //		}
;;;1319   //		else var32 = var32 - CLists.CREG_ReadR2_Offset;
;;;1320   //	}
;;;1321   //	else var32 = var32 + CLists.CREG_ReadR2_Offset;
;;;1322   //	var32 = var32 >> 12;
;;;1323   //	if (var32 < 1)
;;;1324   //	{
;;;1325   //		var32 = 0;				  //清零
;;;1326   //	}
;;;1327   	Para.CR2_VLUE = var32;
000444  ee101a10          VMOV     r1,s0
000448  ed8d0a00          VSTR     s0,[sp,#0]
00044c  6411              STR      r1,[r2,#0x40]  ; Para
;;;1328   	var32 = 0;	
00044e  9000              STR      r0,[sp,#0]
;;;1329   }
000450  e8bd83f8          POP      {r3-r9,pc}
;;;1330   /********************************************************************************
                          ENDP


                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;46     //===========================MODBUS协议=============================//
;;;47     void UART_Action(void)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;48     {//RUT格式：
;;;49     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;50     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;51     	if (UART_Buffer_Rece[0] == ADDR)
000004  f8df83e8          LDR      r8,|L3.1008|
000008  f8980000          LDRB     r0,[r8,#0]  ; UART_Buffer_Rece
00000c  4cf9              LDR      r4,|L3.1012|
00000e  7821              LDRB     r1,[r4,#0]  ; ADDR
;;;52     	{
;;;53     		if (UART_Buffer_Rece[1] == (0x03))	//命令3 读数据   
;;;54     		{																		 
;;;55     			vu8 i;
;;;56     			vu16 crc_result;
;;;57     			crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;58     			if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )
;;;59     			{
;;;60     				if (UART_Buffer_Rece[3] < 0x07)    								//如果寄存器在可读范围内
;;;61     				{
;;;62     					if ((UART_Buffer_Rece[3] + UART_Buffer_Rece[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;63     					{							
;;;64     						UART_Buffer_Send[0] = ADDR;
000010  4ef9              LDR      r6,|L3.1016|
;;;65     						UART_Buffer_Send[1] = 0x03;
;;;66     						UART_Buffer_Send[2] = UART_Buffer_Rece[5]*2;
;;;67     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;68     						{
;;;69     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2] >> 8;
;;;70     							else UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2];														
;;;71     						}
;;;72     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;73     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;74     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;75     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
000012  f8dfa3e8          LDR      r10,|L3.1020|
;;;76     						UART_SEND_flag=1;
000016  4ffa              LDR      r7,|L3.1024|
000018  f8df93e8          LDR      r9,|L3.1028|
00001c  2500              MOVS     r5,#0                 ;69
00001e  4288              CMP      r0,r1                 ;51
000020  d167              BNE      |L3.242|
000022  f8980001          LDRB     r0,[r8,#1]            ;53  ; UART_Buffer_Rece
000026  2803              CMP      r0,#3                 ;53
000028  d163              BNE      |L3.242|
00002a  f8980007          LDRB     r0,[r8,#7]            ;57  ; UART_Buffer_Rece
00002e  f8981006          LDRB     r1,[r8,#6]            ;57  ; UART_Buffer_Rece
000032  eb002001          ADD      r0,r0,r1,LSL #8       ;57
000036  f8ad0004          STRH     r0,[sp,#4]            ;57
00003a  2106              MOVS     r1,#6                 ;58
00003c  4640              MOV      r0,r8                 ;58
00003e  f7fffffe          BL       Hardware_CRC
000042  f8bd1004          LDRH     r1,[sp,#4]            ;58
000046  4288              CMP      r0,r1                 ;58
000048  d002              BEQ      |L3.80|
00004a  f8bd0004          LDRH     r0,[sp,#4]            ;58
00004e  bbe8              CBNZ     r0,|L3.204|
                  |L3.80|
000050  f8980003          LDRB     r0,[r8,#3]            ;60  ; UART_Buffer_Rece
000054  2807              CMP      r0,#7                 ;60
000056  d24c              BCS      |L3.242|
000058  f8980003          LDRB     r0,[r8,#3]            ;62  ; UART_Buffer_Rece
00005c  f8981005          LDRB     r1,[r8,#5]            ;62  ; UART_Buffer_Rece
000060  4408              ADD      r0,r0,r1              ;62
000062  280f              CMP      r0,#0xf               ;62
000064  d245              BCS      |L3.242|
000066  7820              LDRB     r0,[r4,#0]            ;64  ; ADDR
000068  7030              STRB     r0,[r6,#0]            ;64
00006a  2003              MOVS     r0,#3                 ;65
00006c  7070              STRB     r0,[r6,#1]            ;65
00006e  f8980005          LDRB     r0,[r8,#5]            ;66  ; UART_Buffer_Rece
000072  0040              LSLS     r0,r0,#1              ;66
000074  70b0              STRB     r0,[r6,#2]            ;66
000076  f88d5000          STRB     r5,[sp,#0]            ;67
00007a  4649              MOV      r1,r9                 ;69
00007c  e015              B        |L3.170|
                  |L3.126|
00007e  f89d0000          LDRB     r0,[sp,#0]            ;69
000082  07c0              LSLS     r0,r0,#31             ;69
000084  f8980003          LDRB     r0,[r8,#3]            ;70  ; UART_Buffer_Rece
000088  f89d2000          LDRB     r2,[sp,#0]            ;70
00008c  eb000052          ADD      r0,r0,r2,LSR #1       ;70
000090  f8510020          LDR      r0,[r1,r0,LSL #2]     ;70
000094  d100              BNE      |L3.152|
000096  0a00              LSRS     r0,r0,#8              ;69
                  |L3.152|
000098  f89d2000          LDRB     r2,[sp,#0]            ;70
00009c  4432              ADD      r2,r2,r6              ;70
00009e  70d0              STRB     r0,[r2,#3]            ;70
0000a0  f89d0000          LDRB     r0,[sp,#0]            ;67
0000a4  1c40              ADDS     r0,r0,#1              ;67
0000a6  f88d0000          STRB     r0,[sp,#0]            ;67
                  |L3.170|
0000aa  78b0              LDRB     r0,[r6,#2]            ;67  ; UART_Buffer_Send
0000ac  f89d2000          LDRB     r2,[sp,#0]            ;67
0000b0  4290              CMP      r0,r2                 ;67
0000b2  d8e4              BHI      |L3.126|
0000b4  78b0              LDRB     r0,[r6,#2]            ;72  ; UART_Buffer_Send
0000b6  1cc0              ADDS     r0,r0,#3              ;72
0000b8  b2c1              UXTB     r1,r0                 ;72
0000ba  48cf              LDR      r0,|L3.1016|
0000bc  f7fffffe          BL       Hardware_CRC
0000c0  f8ad0004          STRH     r0,[sp,#4]            ;72
0000c4  f8bd0004          LDRH     r0,[sp,#4]            ;73
0000c8  0a01              LSRS     r1,r0,#8              ;73
0000ca  e000              B        |L3.206|
                  |L3.204|
0000cc  e011              B        |L3.242|
                  |L3.206|
0000ce  78b2              LDRB     r2,[r6,#2]            ;73  ; UART_Buffer_Send
0000d0  48c9              LDR      r0,|L3.1016|
0000d2  1cc0              ADDS     r0,r0,#3              ;73
0000d4  5411              STRB     r1,[r2,r0]            ;73
0000d6  f8bd0004          LDRH     r0,[sp,#4]            ;74
0000da  78b2              LDRB     r2,[r6,#2]            ;74  ; UART_Buffer_Send
0000dc  49c6              LDR      r1,|L3.1016|
0000de  1d09              ADDS     r1,r1,#4              ;74
0000e0  5450              STRB     r0,[r2,r1]            ;74
0000e2  78b0              LDRB     r0,[r6,#2]            ;75  ; UART_Buffer_Send
0000e4  1d40              ADDS     r0,r0,#5              ;75
0000e6  f88a0000          STRB     r0,[r10,#0]           ;75
0000ea  6839              LDR      r1,[r7,#0]  ; flagA
0000ec  f0410110          ORR      r1,r1,#0x10
0000f0  6039              STR      r1,[r7,#0]  ; flagA
                  |L3.242|
;;;77     					}
;;;78     				}
;;;79     			}	
;;;80     		}
;;;81     	} 
;;;82     //===============================写寄存器=================================
;;;83     	if ((UART_Buffer_Rece[0] == 0) ||  (UART_Buffer_Rece[0] == ADDR) || (UART_Buffer_Rece[0] == ((ADDR-1)/4+100)))	 
0000f2  f8980000          LDRB     r0,[r8,#0]  ; UART_Buffer_Rece
0000f6  b180              CBZ      r0,|L3.282|
0000f8  f8981000          LDRB     r1,[r8,#0]  ; UART_Buffer_Rece
0000fc  7820              LDRB     r0,[r4,#0]  ; ADDR
0000fe  4281              CMP      r1,r0
000100  d00b              BEQ      |L3.282|
000102  7820              LDRB     r0,[r4,#0]  ; ADDR
000104  f8981000          LDRB     r1,[r8,#0]  ; UART_Buffer_Rece
000108  1e40              SUBS     r0,r0,#1
00010a  17c2              ASRS     r2,r0,#31
00010c  eb007292          ADD      r2,r0,r2,LSR #30
000110  2064              MOVS     r0,#0x64
000112  eb0000a2          ADD      r0,r0,r2,ASR #2
000116  4281              CMP      r1,r0
000118  d170              BNE      |L3.508|
                  |L3.282|
;;;84     	{
;;;85     		vu8 var8;
;;;86     		vu8 a=0;
00011a  f88d5008          STRB     r5,[sp,#8]
;;;87     		vu16 var16;
;;;88     		vu16 crc_result;
;;;89     //=========================以下命令6 写单个寄存器===========================
;;;90     		if (UART_Buffer_Rece[1] == 6)                                 //判断第二个字节是否为命令6
00011e  f8980001          LDRB     r0,[r8,#1]  ; UART_Buffer_Rece
;;;91     		{
;;;92     			if (UART_Buffer_Rece[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;93     			{
;;;94     				crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;95     				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )		  //检查CRC
;;;96     				{
;;;97     					var16 = (UART_Buffer_Rece[4] << 8) + UART_Buffer_Rece[5];	//第5 6个字节为要写入的数据
;;;98     					var8 = UART_Buffer_Rece[3];	        						//第3 4个字节为要写入的地址
;;;99     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;100    
;;;101    					if (UART_Buffer_Rece[0] == ADDR)							//广播模式下不返回数据
;;;102    					{
;;;103    						for (a=0;a<8;a++)
;;;104    						{UART_Buffer_Send[a] = UART_Buffer_Rece[a];}
;;;105    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
000122  f04f0b08          MOV      r11,#8
000126  2806              CMP      r0,#6                 ;90
000128  d146              BNE      |L3.440|
00012a  f8980003          LDRB     r0,[r8,#3]            ;92  ; UART_Buffer_Rece
00012e  2805              CMP      r0,#5                 ;92
000130  d242              BCS      |L3.440|
000132  f8980007          LDRB     r0,[r8,#7]            ;94  ; UART_Buffer_Rece
000136  f8981006          LDRB     r1,[r8,#6]            ;94  ; UART_Buffer_Rece
00013a  eb002001          ADD      r0,r0,r1,LSL #8       ;94
00013e  f8ad0004          STRH     r0,[sp,#4]            ;94
000142  2106              MOVS     r1,#6                 ;95
000144  48aa              LDR      r0,|L3.1008|
000146  f7fffffe          BL       Hardware_CRC
00014a  f8bd1004          LDRH     r1,[sp,#4]            ;95
00014e  4288              CMP      r0,r1                 ;95
000150  d002              BEQ      |L3.344|
000152  f8bd0004          LDRH     r0,[sp,#4]            ;95
000156  bb78              CBNZ     r0,|L3.440|
                  |L3.344|
000158  f8980005          LDRB     r0,[r8,#5]            ;97  ; UART_Buffer_Rece
00015c  f8981004          LDRB     r1,[r8,#4]            ;97  ; UART_Buffer_Rece
000160  eb002001          ADD      r0,r0,r1,LSL #8       ;97
000164  f8ad000c          STRH     r0,[sp,#0xc]          ;97
000168  f8980003          LDRB     r0,[r8,#3]            ;98  ; UART_Buffer_Rece
00016c  f88d0000          STRB     r0,[sp,#0]            ;98
000170  f8bd100c          LDRH     r1,[sp,#0xc]          ;99
000174  f89d2000          LDRB     r2,[sp,#0]            ;99
000178  f8491022          STR      r1,[r9,r2,LSL #2]     ;99
00017c  f8980000          LDRB     r0,[r8,#0]            ;101  ; UART_Buffer_Rece
000180  7821              LDRB     r1,[r4,#0]            ;101  ; ADDR
000182  4288              CMP      r0,r1                 ;101
000184  d118              BNE      |L3.440|
000186  f88d5008          STRB     r5,[sp,#8]            ;103
00018a  e00b              B        |L3.420|
                  |L3.396|
00018c  f89d0008          LDRB     r0,[sp,#8]            ;104
000190  f8180000          LDRB     r0,[r8,r0]            ;104
000194  f89d1008          LDRB     r1,[sp,#8]            ;104
000198  5470              STRB     r0,[r6,r1]            ;104
00019a  f89d0008          LDRB     r0,[sp,#8]            ;103
00019e  1c40              ADDS     r0,r0,#1              ;103
0001a0  f88d0008          STRB     r0,[sp,#8]            ;103
                  |L3.420|
0001a4  f89d0008          LDRB     r0,[sp,#8]            ;103
0001a8  2808              CMP      r0,#8                 ;103
0001aa  d3ef              BCC      |L3.396|
0001ac  f88ab000          STRB     r11,[r10,#0]
;;;106    						UART_SEND_flag=1;
0001b0  6839              LDR      r1,[r7,#0]  ; flagA
0001b2  f0410110          ORR      r1,r1,#0x10
0001b6  6039              STR      r1,[r7,#0]  ; flagA
                  |L3.440|
;;;107    					}
;;;108    				}
;;;109    			}
;;;110    		}
;;;111    //=======================================以下是命令16，连写寄存器===========================================
;;;112    //功能码16格式:
;;;113    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;114    //返回数据格式:
;;;115    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;116    		if (UART_Buffer_Rece[1] == 16)										  
0001b8  f8980001          LDRB     r0,[r8,#1]  ; UART_Buffer_Rece
0001bc  2810              CMP      r0,#0x10
0001be  d15f              BNE      |L3.640|
;;;117    		{	
;;;118    			if ((UART_Buffer_Rece[6] == 6) && (UART_Buffer_Rece[3] == 0x00))	//规定连写寄存器的个数
0001c0  f8980006          LDRB     r0,[r8,#6]  ; UART_Buffer_Rece
0001c4  2806              CMP      r0,#6
0001c6  d15b              BNE      |L3.640|
0001c8  f8980003          LDRB     r0,[r8,#3]  ; UART_Buffer_Rece
0001cc  b9b0              CBNZ     r0,|L3.508|
;;;119    			{
;;;120    				crc_result = (UART_Buffer_Rece[13] << 8) + UART_Buffer_Rece[14];
0001ce  f898100e          LDRB     r1,[r8,#0xe]  ; UART_Buffer_Rece
0001d2  f898000d          LDRB     r0,[r8,#0xd]  ; UART_Buffer_Rece
0001d6  eb012000          ADD      r0,r1,r0,LSL #8
0001da  f8ad0004          STRH     r0,[sp,#4]
;;;121    				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,13)) ||(crc_result == 0) )	   //检查CRC
0001de  210d              MOVS     r1,#0xd
0001e0  4883              LDR      r0,|L3.1008|
0001e2  f7fffffe          BL       Hardware_CRC
0001e6  f8bd1004          LDRH     r1,[sp,#4]
0001ea  4288              CMP      r0,r1
0001ec  d002              BEQ      |L3.500|
0001ee  f8bd0004          LDRH     r0,[sp,#4]
0001f2  b918              CBNZ     r0,|L3.508|
                  |L3.500|
;;;122    				{												
;;;123    					for (var8=0;var8<3;var8++) Run_Control[var8] = (UART_Buffer_Rece[var8*2+7] << 8) + UART_Buffer_Rece[var8*2+8];
0001f4  f88d5000          STRB     r5,[sp,#0]
0001f8  4649              MOV      r1,r9                 ;69
0001fa  e015              B        |L3.552|
                  |L3.508|
0001fc  e040              B        |L3.640|
                  |L3.510|
0001fe  f89d0000          LDRB     r0,[sp,#0]
000202  eb080040          ADD      r0,r8,r0,LSL #1
000206  7a00              LDRB     r0,[r0,#8]
000208  f89d2000          LDRB     r2,[sp,#0]
00020c  eb080242          ADD      r2,r8,r2,LSL #1
000210  79d2              LDRB     r2,[r2,#7]
000212  eb002002          ADD      r0,r0,r2,LSL #8
000216  f89d2000          LDRB     r2,[sp,#0]
00021a  f8410022          STR      r0,[r1,r2,LSL #2]
00021e  f89d0000          LDRB     r0,[sp,#0]
000222  1c40              ADDS     r0,r0,#1
000224  f88d0000          STRB     r0,[sp,#0]
                  |L3.552|
000228  f89d0000          LDRB     r0,[sp,#0]
00022c  2803              CMP      r0,#3
00022e  d3e6              BCC      |L3.510|
;;;124    
;;;125    					if (UART_Buffer_Rece[0] == ADDR)					  //广播模式不返回数据
000230  f8981000          LDRB     r1,[r8,#0]  ; UART_Buffer_Rece
000234  7820              LDRB     r0,[r4,#0]  ; ADDR
000236  4281              CMP      r1,r0
000238  d122              BNE      |L3.640|
;;;126    					{
;;;127    						UART_Buffer_Send[0] = ADDR;
00023a  7820              LDRB     r0,[r4,#0]  ; ADDR
00023c  7030              STRB     r0,[r6,#0]
;;;128    						UART_Buffer_Send[1] = 16;
00023e  2010              MOVS     r0,#0x10
000240  7070              STRB     r0,[r6,#1]
;;;129    						UART_Buffer_Send[2] = UART_Buffer_Rece[2];
000242  f8980002          LDRB     r0,[r8,#2]  ; UART_Buffer_Rece
000246  70b0              STRB     r0,[r6,#2]
;;;130    						UART_Buffer_Send[3] = UART_Buffer_Rece[3];
000248  f8980003          LDRB     r0,[r8,#3]  ; UART_Buffer_Rece
00024c  70f0              STRB     r0,[r6,#3]
;;;131    						UART_Buffer_Send[4] = UART_Buffer_Rece[4];
00024e  f8980004          LDRB     r0,[r8,#4]  ; UART_Buffer_Rece
000252  7130              STRB     r0,[r6,#4]
;;;132    						UART_Buffer_Send[5] = UART_Buffer_Rece[5];
000254  f8980005          LDRB     r0,[r8,#5]  ; UART_Buffer_Rece
000258  7170              STRB     r0,[r6,#5]
;;;133    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
00025a  2106              MOVS     r1,#6
00025c  4866              LDR      r0,|L3.1016|
00025e  f7fffffe          BL       Hardware_CRC
000262  f8ad0004          STRH     r0,[sp,#4]
;;;134    						UART_Buffer_Send[6] = crc_result>>8;
000266  f8bd0004          LDRH     r0,[sp,#4]
00026a  0a00              LSRS     r0,r0,#8
00026c  71b0              STRB     r0,[r6,#6]
;;;135    						UART_Buffer_Send[7] = crc_result;				 
00026e  f8bd0004          LDRH     r0,[sp,#4]
000272  71f0              STRB     r0,[r6,#7]
;;;136    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
000274  f88ab000          STRB     r11,[r10,#0]
;;;137    						UART_SEND_flag=1;
000278  6839              LDR      r1,[r7,#0]  ; flagA
00027a  f0410110          ORR      r1,r1,#0x10
00027e  6039              STR      r1,[r7,#0]  ; flagA
                  |L3.640|
;;;138    					}
;;;139    				}
;;;140    			}			 
;;;141    		}
;;;142    	}
;;;143    /*************************************以下为校准部分**************************************************************************/
;;;144    	if (((UART_Buffer_Rece[0] == 0x01)&&(UART_Buffer_Rece[2] == 0xA5)))			   //校准开始
000280  f8980000          LDRB     r0,[r8,#0]  ; UART_Buffer_Rece
000284  2801              CMP      r0,#1
                  |L3.646|
000286  d17c              BNE      |L3.898|
000288  f8980002          LDRB     r0,[r8,#2]  ; UART_Buffer_Rece
00028c  28a5              CMP      r0,#0xa5
00028e  d1fa              BNE      |L3.646|
;;;145    	{ 
;;;146    		vu16 crc_result;
;;;147    		crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
000290  f8980007          LDRB     r0,[r8,#7]  ; UART_Buffer_Rece
000294  f8981006          LDRB     r1,[r8,#6]  ; UART_Buffer_Rece
000298  eb002001          ADD      r0,r0,r1,LSL #8
00029c  f8ad0000          STRH     r0,[sp,#0]
;;;148    		if (crc_result == Hardware_CRC(UART_Buffer_Rece,6) ||crc_result==0)
0002a0  2106              MOVS     r1,#6
0002a2  4853              LDR      r0,|L3.1008|
0002a4  f7fffffe          BL       Hardware_CRC
0002a8  f8bd1000          LDRH     r1,[sp,#0]
0002ac  4288              CMP      r0,r1
0002ae  d003              BEQ      |L3.696|
0002b0  f8bd0000          LDRH     r0,[sp,#0]
0002b4  2800              CMP      r0,#0
0002b6  d1e6              BNE      |L3.646|
                  |L3.696|
;;;149    		{
;;;150    			/**************负载电压低档校准***************************/
;;;151    			if(UART_Buffer_Rece[1] == 0x01)
0002b8  f8980001          LDRB     r0,[r8,#1]  ; UART_Buffer_Rece
;;;152    			{
;;;153    				Modify_A_READ=0;
;;;154    				Modify_A_ACT=0;
;;;155    				Modify_A_READ = Vmon_Load_value;//测量电压值
0002bc  4952              LDR      r1,|L3.1032|
0002be  2801              CMP      r0,#1                 ;151
0002c0  d10a              BNE      |L3.728|
0002c2  6065              STR      r5,[r4,#4]            ;153  ; Modify_A_READ
0002c4  60e5              STR      r5,[r4,#0xc]          ;154  ; Modify_A_ACT
0002c6  8808              LDRH     r0,[r1,#0]  ; Vmon_Load_value
0002c8  6060              STR      r0,[r4,#4]  ; Modify_A_READ
;;;156    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0002ca  f8980004          LDRB     r0,[r8,#4]  ; UART_Buffer_Rece
0002ce  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
0002d2  eb002002          ADD      r0,r0,r2,LSL #8
0002d6  60e0              STR      r0,[r4,#0xc]  ; Modify_A_ACT
                  |L3.728|
;;;157    			}
;;;158    			if (UART_Buffer_Rece[1] == 0x02)			   //电压测量校准完成
0002d8  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;159    			{
;;;160    				vu32 var16;
;;;161    				vu32 var32a;
;;;162    				vu32 var32b;
;;;163    				
;;;164    				vu32 var16a;
;;;165    				vu32 var32c;
;;;166    				vu32 var32d;
;;;167    				Modify_B_READ=0;
;;;168    				Modify_B_ACT=0;
;;;169    				Modify_B_READ =Vmon_Load_value;//测量电压值
;;;170    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
;;;171    				var32a = Modify_B_ACT;
;;;172    				var32a = var32a - Modify_A_ACT;
;;;173    				var32a = var32a << 12;
;;;174    				var16 = Modify_B_READ - Modify_A_READ;
;;;175    				var32a = var32a / var16;
;;;176    				CLists.CREG_Load_CorrectionV_LOW = var32a;
0002dc  484b              LDR      r0,|L3.1036|
;;;177    				var32a=0;
;;;178    				var32a = Modify_B_ACT;
;;;179    				var32a = var32a << 12;
;;;180    				var32b = Modify_B_READ;
;;;181    				var32b = var32b * CLists.CREG_Load_CorrectionV_LOW;    //内阻电压测量参数低档	
;;;182    				if (var32a < var32b)
;;;183    				{
;;;184    					var32b = var32b - var32a;
;;;185    					CLists.CREG_LoadV_Offset_LOW = var32b;     //内阻电压测量参数  
;;;186    					CLists.CPolar0 |= 0x01;
;;;187    				}
;;;188    				else 
;;;189    				{
;;;190    					var32a = var32a - var32b;
;;;191    					CLists.CREG_LoadV_Offset_LOW = var32a;
;;;192    					CLists.CPolar0 &= ~0x01;
;;;193    				}			
;;;194    					//参数写进FLASH
;;;195    				Flag_DAC_OFF=0;
0002de  4e4c              LDR      r6,|L3.1040|
0002e0  2a02              CMP      r2,#2                 ;158
0002e2  d13e              BNE      |L3.866|
0002e4  6125              STR      r5,[r4,#0x10]         ;167  ; Modify_B_READ
0002e6  61a5              STR      r5,[r4,#0x18]         ;168  ; Modify_B_ACT
0002e8  880a              LDRH     r2,[r1,#0]            ;169  ; Vmon_Load_value
0002ea  6122              STR      r2,[r4,#0x10]         ;169  ; Modify_B_READ
0002ec  f8982004          LDRB     r2,[r8,#4]            ;170  ; UART_Buffer_Rece
0002f0  f8983003          LDRB     r3,[r8,#3]            ;170  ; UART_Buffer_Rece
0002f4  eb022203          ADD      r2,r2,r3,LSL #8       ;170
0002f8  61a2              STR      r2,[r4,#0x18]         ;170  ; Modify_B_ACT
0002fa  69a2              LDR      r2,[r4,#0x18]         ;171  ; Modify_B_ACT
0002fc  9202              STR      r2,[sp,#8]            ;172
0002fe  68e3              LDR      r3,[r4,#0xc]          ;172  ; Modify_A_ACT
000300  1ad2              SUBS     r2,r2,r3              ;172
000302  0312              LSLS     r2,r2,#12             ;173
000304  9202              STR      r2,[sp,#8]            ;174
000306  6922              LDR      r2,[r4,#0x10]         ;174  ; Modify_B_READ
000308  6863              LDR      r3,[r4,#4]            ;174  ; Modify_A_READ
00030a  1ad2              SUBS     r2,r2,r3              ;174
00030c  9203              STR      r2,[sp,#0xc]          ;174
00030e  e9dd2302          LDRD     r2,r3,[sp,#8]         ;174
000312  fbb2f2f3          UDIV     r2,r2,r3              ;175
000316  9202              STR      r2,[sp,#8]            ;176
000318  6002              STR      r2,[r0,#0]            ;176  ; CLists
00031a  69a2              LDR      r2,[r4,#0x18]         ;178  ; Modify_B_ACT
00031c  0312              LSLS     r2,r2,#12             ;179
00031e  9202              STR      r2,[sp,#8]            ;180
000320  6922              LDR      r2,[r4,#0x10]         ;180  ; Modify_B_READ
000322  9201              STR      r2,[sp,#4]            ;181
000324  6802              LDR      r2,[r0,#0]            ;181  ; CLists
000326  9b01              LDR      r3,[sp,#4]            ;181
000328  435a              MULS     r2,r3,r2              ;181
00032a  9201              STR      r2,[sp,#4]            ;181
00032c  e9dd3201          LDRD     r3,r2,[sp,#4]         ;181
000330  429a              CMP      r2,r3                 ;182
000332  d209              BCS      |L3.840|
000334  461a              MOV      r2,r3                 ;184
000336  9b02              LDR      r3,[sp,#8]            ;184
000338  1ad2              SUBS     r2,r2,r3              ;184
00033a  9201              STR      r2,[sp,#4]            ;185
00033c  6442              STR      r2,[r0,#0x44]         ;185  ; CLists
00033e  f8902088          LDRB     r2,[r0,#0x88]         ;186  ; CLists
000342  f0420201          ORR      r2,r2,#1              ;186
000346  e006              B        |L3.854|
                  |L3.840|
000348  1ad2              SUBS     r2,r2,r3              ;190
00034a  9202              STR      r2,[sp,#8]            ;191
00034c  6442              STR      r2,[r0,#0x44]         ;191  ; CLists
00034e  f8902088          LDRB     r2,[r0,#0x88]         ;192  ; CLists
000352  f0220201          BIC      r2,r2,#1              ;192
                  |L3.854|
000356  f8802088          STRB     r2,[r0,#0x88]         ;192
00035a  6832              LDR      r2,[r6,#0]  ; flagB
00035c  f0220208          BIC      r2,r2,#8
000360  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.866|
;;;196    			}
;;;197    			
;;;198    			/**************负载电压高档校准***************************/
;;;199    			if(UART_Buffer_Rece[1] == 0x03)
000362  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000366  2a03              CMP      r2,#3
000368  d10a              BNE      |L3.896|
;;;200    			{
;;;201    				Modify_A_READ=0;
00036a  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;202    				Modify_A_ACT=0;
00036c  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;203    				Modify_A_READ = Vmon_Load_value;//测量电压值
00036e  880a              LDRH     r2,[r1,#0]  ; Vmon_Load_value
000370  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;204    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000372  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000376  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
00037a  eb022203          ADD      r2,r2,r3,LSL #8
00037e  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.896|
;;;205    			}
;;;206    			if (UART_Buffer_Rece[1] == 0x04)			   //电压测量校准完成
000380  e000              B        |L3.900|
                  |L3.898|
000382  e3ea              B        |L3.2906|
                  |L3.900|
000384  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000388  2a04              CMP      r2,#4
00038a  d150              BNE      |L3.1070|
;;;207    			{
;;;208    				vu32 var16;
;;;209    				vu32 var32a;
;;;210    				vu32 var32b;
;;;211    				
;;;212    				vu32 var16a;
;;;213    				vu32 var32c;
;;;214    				vu32 var32d;
;;;215    				Modify_B_READ=0;
00038c  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;216    				Modify_B_ACT=0;
00038e  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;217    				Modify_B_READ =Vmon_Load_value;//测量电压值
000390  8809              LDRH     r1,[r1,#0]  ; Vmon_Load_value
000392  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;218    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000394  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000398  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
00039c  eb012102          ADD      r1,r1,r2,LSL #8
0003a0  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;219    				var32a = Modify_B_ACT;
0003a2  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;220    				var32a = var32a - Modify_A_ACT;
0003a4  9102              STR      r1,[sp,#8]
0003a6  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
0003a8  1a89              SUBS     r1,r1,r2
;;;221    				var32a = var32a << 12;
0003aa  0309              LSLS     r1,r1,#12
;;;222    				var16 = Modify_B_READ - Modify_A_READ;
0003ac  9102              STR      r1,[sp,#8]
0003ae  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
0003b0  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
0003b2  1a89              SUBS     r1,r1,r2
0003b4  9103              STR      r1,[sp,#0xc]
0003b6  e9dd1202          LDRD     r1,r2,[sp,#8]
;;;223    				var32a = var32a / var16;
0003ba  fbb1f1f2          UDIV     r1,r1,r2
;;;224    				CLists.CREG_Load_CorrectionV_HIG = var32a;
0003be  9102              STR      r1,[sp,#8]
0003c0  6041              STR      r1,[r0,#4]  ; CLists
;;;225    				var32a=0;
;;;226    				var32a = Modify_B_ACT;
0003c2  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;227    				var32a = var32a << 12;
0003c4  0309              LSLS     r1,r1,#12
;;;228    				var32b = Modify_B_READ;
0003c6  9102              STR      r1,[sp,#8]
0003c8  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;229    				var32b = var32b * CLists.CREG_Load_CorrectionV_HIG;      //内阻电压测量参数高档
0003ca  9101              STR      r1,[sp,#4]
0003cc  6841              LDR      r1,[r0,#4]  ; CLists
0003ce  9a01              LDR      r2,[sp,#4]
0003d0  4351              MULS     r1,r2,r1
0003d2  9101              STR      r1,[sp,#4]
0003d4  e9dd2101          LDRD     r2,r1,[sp,#4]
;;;230    				if (var32a < var32b)
0003d8  4291              CMP      r1,r2
0003da  d21b              BCS      |L3.1044|
;;;231    				{
;;;232    					var32b = var32b - var32a;
0003dc  4611              MOV      r1,r2
0003de  9a02              LDR      r2,[sp,#8]
0003e0  1a89              SUBS     r1,r1,r2
;;;233    					CLists.CREG_LoadV_Offset_HIG = var32b;     //内阻电压测量参数
0003e2  9101              STR      r1,[sp,#4]
0003e4  6481              STR      r1,[r0,#0x48]  ; CLists
;;;234    					CLists.CPolar0 |= 0x04;
0003e6  f8901088          LDRB     r1,[r0,#0x88]  ; CLists
0003ea  f0410104          ORR      r1,r1,#4
0003ee  e018              B        |L3.1058|
                  |L3.1008|
                          DCD      UART_Buffer_Rece
                  |L3.1012|
                          DCD      ||area_number.11||
                  |L3.1016|
                          DCD      UART_Buffer_Send
                  |L3.1020|
                          DCD      Transmit_BUFFERsize
                  |L3.1024|
                          DCD      flagA
                  |L3.1028|
                          DCD      ||area_number.7||
                  |L3.1032|
                          DCD      Vmon_Load_value
                  |L3.1036|
                          DCD      CLists
                  |L3.1040|
                          DCD      flagB
                  |L3.1044|
;;;235    				}
;;;236    				else 
;;;237    				{
;;;238    					var32a = var32a - var32b;
000414  1a89              SUBS     r1,r1,r2
;;;239    					CLists.CREG_LoadV_Offset_HIG = var32a;
000416  9102              STR      r1,[sp,#8]
000418  6481              STR      r1,[r0,#0x48]  ; CLists
;;;240    					CLists.CPolar0 &= ~0x04;
00041a  f8901088          LDRB     r1,[r0,#0x88]  ; CLists
00041e  f0210104          BIC      r1,r1,#4
                  |L3.1058|
000422  f8801088          STRB     r1,[r0,#0x88]
;;;241    				}			
;;;242    					//参数写进FLASH
;;;243    				Flag_DAC_OFF=0;
000426  6831              LDR      r1,[r6,#0]  ; flagB
000428  f0210108          BIC      r1,r1,#8
00042c  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1070|
;;;244    			}
;;;245    	     /*****************负载电流测量和控制校准*************************/
;;;246    			if (UART_Buffer_Rece[1] == 0x05)			   //CC模式校准
00042e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;247    			{
;;;248    				Modify_A_READ=0;
;;;249    				Modify_C_READ=0;
;;;250    				Modify_A_ACT=0;
;;;251    				Modify_A_READ = Imon_Load_value;//
000432  49fe              LDR      r1,|L3.2092|
;;;252    				Modify_C_READ = Contr_Laod;//
000434  4ffe              LDR      r7,|L3.2096|
000436  2a05              CMP      r2,#5                 ;246
000438  d10d              BNE      |L3.1110|
00043a  6065              STR      r5,[r4,#4]            ;248  ; Modify_A_READ
00043c  60a5              STR      r5,[r4,#8]            ;249  ; Modify_C_READ
00043e  60e5              STR      r5,[r4,#0xc]          ;250  ; Modify_A_ACT
000440  880a              LDRH     r2,[r1,#0]            ;251  ; Imon_Load_value
000442  6062              STR      r2,[r4,#4]            ;251  ; Modify_A_READ
000444  883a              LDRH     r2,[r7,#0]  ; Contr_Laod
000446  60a2              STR      r2,[r4,#8]  ; Modify_C_READ
;;;253    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000448  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
00044c  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000450  eb022203          ADD      r2,r2,r3,LSL #8
000454  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1110|
;;;254    			}
;;;255    			if (UART_Buffer_Rece[1] == 0x06)			   
000456  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
00045a  2a06              CMP      r2,#6
00045c  d172              BNE      |L3.1348|
;;;256    			{
;;;257    				vu32 var16;
;;;258    				vu32 var32a;
;;;259    				vu32 var32b;
;;;260    				
;;;261    				vu32 var16a;
;;;262    				vu32 var32c;
;;;263    				vu32 var32d;
;;;264    				Modify_B_READ=0;
00045e  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;265    				Modify_D_READ=0;
000460  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;266    				Modify_B_ACT=0;
000462  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;267    				
;;;268    				Modify_B_READ = Imon_Load_value;
000464  880a              LDRH     r2,[r1,#0]  ; Imon_Load_value
000466  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;269    				Modify_D_READ = Contr_Laod;
000468  883a              LDRH     r2,[r7,#0]  ; Contr_Laod
00046a  6162              STR      r2,[r4,#0x14]  ; Modify_D_READ
;;;270    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00046c  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000470  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000474  eb022203          ADD      r2,r2,r3,LSL #8
000478  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;271    				
;;;272    				var32a = Modify_B_ACT;
00047a  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;273    				var32a = var32a - Modify_A_ACT;
00047c  9202              STR      r2,[sp,#8]
00047e  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000480  1ad2              SUBS     r2,r2,r3
;;;274    				var32a = var32a << 12;
000482  0312              LSLS     r2,r2,#12
;;;275    				var16 = Modify_B_READ - Modify_A_READ;
000484  9202              STR      r2,[sp,#8]
000486  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
000488  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
00048a  1ad2              SUBS     r2,r2,r3
00048c  9203              STR      r2,[sp,#0xc]
00048e  e9dd2302          LDRD     r2,r3,[sp,#8]
;;;276    				var32a = var32a / var16;
000492  fbb2f2f3          UDIV     r2,r2,r3
;;;277    				CLists.CREG_Load_CorrectionA_LOW = var32a;
000496  9202              STR      r2,[sp,#8]
000498  6082              STR      r2,[r0,#8]  ; CLists
;;;278    				var32a = Modify_B_ACT;
00049a  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;279    				var32a = var32a << 12;
00049c  0312              LSLS     r2,r2,#12
;;;280    				var32b = Modify_B_READ;
00049e  9202              STR      r2,[sp,#8]
0004a0  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;281    				var32b = var32b * CLists.CREG_Load_CorrectionA_LOW;    //负载CC模式电流测量参数低档
0004a2  9201              STR      r2,[sp,#4]
0004a4  6882              LDR      r2,[r0,#8]  ; CLists
0004a6  9b01              LDR      r3,[sp,#4]
0004a8  435a              MULS     r2,r3,r2
0004aa  9201              STR      r2,[sp,#4]
0004ac  e9dd3201          LDRD     r3,r2,[sp,#4]
;;;282    				if (var32a < var32b)
0004b0  429a              CMP      r2,r3
0004b2  d209              BCS      |L3.1224|
;;;283    				{
;;;284    					var32b = var32b - var32a;
0004b4  461a              MOV      r2,r3
0004b6  9b02              LDR      r3,[sp,#8]
0004b8  1ad2              SUBS     r2,r2,r3
;;;285    					CLists.CREG_LoadA_Offset_LOW = var32b;     //负载CC模式电流测量参数
0004ba  9201              STR      r2,[sp,#4]
0004bc  64c2              STR      r2,[r0,#0x4c]  ; CLists
;;;286    					CLists.CPolar2 |= 0x01;
0004be  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
0004c2  f0420201          ORR      r2,r2,#1
0004c6  e006              B        |L3.1238|
                  |L3.1224|
;;;287    				}
;;;288    				else 
;;;289    				{
;;;290    					var32a = var32a - var32b;
0004c8  1ad2              SUBS     r2,r2,r3
;;;291    					CLists.CREG_LoadA_Offset_LOW = var32a;
0004ca  9202              STR      r2,[sp,#8]
0004cc  64c2              STR      r2,[r0,#0x4c]  ; CLists
;;;292    					CLists.CPolar2 &= ~0x01;					
0004ce  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
0004d2  f0220201          BIC      r2,r2,#1
                  |L3.1238|
0004d6  f880208a          STRB     r2,[r0,#0x8a]
;;;293    				}
;;;294    	//---------------------------------------------------------------------------------//
;;;295    				var32c = Modify_B_ACT; 
0004da  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;296    				var32c = var32c - Modify_A_ACT;
0004dc  9202              STR      r2,[sp,#8]
0004de  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
0004e0  1ad2              SUBS     r2,r2,r3
;;;297    				var32c = var32c << 12;
0004e2  0312              LSLS     r2,r2,#12
;;;298    				var16a=Modify_D_READ-Modify_C_READ;
0004e4  9202              STR      r2,[sp,#8]
0004e6  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
0004e8  68a3              LDR      r3,[r4,#8]  ; Modify_C_READ
0004ea  1ad2              SUBS     r2,r2,r3
;;;299    				var16a=var16a*2;
0004ec  0052              LSLS     r2,r2,#1
0004ee  9203              STR      r2,[sp,#0xc]
0004f0  e9dd2302          LDRD     r2,r3,[sp,#8]
;;;300    				var32c=var32c/var16a;
0004f4  fbb2f2f3          UDIV     r2,r2,r3
;;;301    				CLists.CSET_Load_CorrectionA_LOW = var32c;
0004f8  9202              STR      r2,[sp,#8]
0004fa  6182              STR      r2,[r0,#0x18]  ; CLists
;;;302    				var32c = Modify_B_ACT;
0004fc  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;303    				var32c = var32c << 12;
0004fe  0312              LSLS     r2,r2,#12
;;;304    				var32d = CLists.CSET_Load_CorrectionA_LOW;     //负载CC模式控制电流低档
000500  9202              STR      r2,[sp,#8]
000502  6982              LDR      r2,[r0,#0x18]  ; CLists
;;;305    				var32d = var32d * (Modify_D_READ*2);
000504  9201              STR      r2,[sp,#4]
000506  6963              LDR      r3,[r4,#0x14]  ; Modify_D_READ
000508  435a              MULS     r2,r3,r2
00050a  0052              LSLS     r2,r2,#1
00050c  9201              STR      r2,[sp,#4]
00050e  e9dd3201          LDRD     r3,r2,[sp,#4]
;;;306    				if (var32c < var32d)
000512  429a              CMP      r2,r3
000514  d209              BCS      |L3.1322|
;;;307    				{
;;;308    					var32d = var32d - var32c;
000516  461a              MOV      r2,r3
000518  9b02              LDR      r3,[sp,#8]
00051a  1ad2              SUBS     r2,r2,r3
;;;309    					CLists.CSET_LoadA_Offset_LOW = var32d;    //负载CC模式控制电流参数  	
00051c  9201              STR      r2,[sp,#4]
00051e  65c2              STR      r2,[r0,#0x5c]  ; CLists
;;;310    					CLists.CPolar2 |= 0x04;
000520  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
000524  f0420204          ORR      r2,r2,#4
000528  e006              B        |L3.1336|
                  |L3.1322|
;;;311    				}
;;;312    				else 
;;;313    				{
;;;314    					var32c = var32c - var32d;
00052a  1ad2              SUBS     r2,r2,r3
;;;315    					CLists.CSET_LoadA_Offset_LOW = var32c;
00052c  9202              STR      r2,[sp,#8]
00052e  65c2              STR      r2,[r0,#0x5c]  ; CLists
;;;316    					CLists.CPolar2 &= ~0x04;
000530  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
000534  f0220204          BIC      r2,r2,#4
                  |L3.1336|
000538  f880208a          STRB     r2,[r0,#0x8a]
;;;317    				}
;;;318    					
;;;319    				Flag_DAC_OFF =0;
00053c  6832              LDR      r2,[r6,#0]  ; flagB
00053e  f0220208          BIC      r2,r2,#8
000542  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.1348|
;;;320    			}
;;;321    			
;;;322    			/*****************负载高档电流测量和控制校准*************************/
;;;323    			if (UART_Buffer_Rece[1] == 0x07)			   //CC模式校准
000544  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000548  2a07              CMP      r2,#7
00054a  d10d              BNE      |L3.1384|
;;;324    			{
;;;325    				Modify_A_READ=0;
00054c  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;326    				Modify_C_READ=0;
00054e  60a5              STR      r5,[r4,#8]  ; Modify_C_READ
;;;327    				Modify_A_ACT=0;
000550  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;328    				Modify_A_READ = Imon_Load_value;//
000552  880a              LDRH     r2,[r1,#0]  ; Imon_Load_value
000554  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;329    				Modify_C_READ = Contr_Laod;//
000556  883a              LDRH     r2,[r7,#0]  ; Contr_Laod
000558  60a2              STR      r2,[r4,#8]  ; Modify_C_READ
;;;330    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00055a  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
00055e  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000562  eb022203          ADD      r2,r2,r3,LSL #8
000566  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1384|
;;;331    			}
;;;332    			if (UART_Buffer_Rece[1] == 0x08)			   
000568  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
00056c  2a08              CMP      r2,#8
00056e  d172              BNE      |L3.1622|
;;;333    			{
;;;334    				vu32 var16;
;;;335    				vu32 var32a;
;;;336    				vu32 var32b;
;;;337    				
;;;338    				vu32 var16a;
;;;339    				vu32 var32c;
;;;340    				vu32 var32d;
;;;341    				Modify_B_READ=0;
000570  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;342    				Modify_D_READ=0;
000572  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;343    				Modify_B_ACT=0;
000574  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;344    				
;;;345    				Modify_B_READ = Imon_Load_value;
000576  8809              LDRH     r1,[r1,#0]  ; Imon_Load_value
000578  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;346    				Modify_D_READ = Contr_Laod;
00057a  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
00057c  6161              STR      r1,[r4,#0x14]  ; Modify_D_READ
;;;347    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00057e  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000582  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000586  eb012102          ADD      r1,r1,r2,LSL #8
00058a  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;348    				
;;;349    				var32a = Modify_B_ACT;
00058c  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;350    				var32a = var32a - Modify_A_ACT;
00058e  9102              STR      r1,[sp,#8]
000590  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
000592  1a89              SUBS     r1,r1,r2
;;;351    				var32a = var32a << 12;
000594  0309              LSLS     r1,r1,#12
;;;352    				var16 = Modify_B_READ - Modify_A_READ;
000596  9102              STR      r1,[sp,#8]
000598  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
00059a  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
00059c  1a89              SUBS     r1,r1,r2
00059e  9103              STR      r1,[sp,#0xc]
0005a0  e9dd1202          LDRD     r1,r2,[sp,#8]
;;;353    				var32a = var32a / var16;
0005a4  fbb1f1f2          UDIV     r1,r1,r2
;;;354    				CLists.CREG_Load_CorrectionA_LOW = var32a;
0005a8  9102              STR      r1,[sp,#8]
0005aa  6081              STR      r1,[r0,#8]  ; CLists
;;;355    				var32a = Modify_B_ACT;
0005ac  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;356    				var32a = var32a << 12;
0005ae  0309              LSLS     r1,r1,#12
;;;357    				var32b = Modify_B_READ;
0005b0  9102              STR      r1,[sp,#8]
0005b2  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;358    				var32b = var32b * CLists.CREG_Load_CorrectionA_LOW;   //负载CC模式电流测量参数低档
0005b4  9101              STR      r1,[sp,#4]
0005b6  6881              LDR      r1,[r0,#8]  ; CLists
0005b8  9a01              LDR      r2,[sp,#4]
0005ba  4351              MULS     r1,r2,r1
0005bc  9101              STR      r1,[sp,#4]
0005be  e9dd2101          LDRD     r2,r1,[sp,#4]
;;;359    				if (var32a < var32b)
0005c2  4291              CMP      r1,r2
0005c4  d209              BCS      |L3.1498|
;;;360    				{
;;;361    					var32b = var32b - var32a;
0005c6  4611              MOV      r1,r2
0005c8  9a02              LDR      r2,[sp,#8]
0005ca  1a89              SUBS     r1,r1,r2
;;;362    					CLists.CREG_LoadA_Offset_HIG = var32b;     //负载CC模式电流测量参数
0005cc  9101              STR      r1,[sp,#4]
0005ce  6501              STR      r1,[r0,#0x50]  ; CLists
;;;363    					CLists.CPolar3 |= 0x01;
0005d0  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
0005d4  f0410101          ORR      r1,r1,#1
0005d8  e006              B        |L3.1512|
                  |L3.1498|
;;;364    				}
;;;365    				else 
;;;366    				{
;;;367    					var32a = var32a - var32b;
0005da  1a89              SUBS     r1,r1,r2
;;;368    					CLists.CREG_LoadA_Offset_HIG = var32a;
0005dc  9102              STR      r1,[sp,#8]
0005de  6501              STR      r1,[r0,#0x50]  ; CLists
;;;369    					CLists.CPolar3 &= ~0x01;					
0005e0  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
0005e4  f0210101          BIC      r1,r1,#1
                  |L3.1512|
0005e8  f880108b          STRB     r1,[r0,#0x8b]
;;;370    				}
;;;371    	//---------------------------------------------------------------------------------//
;;;372    				var32c = Modify_B_ACT; 
0005ec  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;373    				var32c = var32c - Modify_A_ACT;
0005ee  9102              STR      r1,[sp,#8]
0005f0  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
0005f2  1a89              SUBS     r1,r1,r2
;;;374    				var32c = var32c << 12;
0005f4  0309              LSLS     r1,r1,#12
;;;375    				var16a=Modify_D_READ-Modify_C_READ;
0005f6  9102              STR      r1,[sp,#8]
0005f8  6961              LDR      r1,[r4,#0x14]  ; Modify_D_READ
0005fa  68a2              LDR      r2,[r4,#8]  ; Modify_C_READ
0005fc  1a89              SUBS     r1,r1,r2
;;;376    				var16a=var16a*2;
0005fe  0049              LSLS     r1,r1,#1
000600  9103              STR      r1,[sp,#0xc]
000602  e9dd1202          LDRD     r1,r2,[sp,#8]
;;;377    				var32c=var32c/var16a;
000606  fbb1f1f2          UDIV     r1,r1,r2
;;;378    				CLists.CSET_Load_CorrectionA_HIG = var32c;
00060a  9102              STR      r1,[sp,#8]
00060c  61c1              STR      r1,[r0,#0x1c]  ; CLists
;;;379    				var32c = Modify_B_ACT;
00060e  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;380    				var32c = var32c << 12;
000610  0309              LSLS     r1,r1,#12
;;;381    				var32d = CLists.CSET_Load_CorrectionA_HIG;  //负载CC模式电流测量参数高档
000612  9102              STR      r1,[sp,#8]
000614  69c1              LDR      r1,[r0,#0x1c]  ; CLists
;;;382    				var32d = var32d * (Modify_D_READ*2);
000616  9101              STR      r1,[sp,#4]
000618  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
00061a  4351              MULS     r1,r2,r1
00061c  0049              LSLS     r1,r1,#1
00061e  9101              STR      r1,[sp,#4]
000620  e9dd2101          LDRD     r2,r1,[sp,#4]
;;;383    				if (var32c < var32d)
000624  4291              CMP      r1,r2
000626  d209              BCS      |L3.1596|
;;;384    				{
;;;385    					var32d = var32d - var32c;
000628  4611              MOV      r1,r2
00062a  9a02              LDR      r2,[sp,#8]
00062c  1a89              SUBS     r1,r1,r2
;;;386    					CLists.CSET_LoadA_Offset_HIG = var32d;   //负载CC模式控制电流参数
00062e  9101              STR      r1,[sp,#4]
000630  6601              STR      r1,[r0,#0x60]  ; CLists
;;;387    					CLists.CPolar3 |= 0x04;
000632  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
000636  f0410104          ORR      r1,r1,#4
00063a  e006              B        |L3.1610|
                  |L3.1596|
;;;388    				}
;;;389    				else 
;;;390    				{
;;;391    					var32c = var32c - var32d;
00063c  1a89              SUBS     r1,r1,r2
;;;392    					CLists.CSET_LoadA_Offset_HIG = var32c;
00063e  9102              STR      r1,[sp,#8]
000640  6601              STR      r1,[r0,#0x60]  ; CLists
;;;393    					CLists.CPolar3 &= ~0x04;
000642  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
000646  f0210104          BIC      r1,r1,#4
                  |L3.1610|
00064a  f880108b          STRB     r1,[r0,#0x8b]
;;;394    				}
;;;395    					
;;;396    				Flag_DAC_OFF =0;
00064e  6831              LDR      r1,[r6,#0]  ; flagB
000650  f0210108          BIC      r1,r1,#8
000654  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1622|
;;;397    			}
;;;398    	/*************************负载CV模式电压控制校准低档*******************************/
;;;399    			if(UART_Buffer_Rece[1] == 0x09)
000656  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
00065a  2909              CMP      r1,#9
00065c  d10b              BNE      |L3.1654|
;;;400    			{
;;;401    				Modify_A_READ=0;
00065e  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;402    				Modify_C_READ=0;
000660  60a5              STR      r5,[r4,#8]  ; Modify_C_READ
;;;403    				Modify_A_ACT=0;
000662  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;404    				Modify_C_READ = Contr_Laod;//设置电压值
000664  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
000666  60a1              STR      r1,[r4,#8]  ; Modify_C_READ
;;;405    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000668  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00066c  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000670  eb012102          ADD      r1,r1,r2,LSL #8
000674  60e1              STR      r1,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1654|
;;;406    			}
;;;407    			if (UART_Buffer_Rece[1] == 0x0A)			   //电压测量校准完成
000676  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
00067a  290a              CMP      r1,#0xa
00067c  d140              BNE      |L3.1792|
;;;408    			{
;;;409    				vu32 var16;
;;;410    				vu32 var32a;
;;;411    				vu32 var32b;
;;;412    				
;;;413    				vu32 var16a;
;;;414    				vu32 var32c;
;;;415    				vu32 var32d;
;;;416    				
;;;417    				Modify_B_READ=0;
00067e  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;418    				Modify_D_READ=0;
000680  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;419    				Modify_B_ACT=0;
000682  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;420    			
;;;421    				Modify_D_READ =Contr_Laod;//设置电压值
000684  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
000686  6161              STR      r1,[r4,#0x14]  ; Modify_D_READ
;;;422    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段	
000688  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00068c  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000690  eb012102          ADD      r1,r1,r2,LSL #8
000694  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;423    				var32c = Modify_B_ACT; //CV模式电压控制校准
000696  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;424    				var32c = var32c - Modify_A_ACT;
000698  9102              STR      r1,[sp,#8]
00069a  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
00069c  1a89              SUBS     r1,r1,r2
;;;425    				var32c = var32c << 12;
00069e  0309              LSLS     r1,r1,#12
;;;426    				var16a=Modify_D_READ-Modify_C_READ;
0006a0  9102              STR      r1,[sp,#8]
0006a2  6961              LDR      r1,[r4,#0x14]  ; Modify_D_READ
0006a4  68a2              LDR      r2,[r4,#8]  ; Modify_C_READ
0006a6  1a89              SUBS     r1,r1,r2
;;;427    				var16a=(var16a*2);
0006a8  0049              LSLS     r1,r1,#1
0006aa  9103              STR      r1,[sp,#0xc]
0006ac  e9dd1202          LDRD     r1,r2,[sp,#8]
;;;428    				var32c=var32c/var16a;
0006b0  fbb1f1f2          UDIV     r1,r1,r2
;;;429    				CLists.CSET_Load_CorrectionV_LOW = var32c;
0006b4  9102              STR      r1,[sp,#8]
0006b6  6101              STR      r1,[r0,#0x10]  ; CLists
;;;430    				var32c = Modify_B_ACT;
0006b8  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;431    				var32c = var32c << 12;
0006ba  0309              LSLS     r1,r1,#12
;;;432    				var32d = CLists.CSET_Load_CorrectionV_LOW;   //负载CV模式控制电压抵挡
0006bc  9102              STR      r1,[sp,#8]
0006be  6901              LDR      r1,[r0,#0x10]  ; CLists
;;;433    				var32d = var32d * (Modify_D_READ*2);
0006c0  9101              STR      r1,[sp,#4]
0006c2  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
0006c4  4351              MULS     r1,r2,r1
0006c6  0049              LSLS     r1,r1,#1
0006c8  9101              STR      r1,[sp,#4]
0006ca  e9dd2101          LDRD     r2,r1,[sp,#4]
;;;434    				if (var32c < var32d)
0006ce  4291              CMP      r1,r2
0006d0  d209              BCS      |L3.1766|
;;;435    				{
;;;436    					var32d = var32d - var32c;
0006d2  4611              MOV      r1,r2
0006d4  9a02              LDR      r2,[sp,#8]
0006d6  1a89              SUBS     r1,r1,r2
;;;437    					CLists.CSET_LoadV_Offset_LOW = var32d;    	//负载CV模式控制电压参数   
0006d8  9101              STR      r1,[sp,#4]
0006da  6541              STR      r1,[r0,#0x54]  ; CLists
;;;438    					CLists.CPolar1 |= 0x01;
0006dc  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
0006e0  f0410101          ORR      r1,r1,#1
0006e4  e006              B        |L3.1780|
                  |L3.1766|
;;;439    				}
;;;440    				else 
;;;441    				{
;;;442    					var32c = var32c - var32d;
0006e6  1a89              SUBS     r1,r1,r2
;;;443    					CLists.CSET_LoadV_Offset_LOW = var32c;
0006e8  9102              STR      r1,[sp,#8]
0006ea  6541              STR      r1,[r0,#0x54]  ; CLists
;;;444    					CLists.CPolar1 &= ~0x01;
0006ec  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
0006f0  f0210101          BIC      r1,r1,#1
                  |L3.1780|
0006f4  f8801089          STRB     r1,[r0,#0x89]
;;;445    				}
;;;446    					//参数写进FLASH
;;;447    				Flag_DAC_OFF=0;
0006f8  6831              LDR      r1,[r6,#0]  ; flagB
0006fa  f0210108          BIC      r1,r1,#8
0006fe  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1792|
;;;448    			}
;;;449    			/*************************负载CV模式电压控制校准高档*******************************/
;;;450    			if(UART_Buffer_Rece[1] == 0x0B)
000700  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
000704  290b              CMP      r1,#0xb
000706  d10b              BNE      |L3.1824|
;;;451    			{
;;;452    				Modify_A_READ=0;
000708  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;453    				Modify_C_READ=0;
00070a  60a5              STR      r5,[r4,#8]  ; Modify_C_READ
;;;454    				Modify_A_ACT=0;
00070c  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;455    				Modify_C_READ = Contr_Laod;//设置电压值
00070e  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
000710  60a1              STR      r1,[r4,#8]  ; Modify_C_READ
;;;456    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000712  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000716  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
00071a  eb012102          ADD      r1,r1,r2,LSL #8
00071e  60e1              STR      r1,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1824|
;;;457    			}
;;;458    			if (UART_Buffer_Rece[1] == 0x0C)			   //电压测量校准完成
000720  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
000724  290c              CMP      r1,#0xc
000726  d140              BNE      |L3.1962|
;;;459    			{
;;;460    				vu32 var16;
;;;461    				vu32 var32a;
;;;462    				vu32 var32b;
;;;463    				
;;;464    				vu32 var16a;
;;;465    				vu32 var32c;
;;;466    				vu32 var32d;
;;;467    				
;;;468    				Modify_B_READ=0;
000728  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;469    				Modify_D_READ=0;
00072a  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;470    				Modify_B_ACT=0;
00072c  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;471    			
;;;472    				Modify_D_READ =Contr_Laod;//设置电压值
00072e  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
000730  6161              STR      r1,[r4,#0x14]  ; Modify_D_READ
;;;473    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段	
000732  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000736  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
00073a  eb012102          ADD      r1,r1,r2,LSL #8
00073e  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;474    				var32c = Modify_B_ACT; //CV模式电压控制校准
000740  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;475    				var32c = var32c - Modify_A_ACT;
000742  9102              STR      r1,[sp,#8]
000744  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
000746  1a89              SUBS     r1,r1,r2
;;;476    				var32c = var32c << 12;
000748  0309              LSLS     r1,r1,#12
;;;477    				var16a=Modify_D_READ-Modify_C_READ;
00074a  9102              STR      r1,[sp,#8]
00074c  6961              LDR      r1,[r4,#0x14]  ; Modify_D_READ
00074e  68a2              LDR      r2,[r4,#8]  ; Modify_C_READ
000750  1a89              SUBS     r1,r1,r2
;;;478    				var16a=(var16a*2);
000752  0049              LSLS     r1,r1,#1
000754  9103              STR      r1,[sp,#0xc]
000756  e9dd1202          LDRD     r1,r2,[sp,#8]
;;;479    				var32c=var32c/var16a;
00075a  fbb1f1f2          UDIV     r1,r1,r2
;;;480    				CLists.CSET_Load_CorrectionV_LOW = var32c;
00075e  9102              STR      r1,[sp,#8]
000760  6101              STR      r1,[r0,#0x10]  ; CLists
;;;481    				var32c = Modify_B_ACT;
000762  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;482    				var32c = var32c << 12;
000764  0309              LSLS     r1,r1,#12
;;;483    				var32d = CLists.CSET_Load_CorrectionV_HIG;      //负载CV模式控制电压高档
000766  9102              STR      r1,[sp,#8]
000768  6941              LDR      r1,[r0,#0x14]  ; CLists
;;;484    				var32d = var32d * (Modify_D_READ*2);
00076a  9101              STR      r1,[sp,#4]
00076c  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
00076e  4351              MULS     r1,r2,r1
000770  0049              LSLS     r1,r1,#1
000772  9101              STR      r1,[sp,#4]
000774  e9dd2101          LDRD     r2,r1,[sp,#4]
;;;485    				if (var32c < var32d)
000778  4291              CMP      r1,r2
00077a  d209              BCS      |L3.1936|
;;;486    				{
;;;487    					var32d = var32d - var32c;
00077c  4611              MOV      r1,r2
00077e  9a02              LDR      r2,[sp,#8]
000780  1a89              SUBS     r1,r1,r2
;;;488    					CLists.CSET_LoadV_Offset_HIG = var32d;
000782  9101              STR      r1,[sp,#4]
000784  6581              STR      r1,[r0,#0x58]  ; CLists
;;;489    					CLists.CPolar1 |= 0x04;
000786  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
00078a  f0410104          ORR      r1,r1,#4
00078e  e006              B        |L3.1950|
                  |L3.1936|
;;;490    				}
;;;491    				else 
;;;492    				{
;;;493    					var32c = var32c - var32d;
000790  1a89              SUBS     r1,r1,r2
;;;494    					CLists.CSET_LoadV_Offset_HIG = var32c;      //负载CV模式控制电压参数
000792  9102              STR      r1,[sp,#8]
000794  6581              STR      r1,[r0,#0x58]  ; CLists
;;;495    					CLists.CPolar1 &= ~0x04;
000796  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
00079a  f0210104          BIC      r1,r1,#4
                  |L3.1950|
00079e  f8801089          STRB     r1,[r0,#0x89]
;;;496    				}
;;;497    					//参数写进FLASH
;;;498    				Flag_DAC_OFF=0;
0007a2  6831              LDR      r1,[r6,#0]  ; flagB
0007a4  f0210108          BIC      r1,r1,#8
0007a8  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1962|
;;;499    			}
;;;500    	/************************内阻校准低档**********************************/
;;;501    			if(UART_Buffer_Rece[1] == 0x0D)
0007aa  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;502    			{
;;;503    				Modify_A_READ=0;
;;;504    				Modify_A_ACT=0;
;;;505    				Modify_A_READ = Rmon_value;//测量电阻值
0007ae  4921              LDR      r1,|L3.2100|
0007b0  2a0d              CMP      r2,#0xd               ;501
0007b2  d10a              BNE      |L3.1994|
0007b4  6065              STR      r5,[r4,#4]            ;503  ; Modify_A_READ
0007b6  60e5              STR      r5,[r4,#0xc]          ;504  ; Modify_A_ACT
0007b8  880a              LDRH     r2,[r1,#0]  ; Rmon_value
0007ba  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;506    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0007bc  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
0007c0  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
0007c4  eb022203          ADD      r2,r2,r3,LSL #8
0007c8  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1994|
;;;507    			}
;;;508    			if (UART_Buffer_Rece[1] == 0x0E)			   
0007ca  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
0007ce  2a0e              CMP      r2,#0xe
0007d0  d147              BNE      |L3.2146|
;;;509    			{
;;;510    				vu16 var16;
;;;511    				vu32 var32a;
;;;512    				vu32 var32b;		
;;;513    				vu16 var16a;
;;;514    				vu32 var32c;
;;;515    				vu32 var32d;
;;;516    				Modify_B_READ=0;
0007d2  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;517    				Modify_B_ACT=0;
0007d4  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;518    				Modify_B_READ =Rmon_value;//测量电阻值
0007d6  880a              LDRH     r2,[r1,#0]  ; Rmon_value
0007d8  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;519    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
0007da  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
0007de  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
0007e2  eb022203          ADD      r2,r2,r3,LSL #8
0007e6  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;520    				var32a = Modify_B_ACT;
0007e8  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;521    				var32a = var32a - Modify_A_ACT;
0007ea  9202              STR      r2,[sp,#8]
0007ec  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
0007ee  1ad2              SUBS     r2,r2,r3
;;;522    				var32a = var32a << 12;
0007f0  0312              LSLS     r2,r2,#12
;;;523    				var16 = Modify_B_READ - Modify_A_READ;
0007f2  9202              STR      r2,[sp,#8]
0007f4  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
0007f6  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
0007f8  1ad2              SUBS     r2,r2,r3
0007fa  f8ad200c          STRH     r2,[sp,#0xc]
;;;524    				var32a = var32a / var16;
0007fe  f8bd300c          LDRH     r3,[sp,#0xc]
000802  9a02              LDR      r2,[sp,#8]
000804  fbb2f2f3          UDIV     r2,r2,r3
;;;525    				CLists.CREG_CorrectionR_LOW = var32a;
000808  9202              STR      r2,[sp,#8]
00080a  6342              STR      r2,[r0,#0x34]  ; CLists
;;;526    				var32a=0;
;;;527    				var32a = Modify_B_ACT;
00080c  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;528    				var32a = var32a << 12;
00080e  0312              LSLS     r2,r2,#12
;;;529    				var32b = Modify_B_READ;
000810  9202              STR      r2,[sp,#8]
000812  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;530    				var32b = var32b * CLists.CREG_CorrectionR_LOW;  //内阻测量参数低档
000814  9201              STR      r2,[sp,#4]
000816  6b42              LDR      r2,[r0,#0x34]  ; CLists
000818  9b01              LDR      r3,[sp,#4]
00081a  435a              MULS     r2,r3,r2
00081c  9201              STR      r2,[sp,#4]
00081e  e9dd3201          LDRD     r3,r2,[sp,#4]
;;;531    				if (var32a < var32b)
000822  429a              CMP      r2,r3
000824  d210              BCS      |L3.2120|
;;;532    				{
;;;533    					var32b = var32b - var32a;
000826  461a              MOV      r2,r3
000828  9b02              LDR      r3,[sp,#8]
00082a  e005              B        |L3.2104|
                  |L3.2092|
                          DCD      Imon_Load_value
                  |L3.2096|
                          DCD      Contr_Laod
                  |L3.2100|
                          DCD      Rmon_value
                  |L3.2104|
000838  1ad2              SUBS     r2,r2,r3
;;;534    					CLists.CREG_ReadR_Offset_LOW = var32b;         //内阻测量系数
00083a  9201              STR      r2,[sp,#4]
00083c  6782              STR      r2,[r0,#0x78]  ; CLists
;;;535    					CLists.CPolar4 |= 0x01;
00083e  f890208c          LDRB     r2,[r0,#0x8c]  ; CLists
000842  f0420201          ORR      r2,r2,#1
000846  e006              B        |L3.2134|
                  |L3.2120|
;;;536    				}
;;;537    				else 
;;;538    				{
;;;539    					var32a = var32a - var32b;
000848  1ad2              SUBS     r2,r2,r3
;;;540    					CLists.CREG_ReadR_Offset_LOW = var32a;
00084a  9202              STR      r2,[sp,#8]
00084c  6782              STR      r2,[r0,#0x78]  ; CLists
;;;541    					CLists.CPolar4 &= ~0x01;
00084e  f890208c          LDRB     r2,[r0,#0x8c]  ; CLists
000852  f0220201          BIC      r2,r2,#1
                  |L3.2134|
000856  f880208c          STRB     r2,[r0,#0x8c]
;;;542    				}
;;;543    					//参数写进FLASH
;;;544    				Flag_DAC_OFF=0;
00085a  6832              LDR      r2,[r6,#0]  ; flagB
00085c  f0220208          BIC      r2,r2,#8
000860  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2146|
;;;545    			}		
;;;546    			/************************内阻高档校准**********************************/
;;;547    			if(UART_Buffer_Rece[1] == 0x0F)
000862  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000866  2a0f              CMP      r2,#0xf
000868  d10a              BNE      |L3.2176|
;;;548    			{
;;;549    				Modify_A_READ=0;
00086a  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;550    				Modify_A_ACT=0;
00086c  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;551    				Modify_A_READ = Rmon_value;//测量电阻值
00086e  880a              LDRH     r2,[r1,#0]  ; Rmon_value
000870  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;552    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000872  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000876  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
00087a  eb022203          ADD      r2,r2,r3,LSL #8
00087e  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2176|
;;;553    			}
;;;554    			if (UART_Buffer_Rece[1] == 0x10)			   
000880  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000884  2a10              CMP      r2,#0x10
000886  d140              BNE      |L3.2314|
;;;555    			{
;;;556    				vu16 var16;
;;;557    				vu32 var32a;
;;;558    				vu32 var32b;		
;;;559    				vu16 var16a;
;;;560    				vu32 var32c;
;;;561    				vu32 var32d;
;;;562    				Modify_B_READ=0;
000888  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;563    				Modify_B_ACT=0;
00088a  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;564    				Modify_B_READ =Rmon_value;//测量电阻值
00088c  8809              LDRH     r1,[r1,#0]  ; Rmon_value
00088e  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;565    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000890  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000894  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000898  eb012102          ADD      r1,r1,r2,LSL #8
00089c  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;566    				var32a = Modify_B_ACT;
00089e  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;567    				var32a = var32a - Modify_A_ACT;
0008a0  9102              STR      r1,[sp,#8]
0008a2  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
0008a4  1a89              SUBS     r1,r1,r2
;;;568    				var32a = var32a << 12;
0008a6  0309              LSLS     r1,r1,#12
;;;569    				var16 = Modify_B_READ - Modify_A_READ;
0008a8  9102              STR      r1,[sp,#8]
0008aa  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
0008ac  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
0008ae  1a89              SUBS     r1,r1,r2
0008b0  f8ad100c          STRH     r1,[sp,#0xc]
;;;570    				var32a = var32a / var16;
0008b4  f8bd200c          LDRH     r2,[sp,#0xc]
0008b8  9902              LDR      r1,[sp,#8]
0008ba  fbb1f1f2          UDIV     r1,r1,r2
;;;571    				CLists.CREG_CorrectionR_HIG = var32a;
0008be  9102              STR      r1,[sp,#8]
0008c0  6381              STR      r1,[r0,#0x38]  ; CLists
;;;572    				var32a=0;
;;;573    				var32a = Modify_B_ACT;
0008c2  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;574    				var32a = var32a << 12;
0008c4  0309              LSLS     r1,r1,#12
;;;575    				var32b = Modify_B_READ;
0008c6  9102              STR      r1,[sp,#8]
0008c8  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;576    				var32b = var32b * CLists.CREG_CorrectionR_HIG;    //内阻测量参数高档
0008ca  9101              STR      r1,[sp,#4]
0008cc  6b81              LDR      r1,[r0,#0x38]  ; CLists
0008ce  9a01              LDR      r2,[sp,#4]
0008d0  4351              MULS     r1,r2,r1
0008d2  9101              STR      r1,[sp,#4]
0008d4  e9dd2101          LDRD     r2,r1,[sp,#4]
;;;577    				if (var32a < var32b)
0008d8  4291              CMP      r1,r2
0008da  d209              BCS      |L3.2288|
;;;578    				{
;;;579    					var32b = var32b - var32a;
0008dc  4611              MOV      r1,r2
0008de  9a02              LDR      r2,[sp,#8]
0008e0  1a89              SUBS     r1,r1,r2
;;;580    					CLists.CREG_ReadR_Offset_HIG = var32b;     //内阻测量系数
0008e2  9101              STR      r1,[sp,#4]
0008e4  67c1              STR      r1,[r0,#0x7c]  ; CLists
;;;581    					CLists.CPolar4 |= 0x04;
0008e6  f890108c          LDRB     r1,[r0,#0x8c]  ; CLists
0008ea  f0410104          ORR      r1,r1,#4
0008ee  e006              B        |L3.2302|
                  |L3.2288|
;;;582    				}
;;;583    				else 
;;;584    				{
;;;585    					var32a = var32a - var32b;
0008f0  1a89              SUBS     r1,r1,r2
;;;586    					CLists.CREG_ReadR_Offset_HIG = var32a;
0008f2  9102              STR      r1,[sp,#8]
0008f4  67c1              STR      r1,[r0,#0x7c]  ; CLists
;;;587    					CLists.CPolar4 &= ~0x04;
0008f6  f890108c          LDRB     r1,[r0,#0x8c]  ; CLists
0008fa  f0210104          BIC      r1,r1,#4
                  |L3.2302|
0008fe  f880108c          STRB     r1,[r0,#0x8c]
;;;588    				}
;;;589    					//参数写进FLASH
;;;590    				Flag_DAC_OFF=0;
000902  6831              LDR      r1,[r6,#0]  ; flagB
000904  f0210108          BIC      r1,r1,#8
000908  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.2314|
;;;591    			}	
;;;592    			
;;;593    			/*******************************电源电压控制和测量校准******************************************/	
;;;594    			if (UART_Buffer_Rece[1] == 0x11)			   //电流测量校准
00090a  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
;;;595    			{
;;;596    				Modify_A_READ=0;
;;;597    				Modify_C_READ=0;
;;;598    				Modify_A_ACT=0;
;;;599    				Modify_A_READ = Vmon_POWE_value;//测量电流
00090e  4bfe              LDR      r3,|L3.3336|
;;;600    				Modify_C_READ = Contr_Voltage;//设置电流
000910  f8dfa3f8          LDR      r10,|L3.3340|
000914  2911              CMP      r1,#0x11              ;594
000916  d10e              BNE      |L3.2358|
000918  6065              STR      r5,[r4,#4]            ;596  ; Modify_A_READ
00091a  60a5              STR      r5,[r4,#8]            ;597  ; Modify_C_READ
00091c  60e5              STR      r5,[r4,#0xc]          ;598  ; Modify_A_ACT
00091e  8819              LDRH     r1,[r3,#0]            ;599  ; Vmon_POWE_value
000920  6061              STR      r1,[r4,#4]            ;599  ; Modify_A_READ
000922  f8ba1000          LDRH     r1,[r10,#0]  ; Contr_Voltage
000926  60a1              STR      r1,[r4,#8]  ; Modify_C_READ
;;;601    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000928  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00092c  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000930  eb012102          ADD      r1,r1,r2,LSL #8
000934  60e1              STR      r1,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2358|
;;;602    			}
;;;603    
;;;604    			if (UART_Buffer_Rece[1] == 0x12)			   //电流测量校准完成
000936  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;605    			{
;;;606    				vu16 var16;
;;;607    				vu32 var32a;
;;;608    				vu32 var32b;
;;;609    				
;;;610    				vu16 var16a;
;;;611    				vu32 var32c;
;;;612    				vu32 var32d;
;;;613    				
;;;614    				Modify_D_READ=0;
;;;615    				Modify_B_READ=0;
;;;616    				Modify_B_ACT=0;
;;;617    				
;;;618    				Modify_D_READ = Contr_Voltage;
;;;619    				Modify_B_READ = Vmon_POWE_value;
;;;620    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
;;;621    				var32a = Modify_B_ACT;
;;;622    				var32a = var32a - Modify_A_ACT;
;;;623    				var32a = var32a << 12;
;;;624    				var16 = Modify_B_READ - Modify_A_READ;
;;;625    				var32a = var32a / var16;
;;;626    				CLists.CREG_POWER_CorrectionV = var32a;
;;;627    				var32a = Modify_B_ACT;
;;;628    				var32a = var32a << 12;
;;;629    				var32b = Modify_B_READ;
;;;630    				var32b = var32b * CLists.CREG_POWER_CorrectionV;    //电源测量电压参数
;;;631    				if (var32a < var32b)
;;;632    				{
;;;633    					var32b = var32b - var32a;
;;;634    					CLists.CREG_POWERV_Offset = var32b;     //电源CV模式电压测量参数  
;;;635    					CLists.CPolar5 |= 0x01;
;;;636    				}
;;;637    				else 
;;;638    				{
;;;639    					var32a = var32a - var32b;
;;;640    					CLists.CREG_POWERV_Offset = var32a;
;;;641    					CLists.CPolar5 &= ~0x01;					
;;;642    				}
;;;643    				var32c = Modify_B_ACT; //设置电压校准
;;;644    				var32c = var32c - Modify_A_ACT;
;;;645    				var32c = var32c << 12;
;;;646    				var16a=Modify_D_READ-Modify_C_READ;
;;;647    				var16a=var16a*2;
00093a  f64f71ff          MOV      r1,#0xffff
00093e  2a12              CMP      r2,#0x12              ;604
000940  d17d              BNE      |L3.2622|
000942  6165              STR      r5,[r4,#0x14]         ;614  ; Modify_D_READ
000944  6125              STR      r5,[r4,#0x10]         ;615  ; Modify_B_READ
000946  61a5              STR      r5,[r4,#0x18]         ;616  ; Modify_B_ACT
000948  f8ba2000          LDRH     r2,[r10,#0]           ;618  ; Contr_Voltage
00094c  6162              STR      r2,[r4,#0x14]         ;618  ; Modify_D_READ
00094e  881a              LDRH     r2,[r3,#0]            ;619  ; Vmon_POWE_value
000950  6122              STR      r2,[r4,#0x10]         ;619  ; Modify_B_READ
000952  f8982004          LDRB     r2,[r8,#4]            ;620  ; UART_Buffer_Rece
000956  f8983003          LDRB     r3,[r8,#3]            ;620  ; UART_Buffer_Rece
00095a  eb022203          ADD      r2,r2,r3,LSL #8       ;620
00095e  61a2              STR      r2,[r4,#0x18]         ;620  ; Modify_B_ACT
000960  69a2              LDR      r2,[r4,#0x18]         ;621  ; Modify_B_ACT
000962  9202              STR      r2,[sp,#8]            ;622
000964  68e3              LDR      r3,[r4,#0xc]          ;622  ; Modify_A_ACT
000966  1ad2              SUBS     r2,r2,r3              ;622
000968  0312              LSLS     r2,r2,#12             ;623
00096a  9202              STR      r2,[sp,#8]            ;624
00096c  6922              LDR      r2,[r4,#0x10]         ;624  ; Modify_B_READ
00096e  6863              LDR      r3,[r4,#4]            ;624  ; Modify_A_READ
000970  1ad2              SUBS     r2,r2,r3              ;624
000972  f8ad200c          STRH     r2,[sp,#0xc]          ;624
000976  f8bd300c          LDRH     r3,[sp,#0xc]          ;625
00097a  9a02              LDR      r2,[sp,#8]            ;625
00097c  fbb2f2f3          UDIV     r2,r2,r3              ;625
000980  9202              STR      r2,[sp,#8]            ;626
000982  6202              STR      r2,[r0,#0x20]         ;626  ; CLists
000984  69a2              LDR      r2,[r4,#0x18]         ;627  ; Modify_B_ACT
000986  0312              LSLS     r2,r2,#12             ;628
000988  9202              STR      r2,[sp,#8]            ;629
00098a  6922              LDR      r2,[r4,#0x10]         ;629  ; Modify_B_READ
00098c  9201              STR      r2,[sp,#4]            ;630
00098e  6a02              LDR      r2,[r0,#0x20]         ;630  ; CLists
000990  9b01              LDR      r3,[sp,#4]            ;630
000992  435a              MULS     r2,r3,r2              ;630
000994  9201              STR      r2,[sp,#4]            ;630
000996  e9dd3201          LDRD     r3,r2,[sp,#4]         ;630
00099a  429a              CMP      r2,r3                 ;631
00099c  d209              BCS      |L3.2482|
00099e  461a              MOV      r2,r3                 ;633
0009a0  9b02              LDR      r3,[sp,#8]            ;633
0009a2  1ad2              SUBS     r2,r2,r3              ;633
0009a4  9201              STR      r2,[sp,#4]            ;634
0009a6  6642              STR      r2,[r0,#0x64]         ;634  ; CLists
0009a8  f890208d          LDRB     r2,[r0,#0x8d]         ;635  ; CLists
0009ac  f0420201          ORR      r2,r2,#1              ;635
0009b0  e006              B        |L3.2496|
                  |L3.2482|
0009b2  1ad2              SUBS     r2,r2,r3              ;639
0009b4  9202              STR      r2,[sp,#8]            ;640
0009b6  6642              STR      r2,[r0,#0x64]         ;640  ; CLists
0009b8  f890208d          LDRB     r2,[r0,#0x8d]         ;641  ; CLists
0009bc  f0220201          BIC      r2,r2,#1              ;641
                  |L3.2496|
0009c0  f880208d          STRB     r2,[r0,#0x8d]         ;641
0009c4  69a2              LDR      r2,[r4,#0x18]         ;643  ; Modify_B_ACT
0009c6  9202              STR      r2,[sp,#8]            ;644
0009c8  68e3              LDR      r3,[r4,#0xc]          ;644  ; Modify_A_ACT
0009ca  1ad2              SUBS     r2,r2,r3              ;644
0009cc  0312              LSLS     r2,r2,#12             ;645
0009ce  9202              STR      r2,[sp,#8]            ;646
0009d0  6962              LDR      r2,[r4,#0x14]         ;646  ; Modify_D_READ
0009d2  68a3              LDR      r3,[r4,#8]            ;646  ; Modify_C_READ
0009d4  1ad2              SUBS     r2,r2,r3              ;646
0009d6  f8ad200c          STRH     r2,[sp,#0xc]          ;646
0009da  f8bd200c          LDRH     r2,[sp,#0xc]
0009de  ea010242          AND      r2,r1,r2,LSL #1
0009e2  f8ad200c          STRH     r2,[sp,#0xc]
;;;648    				var32c=var32c/var16a;
0009e6  f8bd300c          LDRH     r3,[sp,#0xc]
0009ea  9a02              LDR      r2,[sp,#8]
0009ec  fbb2f2f3          UDIV     r2,r2,r3
;;;649    				CLists.CSET_POWER_CorrectionV = var32c;
0009f0  9202              STR      r2,[sp,#8]
0009f2  62c2              STR      r2,[r0,#0x2c]  ; CLists
;;;650    				var32c = Modify_B_ACT;
0009f4  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;651    				var32c = var32c << 12;
0009f6  0312              LSLS     r2,r2,#12
;;;652    				var32d = CLists.CSET_POWER_CorrectionV;    //电源电压控制参数
0009f8  9202              STR      r2,[sp,#8]
0009fa  6ac2              LDR      r2,[r0,#0x2c]  ; CLists
;;;653    				var32d = var32d * (Modify_D_READ*2);
0009fc  9201              STR      r2,[sp,#4]
0009fe  6963              LDR      r3,[r4,#0x14]  ; Modify_D_READ
000a00  435a              MULS     r2,r3,r2
000a02  0052              LSLS     r2,r2,#1
000a04  9201              STR      r2,[sp,#4]
000a06  e9dd3201          LDRD     r3,r2,[sp,#4]
;;;654    				if (var32c < var32d)
000a0a  429a              CMP      r2,r3
000a0c  d20a              BCS      |L3.2596|
;;;655    				{
;;;656    					var32d = var32d - var32c;
000a0e  461a              MOV      r2,r3
000a10  9b02              LDR      r3,[sp,#8]
000a12  1ad2              SUBS     r2,r2,r3
;;;657    					CLists.CSET_POWERV_Offset = var32d;    //电源CV模式电压控制参数    
000a14  9201              STR      r2,[sp,#4]
000a16  6702              STR      r2,[r0,#0x70]  ; CLists
;;;658    					CLists.CPolar5 |= 0x04;
000a18  f890208d          LDRB     r2,[r0,#0x8d]  ; CLists
000a1c  f0420204          ORR      r2,r2,#4
000a20  e007              B        |L3.2610|
000a22  e00c              B        |L3.2622|
                  |L3.2596|
;;;659    				}
;;;660    				else 
;;;661    				{
;;;662    					var32c = var32c - var32d;
000a24  1ad2              SUBS     r2,r2,r3
;;;663    					CLists.CSET_POWERV_Offset = var32c;
000a26  9202              STR      r2,[sp,#8]
000a28  6702              STR      r2,[r0,#0x70]  ; CLists
;;;664    					CLists.CPolar5 &= ~0x04;
000a2a  f890208d          LDRB     r2,[r0,#0x8d]  ; CLists
000a2e  f0220204          BIC      r2,r2,#4
                  |L3.2610|
000a32  f880208d          STRB     r2,[r0,#0x8d]
;;;665    				}
;;;666    					
;;;667    				Flag_DAC_OFF=0;
000a36  6832              LDR      r2,[r6,#0]  ; flagB
000a38  f0220208          BIC      r2,r2,#8
000a3c  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2622|
;;;668    			}
;;;669    	/*******************************电源CC模式电流测量和控制校准******************************************/	
;;;670    			if (UART_Buffer_Rece[1] == 0x13)			   //电流测量校准
000a3e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;671    			{
;;;672    				Modify_A_READ=0;
;;;673    				Modify_C_READ=0;
;;;674    				Modify_A_ACT=0;
;;;675    				Modify_A_READ = Imon_POWE_value;//测量电流
;;;676    				Modify_C_READ = Contr_Current;//设置电流
000a42  f8df92cc          LDR      r9,|L3.3344|
000a46  f8dfc2cc          LDR      r12,|L3.3348|
000a4a  2a13              CMP      r2,#0x13              ;670
000a4c  d10f              BNE      |L3.2670|
000a4e  6065              STR      r5,[r4,#4]            ;672  ; Modify_A_READ
000a50  60a5              STR      r5,[r4,#8]            ;673  ; Modify_C_READ
000a52  60e5              STR      r5,[r4,#0xc]          ;674  ; Modify_A_ACT
000a54  f8bc2000          LDRH     r2,[r12,#0]           ;675  ; Imon_POWE_value
000a58  6062              STR      r2,[r4,#4]            ;675  ; Modify_A_READ
000a5a  f8b92000          LDRH     r2,[r9,#0]  ; Contr_Current
000a5e  60a2              STR      r2,[r4,#8]  ; Modify_C_READ
;;;677    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000a60  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000a64  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000a68  eb022203          ADD      r2,r2,r3,LSL #8
000a6c  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2670|
;;;678    			}
;;;679    			if (UART_Buffer_Rece[1] == 0x14)			   //电流测量校准完成
000a6e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000a72  2a14              CMP      r2,#0x14
000a74  d17f              BNE      |L3.2934|
;;;680    			{
;;;681    				vu16 var16;
;;;682    				vu32 var32a;
;;;683    				vu32 var32b;
;;;684    				
;;;685    				vu16 var16a;
;;;686    				vu32 var32c;
;;;687    				vu32 var32d;
;;;688    				
;;;689    				Modify_D_READ=0;
000a76  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;690    				Modify_B_READ=0;
000a78  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;691    				Modify_B_ACT=0;
000a7a  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;692    				
;;;693    				Modify_D_READ = Contr_Current;
000a7c  f8b92000          LDRH     r2,[r9,#0]  ; Contr_Current
000a80  6162              STR      r2,[r4,#0x14]  ; Modify_D_READ
;;;694    				Modify_B_READ = Imon_POWE_value;
000a82  f8bc2000          LDRH     r2,[r12,#0]  ; Imon_POWE_value
000a86  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;695    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000a88  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000a8c  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000a90  eb022203          ADD      r2,r2,r3,LSL #8
000a94  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;696    				var32a = Modify_B_ACT;
000a96  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;697    				var32a = var32a - Modify_A_ACT;
000a98  9202              STR      r2,[sp,#8]
000a9a  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000a9c  1ad2              SUBS     r2,r2,r3
;;;698    				var32a = var32a << 12;
000a9e  0312              LSLS     r2,r2,#12
;;;699    				var16 = Modify_B_READ - Modify_A_READ;
000aa0  9202              STR      r2,[sp,#8]
000aa2  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
000aa4  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
000aa6  1ad2              SUBS     r2,r2,r3
000aa8  f8ad200c          STRH     r2,[sp,#0xc]
;;;700    				var32a = var32a / var16;
000aac  f8bd300c          LDRH     r3,[sp,#0xc]
000ab0  9a02              LDR      r2,[sp,#8]
000ab2  fbb2f2f3          UDIV     r2,r2,r3
;;;701    				CLists.CREG_POWER_CorrectionA_CC = var32a;
000ab6  9202              STR      r2,[sp,#8]
000ab8  6242              STR      r2,[r0,#0x24]  ; CLists
;;;702    				var32a = Modify_B_ACT;
000aba  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;703    				var32a = var32a << 12;
000abc  0312              LSLS     r2,r2,#12
;;;704    				var32b = Modify_B_READ;
000abe  9202              STR      r2,[sp,#8]
000ac0  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;705    				var32b = var32b * CLists.CREG_POWER_CorrectionA_CC;    //电源CC模式电流测量参数
000ac2  9201              STR      r2,[sp,#4]
000ac4  6a42              LDR      r2,[r0,#0x24]  ; CLists
000ac6  9b01              LDR      r3,[sp,#4]
000ac8  435a              MULS     r2,r3,r2
000aca  9201              STR      r2,[sp,#4]
000acc  e9dd3201          LDRD     r3,r2,[sp,#4]
;;;706    				if (var32a < var32b)
000ad0  429a              CMP      r2,r3
000ad2  d209              BCS      |L3.2792|
;;;707    				{
;;;708    					var32b = var32b - var32a;
000ad4  461a              MOV      r2,r3
000ad6  9b02              LDR      r3,[sp,#8]
000ad8  1ad2              SUBS     r2,r2,r3
;;;709    					CLists.CREG_POWERA_Offset_CC = var32b;    //电源CC模式电流测量参数 
000ada  9201              STR      r2,[sp,#4]
000adc  6682              STR      r2,[r0,#0x68]  ; CLists
;;;710    					CLists.CPolar6 |= 0x01;
000ade  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000ae2  f0420201          ORR      r2,r2,#1
000ae6  e006              B        |L3.2806|
                  |L3.2792|
;;;711    				}
;;;712    				else 
;;;713    				{
;;;714    					var32a = var32a - var32b;
000ae8  1ad2              SUBS     r2,r2,r3
;;;715    					CLists.CREG_POWERA_Offset_CC = var32a;
000aea  9202              STR      r2,[sp,#8]
000aec  6682              STR      r2,[r0,#0x68]  ; CLists
;;;716    					CLists.CPolar6 &= ~0x01;					//电流测量系数和零点校准完成
000aee  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000af2  f0220201          BIC      r2,r2,#1
                  |L3.2806|
000af6  f880208e          STRB     r2,[r0,#0x8e]
;;;717    				}
;;;718    				var32c = Modify_B_ACT; //设置电流校准
000afa  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;719    				var32c = var32c - Modify_A_ACT;
000afc  9202              STR      r2,[sp,#8]
000afe  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000b00  1ad2              SUBS     r2,r2,r3
;;;720    				var32c = var32c << 12;
000b02  0312              LSLS     r2,r2,#12
;;;721    				var16a=Modify_D_READ-Modify_C_READ;
000b04  9202              STR      r2,[sp,#8]
000b06  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
000b08  68a3              LDR      r3,[r4,#8]  ; Modify_C_READ
000b0a  1ad2              SUBS     r2,r2,r3
000b0c  f8ad200c          STRH     r2,[sp,#0xc]
;;;722    				var16a=var16a*2;
000b10  f8bd200c          LDRH     r2,[sp,#0xc]
000b14  ea010242          AND      r2,r1,r2,LSL #1
000b18  f8ad200c          STRH     r2,[sp,#0xc]
;;;723    				var32c=var32c/var16a;
000b1c  f8bd300c          LDRH     r3,[sp,#0xc]
000b20  9a02              LDR      r2,[sp,#8]
000b22  fbb2f2f3          UDIV     r2,r2,r3
;;;724    				CLists.CSET_POWER_CorrectionA = var32c;
000b26  9202              STR      r2,[sp,#8]
000b28  6302              STR      r2,[r0,#0x30]  ; CLists
;;;725    				var32c = Modify_B_ACT;
000b2a  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;726    				var32c = var32c << 12;
000b2c  0312              LSLS     r2,r2,#12
;;;727    				var32d = CLists.CSET_POWER_CorrectionA;    //电源电流控制参数
000b2e  9202              STR      r2,[sp,#8]
000b30  6b02              LDR      r2,[r0,#0x30]  ; CLists
;;;728    				var32d = var32d * (Modify_D_READ*2);
000b32  9201              STR      r2,[sp,#4]
000b34  6963              LDR      r3,[r4,#0x14]  ; Modify_D_READ
000b36  435a              MULS     r2,r3,r2
000b38  0052              LSLS     r2,r2,#1
000b3a  9201              STR      r2,[sp,#4]
000b3c  e9dd3201          LDRD     r3,r2,[sp,#4]
;;;729    				if (var32c < var32d)
000b40  429a              CMP      r2,r3
000b42  d20b              BCS      |L3.2908|
;;;730    				{
;;;731    					var32d = var32d - var32c;
000b44  461a              MOV      r2,r3
000b46  9b02              LDR      r3,[sp,#8]
000b48  1ad2              SUBS     r2,r2,r3
;;;732    					CLists.CSET_POWERA_Offset = var32d;    //电源CC模式电流控制参数 
000b4a  9201              STR      r2,[sp,#4]
000b4c  6742              STR      r2,[r0,#0x74]  ; CLists
;;;733    					CLists.CPolar6 |= 0x04;
000b4e  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000b52  f0420204          ORR      r2,r2,#4
000b56  e008              B        |L3.2922|
000b58  e00d              B        |L3.2934|
                  |L3.2906|
000b5a  e156              B        |L3.3594|
                  |L3.2908|
;;;734    				}
;;;735    				else 
;;;736    				{
;;;737    					var32c = var32c - var32d;
000b5c  1ad2              SUBS     r2,r2,r3
;;;738    					CLists.CSET_POWERA_Offset = var32c;
000b5e  9202              STR      r2,[sp,#8]
000b60  6742              STR      r2,[r0,#0x74]  ; CLists
;;;739    					CLists.CPolar6 &= ~0x04;
000b62  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000b66  f0220204          BIC      r2,r2,#4
                  |L3.2922|
000b6a  f880208e          STRB     r2,[r0,#0x8e]
;;;740    				}
;;;741    				
;;;742    				Flag_DAC_OFF=0;
000b6e  6832              LDR      r2,[r6,#0]  ; flagB
000b70  f0220208          BIC      r2,r2,#8
000b74  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2934|
;;;743    			}
;;;744    	
;;;745    	/****************电源CV电流测量校准**********************************/
;;;746    			if (UART_Buffer_Rece[1] == 0x15)			  
000b76  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000b7a  2a15              CMP      r2,#0x15
000b7c  d10b              BNE      |L3.2966|
;;;747    			{ 
;;;748    				Modify_A_READ=0;
000b7e  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;749    				Modify_A_ACT=0;
000b80  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;750    				Modify_A_READ = Imon_POWE_value;
000b82  f8bc2000          LDRH     r2,[r12,#0]  ; Imon_POWE_value
000b86  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;751    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000b88  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000b8c  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000b90  eb022203          ADD      r2,r2,r3,LSL #8
000b94  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2966|
;;;752    			}
;;;753    
;;;754    			if (UART_Buffer_Rece[1] == 0x16)			   
000b96  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000b9a  2a16              CMP      r2,#0x16
000b9c  d141              BNE      |L3.3106|
;;;755    			{
;;;756    				vu16 var16;
;;;757    				vu32 var32a;
;;;758    				vu32 var32b;
;;;759    				
;;;760    				vu16 var16a;
;;;761    				vu32 var32c;
;;;762    				vu32 var32d;
;;;763    				
;;;764    				Modify_B_READ=0;
000b9e  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;765    				Modify_B_ACT=0;
000ba0  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;766    				Modify_B_READ = Imon_POWE_value;
000ba2  f8bc2000          LDRH     r2,[r12,#0]  ; Imon_POWE_value
000ba6  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;767    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000ba8  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000bac  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000bb0  eb022203          ADD      r2,r2,r3,LSL #8
000bb4  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;768    				var32a = Modify_B_ACT;
000bb6  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;769    				var32a = var32a - Modify_A_ACT;
000bb8  9202              STR      r2,[sp,#8]
000bba  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000bbc  1ad2              SUBS     r2,r2,r3
;;;770    				var32a = var32a << 12;
000bbe  0312              LSLS     r2,r2,#12
;;;771    				var16 = Modify_B_READ - Modify_A_READ;
000bc0  9202              STR      r2,[sp,#8]
000bc2  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
000bc4  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
000bc6  1ad2              SUBS     r2,r2,r3
000bc8  f8ad200c          STRH     r2,[sp,#0xc]
;;;772    				var32a = var32a / var16;
000bcc  f8bd300c          LDRH     r3,[sp,#0xc]
000bd0  9a02              LDR      r2,[sp,#8]
000bd2  fbb2f2f3          UDIV     r2,r2,r3
;;;773    				CLists.CREG_POWER_CorrectionA_CV = var32a;
000bd6  9202              STR      r2,[sp,#8]
000bd8  6282              STR      r2,[r0,#0x28]  ; CLists
;;;774    				var32a = Modify_B_ACT;
000bda  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;775    				var32a = var32a << 12;
000bdc  0312              LSLS     r2,r2,#12
;;;776    				var32b = Modify_B_READ;
000bde  9202              STR      r2,[sp,#8]
000be0  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;777    				var32b = var32b * CLists.CREG_POWER_CorrectionA_CV;   //电源CV模式电流测量参数
000be2  9201              STR      r2,[sp,#4]
000be4  6a82              LDR      r2,[r0,#0x28]  ; CLists
000be6  9b01              LDR      r3,[sp,#4]
000be8  435a              MULS     r2,r3,r2
000bea  9201              STR      r2,[sp,#4]
000bec  e9dd3201          LDRD     r3,r2,[sp,#4]
;;;778    				if (var32a < var32b)
000bf0  429a              CMP      r2,r3
000bf2  d209              BCS      |L3.3080|
;;;779    				{
;;;780    					var32b = var32b - var32a;
000bf4  461a              MOV      r2,r3
000bf6  9b02              LDR      r3,[sp,#8]
000bf8  1ad2              SUBS     r2,r2,r3
;;;781    					CLists.CREG_POWERA_Offset_CV = var32b;   //电源CC模式电流测量参数
000bfa  9201              STR      r2,[sp,#4]
000bfc  66c2              STR      r2,[r0,#0x6c]  ; CLists
;;;782    					CLists.CPolar6 |= 0x08;
000bfe  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000c02  f0420208          ORR      r2,r2,#8
000c06  e006              B        |L3.3094|
                  |L3.3080|
;;;783    				}
;;;784    				else 
;;;785    				{
;;;786    					var32a = var32a - var32b;
000c08  1ad2              SUBS     r2,r2,r3
;;;787    					CLists.CREG_POWERA_Offset_CV = var32a;
000c0a  9202              STR      r2,[sp,#8]
000c0c  66c2              STR      r2,[r0,#0x6c]  ; CLists
;;;788    					CLists.CPolar6 &= ~0x08;					
000c0e  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000c12  f0220208          BIC      r2,r2,#8
                  |L3.3094|
000c16  f880208e          STRB     r2,[r0,#0x8e]
;;;789    				}
;;;790    					
;;;791    				Flag_DAC_OFF=0;
000c1a  6832              LDR      r2,[r6,#0]  ; flagB
000c1c  f0220208          BIC      r2,r2,#8
000c20  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.3106|
;;;792    			}
;;;793    	/****************************识别电阻1校准*****************************************/
;;;794    			if(UART_Buffer_Rece[1] == 0x17)
000c22  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;795    			{
;;;796    				Modify_A_READ=0;
;;;797    				Modify_A_ACT=0;
;;;798    				//Modify_A_READ = R1mon_value;//测量电压值
;;;799    				Modify_A_READ=(R1mon_value*1000)/(65535-R1mon_value);
000c26  4b3c              LDR      r3,|L3.3352|
000c28  2a17              CMP      r2,#0x17              ;794
000c2a  d114              BNE      |L3.3158|
000c2c  6065              STR      r5,[r4,#4]            ;796  ; Modify_A_READ
000c2e  60e5              STR      r5,[r4,#0xc]          ;797  ; Modify_A_ACT
000c30  881a              LDRH     r2,[r3,#0]  ; R1mon_value
000c32  f44f7c7a          MOV      r12,#0x3e8
000c36  fb02f20c          MUL      r2,r2,r12
000c3a  f8b3c000          LDRH     r12,[r3,#0]  ; R1mon_value
000c3e  eba10c0c          SUB      r12,r1,r12
000c42  fbb2f2fc          UDIV     r2,r2,r12
000c46  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;800    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000c48  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000c4c  f898c003          LDRB     r12,[r8,#3]  ; UART_Buffer_Rece
000c50  eb02220c          ADD      r2,r2,r12,LSL #8
000c54  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.3158|
;;;801    			}
;;;802    			if (UART_Buffer_Rece[1] == 0x18)			   //电压测量校准完成
000c56  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000c5a  2a18              CMP      r2,#0x18
000c5c  d149              BNE      |L3.3314|
;;;803    			{
;;;804    				vu16 var16;
;;;805    				vu32 var32a;
;;;806    				vu32 var32b;
;;;807    				
;;;808    				vu16 var16a;
;;;809    				vu32 var32c;
;;;810    				vu32 var32d;
;;;811    				Modify_B_READ=0;
000c5e  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;812    				Modify_B_ACT=0;
000c60  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;813    				//Modify_B_READ =R1mon_value;//测量电压值
;;;814    				Modify_B_READ=(R1mon_value*1000)/(65535-R1mon_value);
000c62  881a              LDRH     r2,[r3,#0]  ; R1mon_value
000c64  f44f7c7a          MOV      r12,#0x3e8
000c68  881b              LDRH     r3,[r3,#0]  ; R1mon_value
000c6a  fb02f20c          MUL      r2,r2,r12
000c6e  1ac9              SUBS     r1,r1,r3
000c70  fbb2f1f1          UDIV     r1,r2,r1
000c74  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;815    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000c76  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000c7a  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000c7e  eb012102          ADD      r1,r1,r2,LSL #8
000c82  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;816    				var32a = Modify_B_ACT;
000c84  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;817    				var32a = var32a - Modify_A_ACT;
000c86  9102              STR      r1,[sp,#8]
000c88  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
000c8a  1a89              SUBS     r1,r1,r2
;;;818    				var32a = var32a << 12;
000c8c  0309              LSLS     r1,r1,#12
;;;819    				var16 = Modify_B_READ - Modify_A_READ;
000c8e  9102              STR      r1,[sp,#8]
000c90  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
000c92  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
000c94  1a89              SUBS     r1,r1,r2
000c96  f8ad100c          STRH     r1,[sp,#0xc]
;;;820    				var32a = var32a / var16;
000c9a  f8bd200c          LDRH     r2,[sp,#0xc]
000c9e  9902              LDR      r1,[sp,#8]
000ca0  fbb1f1f2          UDIV     r1,r1,r2
;;;821    				CLists.CREG_CorrectionR1 = var32a;     //识别电阻1参数
000ca4  9102              STR      r1,[sp,#8]
000ca6  63c1              STR      r1,[r0,#0x3c]  ; CLists
;;;822    				var32a=0;
;;;823    				var32a = Modify_B_ACT;
000ca8  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;824    				var32a = var32a << 12;
000caa  0309              LSLS     r1,r1,#12
;;;825    				var32b = Modify_B_READ;
000cac  9102              STR      r1,[sp,#8]
000cae  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;826    				var32b = var32b * CLists.CREG_CorrectionR1;
000cb0  9101              STR      r1,[sp,#4]
000cb2  6bc1              LDR      r1,[r0,#0x3c]  ; CLists
000cb4  9a01              LDR      r2,[sp,#4]
000cb6  4351              MULS     r1,r2,r1
;;;827    				if (var32a < var32b)
000cb8  9a02              LDR      r2,[sp,#8]
000cba  9101              STR      r1,[sp,#4]
000cbc  428a              CMP      r2,r1
000cbe  d208              BCS      |L3.3282|
;;;828    				{
;;;829    					var32b = var32b - var32a;
000cc0  1a89              SUBS     r1,r1,r2
;;;830    					CLists.CREG_ReadR1_Offset = var32b;    //内阻测量系数
000cc2  9101              STR      r1,[sp,#4]
000cc4  f8c01080          STR      r1,[r0,#0x80]  ; CLists
;;;831    					CLists.CPolar7 |= 0x01;
000cc8  f890108f          LDRB     r1,[r0,#0x8f]  ; CLists
000ccc  f0410101          ORR      r1,r1,#1
000cd0  e009              B        |L3.3302|
                  |L3.3282|
;;;832    				}
;;;833    				else 
;;;834    				{
;;;835    					var32a = var32a - var32b;
000cd2  4611              MOV      r1,r2
000cd4  9a01              LDR      r2,[sp,#4]
000cd6  1a89              SUBS     r1,r1,r2
;;;836    					CLists.CREG_ReadR1_Offset = var32a;
000cd8  9102              STR      r1,[sp,#8]
000cda  f8c01080          STR      r1,[r0,#0x80]  ; CLists
;;;837    					CLists.CPolar7 &= ~0x01;
000cde  f890108f          LDRB     r1,[r0,#0x8f]  ; CLists
000ce2  f0210101          BIC      r1,r1,#1
                  |L3.3302|
000ce6  f880108f          STRB     r1,[r0,#0x8f]
;;;838    				}
;;;839    					//参数写进FLASH
;;;840    				Flag_DAC_OFF=0;
000cea  6831              LDR      r1,[r6,#0]  ; flagB
000cec  f0210108          BIC      r1,r1,#8
000cf0  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.3314|
;;;841    			}	
;;;842    			/***************************识别电阻2校准**************************************/
;;;843    			if(UART_Buffer_Rece[1] == 0x19)
000cf2  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;844    			{
;;;845    				Modify_A_READ=0;
;;;846    				Modify_A_ACT=0;
;;;847    				Modify_A_READ = R2mon_value;//测量电压值
000cf6  4909              LDR      r1,|L3.3356|
000cf8  2a19              CMP      r2,#0x19              ;843
000cfa  d118              BNE      |L3.3374|
000cfc  6065              STR      r5,[r4,#4]            ;845  ; Modify_A_READ
000cfe  60e5              STR      r5,[r4,#0xc]          ;846  ; Modify_A_ACT
000d00  880a              LDRH     r2,[r1,#0]  ; R2mon_value
000d02  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;848    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000d04  e00c              B        |L3.3360|
000d06  0000              DCW      0x0000
                  |L3.3336|
                          DCD      Vmon_POWE_value
                  |L3.3340|
                          DCD      Contr_Voltage
                  |L3.3344|
                          DCD      Contr_Current
                  |L3.3348|
                          DCD      Imon_POWE_value
                  |L3.3352|
                          DCD      R1mon_value
                  |L3.3356|
                          DCD      R2mon_value
                  |L3.3360|
000d20  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000d24  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000d28  eb022203          ADD      r2,r2,r3,LSL #8
000d2c  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.3374|
;;;849    			}
;;;850    			if (UART_Buffer_Rece[1] == 0x1A)			   //电压测量校准完成
000d2e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000d32  2a1a              CMP      r2,#0x1a
000d34  d13f              BNE      |L3.3510|
;;;851    			{
;;;852    				vu16 var16;
;;;853    				vu32 var32a;
;;;854    				vu32 var32b;
;;;855    				
;;;856    				vu16 var16a;
;;;857    				vu32 var32c;
;;;858    				vu32 var32d;
;;;859    				Modify_B_READ=0;
000d36  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;860    				Modify_B_ACT=0;
000d38  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;861    				Modify_B_READ =R2mon_value;//测量电压值
000d3a  8809              LDRH     r1,[r1,#0]  ; R2mon_value
000d3c  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;862    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000d3e  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000d42  f8981003          LDRB     r1,[r8,#3]  ; UART_Buffer_Rece
000d46  eb022101          ADD      r1,r2,r1,LSL #8
000d4a  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;863    				var32a = Modify_B_ACT;
000d4c  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;864    				var32a = var32a - Modify_A_ACT;
000d4e  9102              STR      r1,[sp,#8]
000d50  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
000d52  1a89              SUBS     r1,r1,r2
;;;865    				var32a = var32a << 12;
000d54  0309              LSLS     r1,r1,#12
;;;866    				var16 = Modify_B_READ - Modify_A_READ;
000d56  9102              STR      r1,[sp,#8]
000d58  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
000d5a  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
000d5c  1a89              SUBS     r1,r1,r2
000d5e  f8ad100c          STRH     r1,[sp,#0xc]
;;;867    				var32a = var32a / var16;
000d62  f8bd200c          LDRH     r2,[sp,#0xc]
000d66  9902              LDR      r1,[sp,#8]
000d68  fbb1f1f2          UDIV     r1,r1,r2
;;;868    				CLists.CREG_CorrectionR2 = var32a;
000d6c  9102              STR      r1,[sp,#8]
000d6e  6401              STR      r1,[r0,#0x40]  ; CLists
;;;869    				var32a=0;
;;;870    				var32a = Modify_B_ACT;
000d70  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;871    				var32a = var32a << 12;
000d72  0309              LSLS     r1,r1,#12
;;;872    				var32b = Modify_B_READ;
000d74  9102              STR      r1,[sp,#8]
000d76  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;873    				var32b = var32b * CLists.CREG_CorrectionR2;    	//识别电阻2参数    
000d78  9101              STR      r1,[sp,#4]
000d7a  6c01              LDR      r1,[r0,#0x40]  ; CLists
000d7c  9a01              LDR      r2,[sp,#4]
000d7e  4351              MULS     r1,r2,r1
000d80  9101              STR      r1,[sp,#4]
000d82  e9dd2101          LDRD     r2,r1,[sp,#4]
;;;874    				if (var32a < var32b)
000d86  4291              CMP      r1,r2
000d88  d209              BCS      |L3.3486|
;;;875    				{
;;;876    					var32b = var32b - var32a;
000d8a  4611              MOV      r1,r2
000d8c  9a02              LDR      r2,[sp,#8]
000d8e  1a89              SUBS     r1,r1,r2
;;;877    					CLists.CREG_ReadR2_Offset = var32b;    //内阻测量系数  
000d90  9101              STR      r1,[sp,#4]
000d92  f8401f84          STR      r1,[r0,#0x84]!  ; CLists
;;;878    					CLists.CPolar7 |= 0x04;
000d96  7ac1              LDRB     r1,[r0,#0xb]  ; CLists
000d98  f0410104          ORR      r1,r1,#4
000d9c  e006              B        |L3.3500|
                  |L3.3486|
;;;879    				}
;;;880    				else 
;;;881    				{
;;;882    					var32a = var32a - var32b;
000d9e  1a89              SUBS     r1,r1,r2
;;;883    					CLists.CREG_ReadR2_Offset = var32a;
000da0  9102              STR      r1,[sp,#8]
000da2  f8401f84          STR      r1,[r0,#0x84]!  ; CLists
;;;884    					CLists.CPolar7 &= ~0x04;
000da6  7ac1              LDRB     r1,[r0,#0xb]  ; CLists
000da8  f0210104          BIC      r1,r1,#4
                  |L3.3500|
000dac  72c1              STRB     r1,[r0,#0xb]
;;;885    				}
;;;886    					//参数写进FLASH
;;;887    				Flag_DAC_OFF=0;
000dae  6830              LDR      r0,[r6,#0]  ; flagB
000db0  f0200008          BIC      r0,r0,#8
000db4  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.3510|
;;;888    			}	
;;;889    	
;;;890    			Write_Flash_Bytes();
000db6  f7fffffe          BL       Write_Flash_Bytes
;;;891    			
;;;892    	/***********接受DAC*******************************************/
;;;893    			if (UART_Buffer_Rece[1] == 0x1B)			   
000dba  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
000dbe  4640              MOV      r0,r8
000dc0  291b              CMP      r1,#0x1b
000dc2  d108              BNE      |L3.3542|
;;;894    			{
;;;895    				Contr_Laod = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000dc4  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000dc6  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
000dc8  eb012102          ADD      r1,r1,r2,LSL #8
000dcc  8039              STRH     r1,[r7,#0]
;;;896    				Flag_DAC_OFF=1;
000dce  6831              LDR      r1,[r6,#0]  ; flagB
000dd0  f0410108          ORR      r1,r1,#8
000dd4  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.3542|
;;;897    			}
;;;898    			if (UART_Buffer_Rece[1] == 0x1C)			   
000dd6  7841              LDRB     r1,[r0,#1]  ; UART_Buffer_Rece
000dd8  291c              CMP      r1,#0x1c
000dda  d109              BNE      |L3.3568|
;;;899    			{
;;;900    				Contr_Voltage = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000ddc  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000dde  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
000de0  eb012102          ADD      r1,r1,r2,LSL #8
000de4  f8aa1000          STRH     r1,[r10,#0]
;;;901    				Flag_DAC_OFF=1;
000de8  6831              LDR      r1,[r6,#0]  ; flagB
000dea  f0410108          ORR      r1,r1,#8
000dee  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.3568|
;;;902    			}
;;;903    			if (UART_Buffer_Rece[1] == 0x1D)			   
000df0  7841              LDRB     r1,[r0,#1]  ; UART_Buffer_Rece
000df2  291d              CMP      r1,#0x1d
000df4  d109              BNE      |L3.3594|
;;;904    			{
;;;905    				Contr_Current = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000df6  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000df8  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
000dfa  eb012100          ADD      r1,r1,r0,LSL #8
000dfe  f8a91000          STRH     r1,[r9,#0]
;;;906    				Flag_DAC_OFF=1;
000e02  6830              LDR      r0,[r6,#0]  ; flagB
000e04  f0400008          ORR      r0,r0,#8
000e08  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.3594|
;;;907    			}
;;;908    		}
;;;909    //===================================================================================
;;;910    	}
;;;911    }
000e0a  e8bd9fff          POP      {r0-r12,pc}
;;;912    //===============================AD值转换成测量值============================================//
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        68

                          AREA ||area_number.6||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.bss||
                  Correct_Strong
                          %        68

                          AREA ||area_number.7||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.bss||
                  Run_Control
                          %        68

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  ADDR
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  Modify_A_READ
                          DCD      0x00000000
                  Modify_C_READ
                          DCD      0x00000000
                  Modify_A_ACT
                          DCD      0x00000000
                  Modify_B_READ
                          DCD      0x00000000
                  Modify_D_READ
                          DCD      0x00000000
                  Modify_B_ACT
                          DCD      0x00000000

                          AREA ||area_number.12||, DATA, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.data||
                  correct_por
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 144
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
