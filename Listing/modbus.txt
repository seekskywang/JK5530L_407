; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\modbus.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=538 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\modbus.crf --no_multibyte_chars ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=2

                  Hardware_CRC PROC
;;;1352   //-----------------------------CRC检测--------------------------------------------//
;;;1353   vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b513              PUSH     {r0,r1,r4,lr}
;;;1354   {
000002  b082              SUB      sp,sp,#8
;;;1355   	vu16 CRC_Result=0xffff;
000004  f64f71ff          MOV      r1,#0xffff
000008  f8ad1000          STRH     r1,[sp,#0]
;;;1356   	vu8 i;
;;;1357   	if(count==0)
00000c  f89d100c          LDRB     r1,[sp,#0xc]
000010  b911              CBNZ     r1,|L1.24|
;;;1358   	{
;;;1359   		count=1;
000012  2101              MOVS     r1,#1
000014  f88d100c          STRB     r1,[sp,#0xc]
                  |L1.24|
000018  2400              MOVS     r4,#0
;;;1360   	}
;;;1361   	while(count--)
;;;1362   	{
;;;1363   		CRC_Result^=*p_buffer;
;;;1364   		for(i=0;i<8;i++)
;;;1365   		{
;;;1366   			if(CRC_Result&1)
;;;1367   			{
;;;1368   				CRC_Result>>=1;
;;;1369   				CRC_Result^=0xA001;
00001a  f24a0301          MOV      r3,#0xa001
00001e  bf00              NOP                            ;1361
                  |L1.32|
000020  f89d100c          LDRB     r1,[sp,#0xc]          ;1361
000024  1e4a              SUBS     r2,r1,#1              ;1361
000026  f88d200c          STRB     r2,[sp,#0xc]          ;1361
00002a  d323              BCC      |L1.116|
00002c  7801              LDRB     r1,[r0,#0]            ;1363
00002e  f8bd2000          LDRH     r2,[sp,#0]            ;1363
000032  4051              EORS     r1,r1,r2              ;1363
000034  f8ad1000          STRH     r1,[sp,#0]            ;1363
000038  f88d4004          STRB     r4,[sp,#4]            ;1364
00003c  e014              B        |L1.104|
00003e  bf00              NOP                            ;1366
                  |L1.64|
000040  f8bd1000          LDRH     r1,[sp,#0]            ;1366
000044  07c9              LSLS     r1,r1,#31             ;1366
;;;1370   			}
;;;1371   			else 
;;;1372   			{
;;;1373   				CRC_Result>>=1;
000046  f8bd1000          LDRH     r1,[sp,#0]
00004a  ea4f0151          LSR      r1,r1,#1
00004e  d004              BEQ      |L1.90|
000050  f8ad1000          STRH     r1,[sp,#0]            ;1368
000054  f8bd1000          LDRH     r1,[sp,#0]            ;1369
000058  4059              EORS     r1,r1,r3              ;1369
                  |L1.90|
00005a  f8ad1000          STRH     r1,[sp,#0]
00005e  f89d1004          LDRB     r1,[sp,#4]            ;1364
000062  1c49              ADDS     r1,r1,#1              ;1364
000064  f88d1004          STRB     r1,[sp,#4]            ;1364
                  |L1.104|
000068  f89d1004          LDRB     r1,[sp,#4]            ;1364
00006c  2908              CMP      r1,#8                 ;1364
00006e  d3e7              BCC      |L1.64|
000070  1c40              ADDS     r0,r0,#1              ;1364
;;;1374   			}
;;;1375   		}
;;;1376   		p_buffer++;
000072  e7d5              B        |L1.32|
                  |L1.116|
;;;1377   	}
;;;1378   	return CRC_Result;
000074  f8bd0000          LDRH     r0,[sp,#0]
;;;1379   }
000078  b004              ADD      sp,sp,#0x10
00007a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;912    //===============================AD值转换成测量值============================================//
;;;913    void Transformation_ADC(void)  
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;914    {
;;;915    	vu32 var32;
;;;916    	vu32 var32a;
;;;917    /*****************************负载测量电压转换******************************************/
;;;918    	if(LOAD_V_SW==0)//低档
000004  f8df83f4          LDR      r8,|L2.1020|
000008  f8d8401c          LDR      r4,[r8,#0x1c]  ; Run_Control
;;;919    	{
;;;920    		var32 = Vmon_Load_value;
00000c  4bfc              LDR      r3,|L2.1024|
;;;921    		var32 = var32 * CalPara.TestLV[0] + CalPara.OffsetLV[0];  
;;;922    //		if ((CLists.CPolar0 & 0x01) == 0x01)		  
;;;923    //		{
;;;924    //			if (var32 < CLists.CREG_LoadV_Offset_LOW) 
;;;925    //			{
;;;926    //				var32 = 0;
;;;927    //			}
;;;928    //			else var32 = var32 - CLists.CREG_LoadV_Offset_LOW;
;;;929    //		}
;;;930    //		else var32 = var32 + CLists.CREG_LoadV_Offset_LOW;
;;;931    //		var32 = var32 >> 12;
;;;932    		if (var32 < 30) var32 = 0;				  //40mV以下清零
;;;933    		Para.CVoltage = var32;
;;;934    //		DISS_Voltage=Para.CVoltage;
;;;935    		DISS_Voltage=(float)Para.CVoltage/1000;//计算显示电压
00000e  4dfd              LDR      r5,|L2.1028|
000010  ed9f0afd          VLDR     s0,|L2.1032|
000014  49fd              LDR      r1,|L2.1036|
000016  48fe              LDR      r0,|L2.1040|
;;;936    // 		if( DISS_Voltage >= 10 ){
;;;937    // 				CLists.CLOAD_V_SW  = 1;
;;;938    // 		}
;;;939    // 	//如果DISS_Voltage的值  >=10 CLists.CLOAD_V_SW  =1
;;;940    		var32 = 0;
;;;941    	}
;;;942    	else//高档
;;;943    	{
;;;944    		var32 = Vmon_Load_value;
000018  881b              LDRH     r3,[r3,#0]  ; Vmon_Load_value
00001a  2200              MOVS     r2,#0                 ;933
00001c  9300              STR      r3,[sp,#0]            ;914
00001e  b3e4              CBZ      r4,|L2.154|
;;;945    		var32 = var32 * CalPara.TestLV[1] + CalPara.OffsetLV[1]; 
000020  ee013a10          VMOV     s2,r3
000024  edd10a05          VLDR     s1,[r1,#0x14]
000028  edd11a01          VLDR     s3,[r1,#4]
00002c  eeb81a41          VCVT.F32.U32 s2,s2
000030  ee410a21          VMLA.F32 s1,s2,s3
000034  eefc0ae0          VCVT.U32.F32 s1,s1
;;;946    //		if ((CLists.CPolar0 & 0x04) == 0x04)		  
;;;947    //		{
;;;948    //			if (var32 < CLists.CREG_LoadV_Offset_HIG) 
;;;949    //			{
;;;950    //				var32 = 0;
;;;951    //			}
;;;952    //			else var32 = var32 - CLists.CREG_LoadV_Offset_HIG;
;;;953    //		}
;;;954    //		else var32 = var32 + CLists.CREG_LoadV_Offset_HIG;
;;;955    //		var32 = var32 >> 12;
;;;956    		if (var32 < 10) var32 = 0;				  //40mV以下清零
000038  ee103a90          VMOV     r3,s1
00003c  edcd0a00          VSTR     s1,[sp,#0]            ;945
000040  2b0a              CMP      r3,#0xa
000042  d200              BCS      |L2.70|
000044  9200              STR      r2,[sp,#0]
                  |L2.70|
;;;957    		Para.CVoltage = var32*10;
000046  9b00              LDR      r3,[sp,#0]
000048  eb030383          ADD      r3,r3,r3,LSL #2
00004c  005b              LSLS     r3,r3,#1
                  |L2.78|
00004e  62c3              STR      r3,[r0,#0x2c]  ; Para
;;;958    //		DISS_Voltage=Para.CVoltage;
;;;959    		DISS_Voltage=(float)Para.CVoltage/1000;//计算显示电压
000050  6ac3              LDR      r3,[r0,#0x2c]  ; Para
000052  ee003a90          VMOV     s1,r3
000056  eef80a60          VCVT.F32.U32 s1,s1
00005a  ee801a80          VDIV.F32 s2,s1,s0
00005e  ed851a00          VSTR     s2,[r5,#0]
;;;960    // 		if( DISS_Voltage < 12 ){
;;;961    // 				CLists.CLOAD_V_SW  = 0;
;;;962    // 		}
;;;963       //如果DISS_Voltage的值  <12  CLists.CLOAD_V_SW  = 0
;;;964    		var32 = 0;
;;;965    	}
;;;966    	
;;;967    	/*******************负载测量电流转换**************************************/
;;;968    	if(LOAD_I_SW==0)//低档
000062  9200              STR      r2,[sp,#0]
000064  f8d87020          LDR      r7,[r8,#0x20]  ; Run_Control
;;;969    	{
;;;970    		var32 = Imon_Load_value;
000068  4bec              LDR      r3,|L2.1052|
00006a  2f00              CMP      r7,#0                 ;968
;;;971    		var32 = var32 * CalPara.TestLC[0] + CalPara.OffsetTestLC[0];  
;;;972    //		if ((CLists.CPolar2 & 0x01) == 0x01)		  
;;;973    //		{
;;;974    //			if (var32 < CLists.CREG_LoadA_Offset_LOW) 
;;;975    //			{
;;;976    //				var32 = 0;
;;;977    //			}
;;;978    //			else var32 = var32 - CLists.CREG_LoadA_Offset_LOW;
;;;979    //		}
;;;980    //		else var32 = var32 + CLists.CREG_LoadA_Offset_LOW;
;;;981    //		var32 = var32 >> 12;
;;;982    		Para.CLaod_Current = var32;
;;;983    		if(Para.CSET_Current_Laod >= 5000)
;;;984    		{
;;;985    			var32 = Imon_Load_value;
;;;986    			var32 = var32 * CalPara.TestLC[1] + CalPara.OffsetTestLC[1];
;;;987    			Para.CLaod_Current = var32;
;;;988    		}
;;;989    		if(mainswitch == 0 && lockflag ==0)
00006c  f8df93a4          LDR      r9,|L2.1044|
;;;990    			Para.CLaod_Current=0;
;;;991    //		DISS_Current=Para.CLaod_Current;
;;;992    		DISS_Current=(float)Para.CLaod_Current/1000;//计算显示电流
000070  f8dfa3a4          LDR      r10,|L2.1048|
000074  4cea              LDR      r4,|L2.1056|
;;;993    		var32 = 0;	
;;;994    	}
;;;995    	
;;;996    	else//高档
;;;997    	{
;;;998    		var32 = Imon_Load_value;
000076  881f              LDRH     r7,[r3,#0]  ; Imon_Load_value
000078  f2413b88          MOV      r11,#0x1388           ;983
;;;999    		var32 = var32 * CalPara.TestLC[2] + CalPara.OffsetTestLC[2];   
;;;1000   //		if ((CLists.CPolar4 & 0x01) == 0x01)		  
;;;1001   //		{
;;;1002   //			if (var32 < CLists.CREG_LoadA_Offset_HIG) 
;;;1003   //			{
;;;1004   //				var32 = 0;
;;;1005   //			}
;;;1006   //			else var32 = var32 - CLists.CREG_LoadA_Offset_HIG;
;;;1007   //		}
;;;1008   //		else var32 = var32 + CLists.CREG_LoadA_Offset_HIG;
;;;1009   //		var32 = var32 >> 12;
;;;1010   		Para.CLaod_Current = var32;
;;;1011   		if(Para.CLaod_Current < 1000)
00007c  f44f7e7a          MOV      lr,#0x3e8
;;;1012   		{
;;;1013   			Para.CLaod_Current = 0;
;;;1014   		}
;;;1015   		if(Para.CSET_Current_Laod >= 30000)
;;;1016   		{
;;;1017   			var32 = Imon_Load_value;
;;;1018   			var32 = var32 * CalPara.TestLC[3] + CalPara.OffsetTestLC[3];
;;;1019   			Para.CLaod_Current = var32;
;;;1020   		}
;;;1021   		if(Para.CSET_Current_Laod >= 50000)
000080  f24c3650          MOV      r6,#0xc350
000084  9700              STR      r7,[sp,#0]            ;998
000086  d047              BEQ      |L2.280|
000088  ee017a10          VMOV     s2,r7                 ;999
00008c  edd10a1f          VLDR     s1,[r1,#0x7c]         ;999
000090  edd11a11          VLDR     s3,[r1,#0x44]         ;999
000094  eeb81a41          VCVT.F32.U32 s2,s2                 ;999
000098  e000              B        |L2.156|
                  |L2.154|
00009a  e028              B        |L2.238|
                  |L2.156|
00009c  ee410a21          VMLA.F32 s1,s2,s3              ;999
0000a0  eefc0ae0          VCVT.U32.F32 s1,s1                 ;999
0000a4  ee107a90          VMOV     r7,s1                 ;1010
0000a8  edcd0a00          VSTR     s1,[sp,#0]            ;999
0000ac  6347              STR      r7,[r0,#0x34]         ;1010  ; Para
0000ae  6b47              LDR      r7,[r0,#0x34]         ;1011  ; Para
0000b0  4577              CMP      r7,lr                 ;1011
0000b2  d200              BCS      |L2.182|
0000b4  6342              STR      r2,[r0,#0x34]         ;1013  ; Para
                  |L2.182|
0000b6  6947              LDR      r7,[r0,#0x14]         ;1015  ; Para
0000b8  f2475c30          MOV      r12,#0x7530           ;1015
0000bc  4567              CMP      r7,r12                ;1015
0000be  d312              BCC      |L2.230|
0000c0  881f              LDRH     r7,[r3,#0]            ;1017  ; Imon_Load_value
0000c2  9700              STR      r7,[sp,#0]            ;1018
0000c4  ee017a10          VMOV     s2,r7                 ;1018
0000c8  edd10a20          VLDR     s1,[r1,#0x80]         ;1018
0000cc  edd11a12          VLDR     s3,[r1,#0x48]         ;1018
0000d0  eeb81a41          VCVT.F32.U32 s2,s2                 ;1018
0000d4  ee410a21          VMLA.F32 s1,s2,s3              ;1018
0000d8  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1018
0000dc  ee107a90          VMOV     r7,s1                 ;1019
0000e0  edcd0a00          VSTR     s1,[sp,#0]            ;1018
0000e4  6347              STR      r7,[r0,#0x34]         ;1019  ; Para
                  |L2.230|
0000e6  6947              LDR      r7,[r0,#0x14]  ; Para
0000e8  42b7              CMP      r7,r6
0000ea  d256              BCS      |L2.410|
0000ec  e038              B        |L2.352|
                  |L2.238|
0000ee  ee013a10          VMOV     s2,r3                 ;921
0000f2  edd10a04          VLDR     s1,[r1,#0x10]         ;921
0000f6  edd11a00          VLDR     s3,[r1,#0]            ;921
0000fa  eeb81a41          VCVT.F32.U32 s2,s2                 ;921
0000fe  ee410a21          VMLA.F32 s1,s2,s3              ;921
000102  eefc0ae0          VCVT.U32.F32 s1,s1                 ;921
000106  ee103a90          VMOV     r3,s1                 ;932
00010a  edcd0a00          VSTR     s1,[sp,#0]            ;921
00010e  2b1e              CMP      r3,#0x1e              ;932
000110  d200              BCS      |L2.276|
000112  9200              STR      r2,[sp,#0]            ;932
                  |L2.276|
000114  9b00              LDR      r3,[sp,#0]            ;940
000116  e79a              B        |L2.78|
                  |L2.280|
000118  ee017a10          VMOV     s2,r7                 ;971
00011c  edd10a1d          VLDR     s1,[r1,#0x74]         ;971
000120  edd11a0f          VLDR     s3,[r1,#0x3c]         ;971
000124  eeb81a41          VCVT.F32.U32 s2,s2                 ;971
000128  ee410a21          VMLA.F32 s1,s2,s3              ;971
00012c  eefc0ae0          VCVT.U32.F32 s1,s1                 ;971
000130  ee107a90          VMOV     r7,s1                 ;982
000134  edcd0a00          VSTR     s1,[sp,#0]            ;971
000138  6347              STR      r7,[r0,#0x34]         ;982  ; Para
00013a  f8d0c014          LDR      r12,[r0,#0x14]        ;983  ; Para
00013e  45dc              CMP      r12,r11               ;983
000140  d30e              BCC      |L2.352|
000142  881b              LDRH     r3,[r3,#0]            ;985  ; Imon_Load_value
000144  9300              STR      r3,[sp,#0]            ;986
000146  ee003a90          VMOV     s1,r3                 ;986
00014a  ed911a1e          VLDR     s2,[r1,#0x78]         ;986
00014e  edd11a10          VLDR     s3,[r1,#0x40]         ;986
000152  eef80a60          VCVT.F32.U32 s1,s1                 ;986
000156  ee001aa1          VMLA.F32 s2,s1,s3              ;986
00015a  eefc0ac1          VCVT.U32.F32 s1,s2                 ;986
00015e  e02a              B        |L2.438|
                  |L2.352|
000160  7823              LDRB     r3,[r4,#0]            ;989  ; mainswitch
000162  b91b              CBNZ     r3,|L2.364|
000164  f8993000          LDRB     r3,[r9,#0]            ;989  ; lockflag
000168  b903              CBNZ     r3,|L2.364|
00016a  6342              STR      r2,[r0,#0x34]         ;990  ; Para
                  |L2.364|
;;;1022   		{
;;;1023   			var32 = Imon_Load_value;
;;;1024   			var32 = var32 * CalPara.TestLC[4] + CalPara.OffsetTestLC[4];
;;;1025   			Para.CLaod_Current = var32;
;;;1026   		}
;;;1027   		if(mainswitch == 0 && lockflag ==0)
;;;1028   			Para.CLaod_Current=0;
;;;1029   //		DISS_Current=Para.CLaod_Current;
;;;1030   		DISS_Current=(float)Para.CLaod_Current/1000;//计算显示电流
00016c  6b43              LDR      r3,[r0,#0x34]  ; Para
00016e  ee003a90          VMOV     s1,r3
000172  eef80a60          VCVT.F32.U32 s1,s1
000176  ee801a80          VDIV.F32 s2,s1,s0
00017a  ed8a1a00          VSTR     s2,[r10,#0]
;;;1031   		var32 = 0;
;;;1032   	}
;;;1033   	
;;;1034   	/*************************负载电压和电流控制 转换**************************************/
;;;1035   	if(LOAD_MODE==0 || LOAD_MODE == 2)//CC
00017e  9200              STR      r2,[sp,#0]
000180  f8d87018          LDR      r7,[r8,#0x18]  ; Run_Control
;;;1036   	{
;;;1037   		if(LOAD_MODE == 2)
;;;1038   		{
;;;1039   			Para.CSET_Current_Laod = (uint32_t)((((float)Para.LOAD_P/1000)/DISS_Voltage)*1000);
;;;1040   			if(Para.CSET_Current_Laod > 15000)
;;;1041   			{
;;;1042   				LOAD_I_SW = 1;
;;;1043   			}else{
;;;1044   				LOAD_I_SW = 0;
;;;1045   			}
;;;1046   		}
;;;1047   		if(LOAD_I_SW==0)//低档
;;;1048   		{
;;;1049   			var32 = Para.CSET_Current_Laod;
;;;1050   			if(Para.CSET_Current_Laod < 5000)
;;;1051   			{
;;;1052   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[0] + CalPara.OffsetLC[0];
;;;1053   			}else{
;;;1054   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[1] + CalPara.OffsetLC[1];
;;;1055   			}
;;;1056   //			var32=var32<<12;   
;;;1057   //			if ((CLists.CPolar2 & 0x04) == 0)			   
;;;1058   //			{
;;;1059   //				if (var32 < CLists.CSET_LoadA_Offset_LOW) var32 = 0;
;;;1060   //				else var32 = var32 - CLists.CSET_LoadA_Offset_LOW;
;;;1061   //			}
;;;1062   //			else var32 = var32 + CLists.CSET_LoadA_Offset_LOW;
;;;1063   //			var32 = var32/CLists.CSET_Load_CorrectionA_LOW;
;;;1064   //			var32=var32>>1;
;;;1065   			Contr_Laod = var32;
000184  4ba7              LDR      r3,|L2.1060|
000186  b1e7              CBZ      r7,|L2.450|
000188  f8d87018          LDR      r7,[r8,#0x18]         ;1035  ; Run_Control
00018c  2f02              CMP      r7,#2                 ;1035
00018e  d018              BEQ      |L2.450|
;;;1066   			if(Para.CSET_Current_Laod==0 || mainswitch == 0)
;;;1067   			{
;;;1068   				Contr_Laod=0;
;;;1069   			}
;;;1070   			var32 = 0;
;;;1071   		}
;;;1072   		else//高档
;;;1073   		{
;;;1074   			var32 = Para.CSET_Current_Laod;
;;;1075   			if(Para.CSET_Current_Laod < 20000)
;;;1076   			{
;;;1077   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[2] + CalPara.OffsetLC[2];  
;;;1078   			}else if(Para.CSET_Current_Laod >= 20000 && Para.CSET_Current_Laod < 50000){
;;;1079   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[3] + CalPara.OffsetLC[3];  
;;;1080   			}else if(Para.CSET_Current_Laod >= 50000){
;;;1081   				var32 = Para.CSET_Current_Laod * CalPara.SetLC[4] + CalPara.OffsetLC[4];  
;;;1082   			}
;;;1083   //			if ((CLists.CPolar3 & 0x04) == 0)			   
;;;1084   //			{
;;;1085   //				if (var32 < CLists.CSET_LoadA_Offset_HIG) var32 = 0;
;;;1086   //				else var32 = var32 - CLists.CSET_LoadA_Offset_HIG;
;;;1087   //			}
;;;1088   //			else var32 = var32 + CLists.CSET_LoadA_Offset_HIG;
;;;1089   //			var32 = var32/CLists.CSET_Load_CorrectionA_HIG;
;;;1090   //			var32=var32>>1;
;;;1091   			Contr_Laod = var32;
;;;1092   			if(Para.CSET_Current_Laod==0 || mainswitch == 0)
;;;1093   			{
;;;1094   				Contr_Laod=0;
;;;1095   			}
;;;1096   			var32 = 0;
;;;1097   		}
;;;1098   		
;;;1099   	}
;;;1100   	else if(LOAD_MODE==1)//CV
000190  f8d85018          LDR      r5,[r8,#0x18]  ; Run_Control
000194  2d01              CMP      r5,#1
000196  d079              BEQ      |L2.652|
000198  e0ad              B        |L2.758|
                  |L2.410|
00019a  881b              LDRH     r3,[r3,#0]            ;1023  ; Imon_Load_value
00019c  9300              STR      r3,[sp,#0]            ;1024
00019e  ee013a10          VMOV     s2,r3                 ;1024
0001a2  edd10a21          VLDR     s1,[r1,#0x84]         ;1024
0001a6  edd11a13          VLDR     s3,[r1,#0x4c]         ;1024
0001aa  eeb81a41          VCVT.F32.U32 s2,s2                 ;1024
0001ae  ee410a21          VMLA.F32 s1,s2,s3              ;1024
0001b2  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1024
                  |L2.438|
0001b6  ee103a90          VMOV     r3,s1                 ;1025
0001ba  edcd0a00          VSTR     s1,[sp,#0]            ;1024
0001be  6343              STR      r3,[r0,#0x34]         ;1025  ; Para
0001c0  e7ce              B        |L2.352|
                  |L2.450|
0001c2  f8d87018          LDR      r7,[r8,#0x18]         ;1037  ; Run_Control
0001c6  2f02              CMP      r7,#2                 ;1037
0001c8  d11c              BNE      |L2.516|
0001ca  6e47              LDR      r7,[r0,#0x64]         ;1039  ; Para
0001cc  edd51a00          VLDR     s3,[r5,#0]            ;1039
0001d0  ee007a90          VMOV     s1,r7                 ;1039
0001d4  eeb81a60          VCVT.F32.U32 s2,s1                 ;1039
0001d8  eec10a00          VDIV.F32 s1,s2,s0              ;1039
0001dc  ee801aa1          VDIV.F32 s2,s1,s3              ;1039
0001e0  ee610a00          VMUL.F32 s1,s2,s0              ;1039
0001e4  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1039
0001e8  ee105a90          VMOV     r5,s1                 ;1039
0001ec  6145              STR      r5,[r0,#0x14]         ;1039  ; Para
0001ee  6945              LDR      r5,[r0,#0x14]         ;1040  ; Para
0001f0  f6432798          MOV      r7,#0x3a98            ;1040
0001f4  42bd              CMP      r5,r7                 ;1040
0001f6  d903              BLS      |L2.512|
0001f8  2501              MOVS     r5,#1                 ;1042
0001fa  f8c85020          STR      r5,[r8,#0x20]         ;1042  ; Run_Control
0001fe  e001              B        |L2.516|
                  |L2.512|
000200  f8c82020          STR      r2,[r8,#0x20]         ;1044  ; Run_Control
                  |L2.516|
000204  f8d85020          LDR      r5,[r8,#0x20]         ;1047  ; Run_Control
000208  2d00              CMP      r5,#0                 ;1047
00020a  6945              LDR      r5,[r0,#0x14]         ;1074  ; Para
00020c  9500              STR      r5,[sp,#0]            ;1047
00020e  d00e              BEQ      |L2.558|
000210  6947              LDR      r7,[r0,#0x14]         ;1075  ; Para
000212  f6446520          MOV      r5,#0x4e20            ;1075
000216  42af              CMP      r7,r5                 ;1075
000218  d228              BCS      |L2.620|
00021a  edd10a18          VLDR     s1,[r1,#0x60]         ;1077
00021e  6945              LDR      r5,[r0,#0x14]         ;1077  ; Para
000220  edd11a0a          VLDR     s3,[r1,#0x28]         ;1077
000224  ee015a10          VMOV     s2,r5                 ;1077
000228  eeb81a41          VCVT.F32.U32 s2,s2                 ;1077
00022c  e03b              B        |L2.678|
                  |L2.558|
00022e  6946              LDR      r6,[r0,#0x14]         ;1050  ; Para
000230  455e              CMP      r6,r11                ;1050
000232  d209              BCS      |L2.584|
000234  edd10a16          VLDR     s1,[r1,#0x58]         ;1052
000238  6945              LDR      r5,[r0,#0x14]         ;1052  ; Para
00023a  edd11a08          VLDR     s3,[r1,#0x20]         ;1052
00023e  ee015a10          VMOV     s2,r5                 ;1052
000242  eeb81a41          VCVT.F32.U32 s2,s2                 ;1052
000246  e008              B        |L2.602|
                  |L2.584|
000248  edd10a17          VLDR     s1,[r1,#0x5c]         ;1054
00024c  6945              LDR      r5,[r0,#0x14]         ;1054  ; Para
00024e  edd11a09          VLDR     s3,[r1,#0x24]         ;1054
000252  ee015a10          VMOV     s2,r5                 ;1054
000256  eeb81a41          VCVT.F32.U32 s2,s2                 ;1054
                  |L2.602|
00025a  ee410a21          VMLA.F32 s1,s2,s3              ;1054
00025e  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1054
000262  edcd0a00          VSTR     s1,[sp,#0]            ;1054
000266  ee105a90          VMOV     r5,s1                 ;1065
00026a  e023              B        |L2.692|
                  |L2.620|
00026c  6947              LDR      r7,[r0,#0x14]         ;1078  ; Para
00026e  42af              CMP      r7,r5                 ;1078
000270  d30d              BCC      |L2.654|
000272  6945              LDR      r5,[r0,#0x14]         ;1078  ; Para
000274  42b5              CMP      r5,r6                 ;1078
000276  d20a              BCS      |L2.654|
000278  edd10a19          VLDR     s1,[r1,#0x64]         ;1079
00027c  6945              LDR      r5,[r0,#0x14]         ;1079  ; Para
00027e  edd11a0b          VLDR     s3,[r1,#0x2c]         ;1079
000282  ee015a10          VMOV     s2,r5                 ;1079
000286  eeb81a41          VCVT.F32.U32 s2,s2                 ;1079
00028a  e00c              B        |L2.678|
                  |L2.652|
00028c  e01a              B        |L2.708|
                  |L2.654|
00028e  6945              LDR      r5,[r0,#0x14]         ;1080  ; Para
000290  42b5              CMP      r5,r6                 ;1080
000292  d30e              BCC      |L2.690|
000294  edd10a1a          VLDR     s1,[r1,#0x68]         ;1081
000298  6945              LDR      r5,[r0,#0x14]         ;1081  ; Para
00029a  edd11a0c          VLDR     s3,[r1,#0x30]         ;1081
00029e  ee015a10          VMOV     s2,r5                 ;1081
0002a2  eeb81a41          VCVT.F32.U32 s2,s2                 ;1081
                  |L2.678|
0002a6  ee410a21          VMLA.F32 s1,s2,s3              ;1081
0002aa  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1081
0002ae  edcd0a00          VSTR     s1,[sp,#0]            ;1081
                  |L2.690|
0002b2  9d00              LDR      r5,[sp,#0]            ;1091
                  |L2.692|
0002b4  801d              STRH     r5,[r3,#0]            ;1091
0002b6  6945              LDR      r5,[r0,#0x14]         ;1092  ; Para
0002b8  e06b              B        |L2.914|
                  |L2.698|
0002ba  7824              LDRB     r4,[r4,#0]            ;1092  ; mainswitch
0002bc  b904              CBNZ     r4,|L2.704|
                  |L2.702|
0002be  801a              STRH     r2,[r3,#0]            ;1094
                  |L2.704|
;;;1101   	{
;;;1102   		if(LOAD_V_SW==0)//低档
;;;1103   		{
;;;1104   			var32 = Para.CSET_Voltage_Laod;
;;;1105   			var32 = Para.CSET_Voltage_Laod * CalPara.SetCV[0] + CalPara.OffsetCV[0];   
;;;1106   //			if ((CLists.CPolar2 & 0x04) == 0)			   
;;;1107   //			{
;;;1108   //				if (var32 < CLists.CSET_LoadV_Offset_LOW) var32 = 0;
;;;1109   //				else var32 = var32 - CLists.CSET_LoadV_Offset_LOW;
;;;1110   //			}
;;;1111   //			else var32 = var32 + CLists.CSET_LoadV_Offset_LOW;
;;;1112   //			var32 = var32/CLists.CSET_Load_CorrectionV_LOW;
;;;1113   //			var32=var32>>1;
;;;1114   			Contr_Laod = var32;
;;;1115   			if(Para.CSET_Voltage_Laod==0 || mainswitch == 0)
;;;1116   			{
;;;1117   				Contr_Laod=0;
;;;1118   			}
;;;1119   			var32 = 0;
0002c0  9200              STR      r2,[sp,#0]
0002c2  e018              B        |L2.758|
                  |L2.708|
0002c4  f8d8501c          LDR      r5,[r8,#0x1c]         ;1102  ; Run_Control
0002c8  b3ed              CBZ      r5,|L2.838|
;;;1120   		}
;;;1121   		else//高档
;;;1122   		{
;;;1123   			var32 = Para.CSET_Voltage_Laod;
0002ca  6904              LDR      r4,[r0,#0x10]  ; Para
;;;1124   			var32 = Para.CSET_Voltage_Laod/10 * CalPara.SetCV[1] + CalPara.OffsetCV[1];  
0002cc  6904              LDR      r4,[r0,#0x10]  ; Para
0002ce  250a              MOVS     r5,#0xa
0002d0  fbb4f4f5          UDIV     r4,r4,r5
0002d4  ee004a90          VMOV     s1,r4
0002d8  edd11a0e          VLDR     s3,[r1,#0x38]
0002dc  eeb81a60          VCVT.F32.U32 s2,s1
0002e0  edd10a1c          VLDR     s1,[r1,#0x70]
0002e4  ee410a21          VMLA.F32 s1,s2,s3
0002e8  eefc0ae0          VCVT.U32.F32 s1,s1
;;;1125   //			if ((CLists.CPolar2 & 0x04) == 0)			   
;;;1126   //			{
;;;1127   //				if (var32 < CLists.CSET_LoadV_Offset_HIG) var32 = 0;
;;;1128   //				else var32 = var32 - CLists.CSET_LoadV_Offset_HIG;
;;;1129   //			}
;;;1130   //			else var32 = var32 + CLists.CSET_LoadV_Offset_HIG;
;;;1131   //			var32 = var32/CLists.CSET_Load_CorrectionV_HIG;
;;;1132   //			var32=var32>>1;
;;;1133   			Contr_Laod = var32;
0002ec  ee104a90          VMOV     r4,s1
0002f0  edcd0a00          VSTR     s1,[sp,#0]            ;1124
0002f4  801c              STRH     r4,[r3,#0]
                  |L2.758|
;;;1134   //			if(Para.CSET_Voltage_Laod==0)
;;;1135   //			{
;;;1136   //				Contr_Laod=0;
;;;1137   //			}
;;;1138   //			var32 = 0;
;;;1139   		}
;;;1140   		
;;;1141   	}
;;;1142   /*****************************内阻值转换*******************************************/
;;;1143   	if(RCONT_SW==0)//低档
0002f6  f8d87024          LDR      r7,[r8,#0x24]  ; Run_Control
;;;1144   	{
;;;1145   		var32 = Rmon_value;
0002fa  4b4c              LDR      r3,|L2.1068|
0002fc  2f00              CMP      r7,#0                 ;1143
;;;1146   		var32 = var32 * CalPara.TestR[0] + CalPara.OffsetR[0];  
;;;1147   //		if ((CLists.CPolar4 & 0x01) == 0x01)		  
;;;1148   //		{
;;;1149   //			if (var32 < CLists.CREG_ReadR_Offset_LOW) 
;;;1150   //			{
;;;1151   //				var32 = 0;
;;;1152   //			}
;;;1153   //			else var32 = var32 - CLists.CREG_ReadR_Offset_LOW;
;;;1154   //		}
;;;1155   //		else var32 = var32 + CLists.CREG_ReadR_Offset_LOW;
;;;1156   //		var32 = var32 >> 12;
;;;1157   //		if (var32 < 1)
;;;1158   //		{
;;;1159   //			var32 = 0;				  //清零
;;;1160   //		}
;;;1161   		Para.CR_VLUE = var32;
;;;1162   		if(Rmon_value > 60000 && finishdelay == 0)
0002fe  4d4a              LDR      r5,|L2.1064|
;;;1163   		{
;;;1164   			if(finishflag == 1)
000300  4c4b              LDR      r4,|L2.1072|
;;;1165   			{
;;;1166   				finishflag = 0;
;;;1167   			}
;;;1168   		}
;;;1169   //		if(Para.CR_VLUE > 250)
;;;1170   //		{
;;;1171   //			Para.CR_VLUE = 0;
;;;1172   //		}
;;;1173   		var32 = 0;	
;;;1174   	}
;;;1175   	else//高档
;;;1176   	{
;;;1177   		var32 = Rmon_value;
000302  881f              LDRH     r7,[r3,#0]  ; Rmon_value
000304  f64e2660          MOV      r6,#0xea60            ;1162
000308  9700              STR      r7,[sp,#0]            ;1143
00030a  d045              BEQ      |L2.920|
;;;1178   		var32 = var32 * CalPara.TestR[1] + CalPara.OffsetR[1];  
00030c  ee017a10          VMOV     s2,r7
000310  edd10a2a          VLDR     s1,[r1,#0xa8]
000314  edd11a25          VLDR     s3,[r1,#0x94]
000318  eeb81a41          VCVT.F32.U32 s2,s2
00031c  ee410a21          VMLA.F32 s1,s2,s3
000320  eefc0ae0          VCVT.U32.F32 s1,s1
;;;1179   //		if ((CLists.CPolar4 & 0x04) == 0x04)		  
;;;1180   //		{
;;;1181   //			if (var32 < CLists.CREG_ReadR_Offset_HIG) 
;;;1182   //			{
;;;1183   //				var32 = 0;
;;;1184   //			}
;;;1185   //			else var32 = var32 - CLists.CREG_ReadR_Offset_HIG;
;;;1186   //		}
;;;1187   //		else var32 = var32 + CLists.CREG_ReadR_Offset_HIG;
;;;1188   //		var32 = var32 >> 12;
;;;1189   //		if (var32 < 1)
;;;1190   //		{
;;;1191   //			var32 = 0;				  //清零
;;;1192   //		}
;;;1193   		Para.CR_VLUE = var32;
000324  ee107a90          VMOV     r7,s1
000328  edcd0a00          VSTR     s1,[sp,#0]            ;1178
00032c  6387              STR      r7,[r0,#0x38]  ; Para
;;;1194   		if(Para.CR_VLUE > 1000)
00032e  6b87              LDR      r7,[r0,#0x38]  ; Para
000330  4577              CMP      r7,lr
000332  d914              BLS      |L2.862|
;;;1195   		{
;;;1196   			var32 = Rmon_value;
000334  881f              LDRH     r7,[r3,#0]  ; Rmon_value
;;;1197   			var32 = var32 * CalPara.TestR[2] + CalPara.OffsetR[2];
000336  9700              STR      r7,[sp,#0]
000338  edd10a2b          VLDR     s1,[r1,#0xac]
00033c  edd11a26          VLDR     s3,[r1,#0x98]
                  |L2.832|
000340  ee017a10          VMOV     s2,r7                 ;1146
000344  e000              B        |L2.840|
                  |L2.838|
000346  e010              B        |L2.874|
                  |L2.840|
000348  eeb81a41          VCVT.F32.U32 s2,s2                 ;1146
00034c  ee410a21          VMLA.F32 s1,s2,s3              ;1146
000350  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1146
000354  ee107a90          VMOV     r7,s1                 ;1161
000358  edcd0a00          VSTR     s1,[sp,#0]            ;1146
00035c  6387              STR      r7,[r0,#0x38]         ;1161  ; Para
                  |L2.862|
;;;1198   			Para.CR_VLUE = var32;
;;;1199   		}
;;;1200   		if(Rmon_value > 60000 && finishdelay == 0)
00035e  881b              LDRH     r3,[r3,#0]  ; Rmon_value
000360  42b3              CMP      r3,r6
000362  d922              BLS      |L2.938|
000364  682b              LDR      r3,[r5,#0]            ;1162  ; finishdelay
000366  b1e3              CBZ      r3,|L2.930|
000368  e01f              B        |L2.938|
                  |L2.874|
00036a  6905              LDR      r5,[r0,#0x10]         ;1104  ; Para
00036c  edd10a1b          VLDR     s1,[r1,#0x6c]         ;1105
000370  6905              LDR      r5,[r0,#0x10]         ;1105  ; Para
000372  edd11a0d          VLDR     s3,[r1,#0x34]         ;1105
000376  ee015a10          VMOV     s2,r5                 ;1105
00037a  eeb81a41          VCVT.F32.U32 s2,s2                 ;1105
00037e  ee410a21          VMLA.F32 s1,s2,s3              ;1105
000382  eefc0ae0          VCVT.U32.F32 s1,s1                 ;1105
000386  ee105a90          VMOV     r5,s1                 ;1114
00038a  edcd0a00          VSTR     s1,[sp,#0]            ;1105
00038e  801d              STRH     r5,[r3,#0]            ;1114
000390  6905              LDR      r5,[r0,#0x10]         ;1115  ; Para
                  |L2.914|
000392  2d00              CMP      r5,#0                 ;1115
000394  d093              BEQ      |L2.702|
000396  e790              B        |L2.698|
                  |L2.920|
000398  edd10a29          VLDR     s1,[r1,#0xa4]         ;1146
00039c  edd11a24          VLDR     s3,[r1,#0x90]         ;1146
0003a0  e7ce              B        |L2.832|
                  |L2.930|
0003a2  7823              LDRB     r3,[r4,#0]            ;1164  ; finishflag
0003a4  2b01              CMP      r3,#1                 ;1164
0003a6  d100              BNE      |L2.938|
0003a8  7022              STRB     r2,[r4,#0]            ;1166
                  |L2.938|
;;;1201   		{
;;;1202   			if(finishflag == 1)
;;;1203   			{
;;;1204   				finishflag = 0;
;;;1205   			}
;;;1206   		}
;;;1207   		var32 = 0;	
;;;1208   	}
;;;1209   	
;;;1210   	/*****************************稳压电源测量电压转换*******************************************/
;;;1211   //	var32 = Vmon_POWE_value;
;;;1212   //	var32 = var32 * CalPara.TestPV[0] + CalPara.OffsetPV[0];  
;;;1213   //	//	if ((CLists.CPolar5 & 0x01) == 0x01)		  
;;;1214   //	//	{
;;;1215   //	//		if (var32 < CLists.CREG_POWERV_Offset) 
;;;1216   //	//		{
;;;1217   //	//			var32 = 0;
;;;1218   //	//		}
;;;1219   //	//		else var32 = var32 - CLists.CREG_POWERV_Offset;
;;;1220   //	//	}
;;;1221   //	//	else var32 = var32 + CLists.CREG_POWERV_Offset;
;;;1222   //	//	var32 = var32 >> 12;
;;;1223   //	//	if (var32 < 40) var32 = 0;				  //40mV以下清零
;;;1224   //	Para.CPOW_Voltage = var32;
;;;1225   //	//	DISS_POW_Voltage=Para.CPOW_Voltage;
;;;1226   	DISS_POW_Voltage=(float)Para.CPOW_Voltage/1000;//计算显示电压
0003aa  9200              STR      r2,[sp,#0]
0003ac  6a83              LDR      r3,[r0,#0x28]  ; Para
0003ae  ee003a90          VMOV     s1,r3
0003b2  4b20              LDR      r3,|L2.1076|
0003b4  eef80a60          VCVT.F32.U32 s1,s1
0003b8  ee801a80          VDIV.F32 s2,s1,s0
0003bc  ed831a00          VSTR     s2,[r3,#0]
;;;1227   //	var32 = 0;
;;;1228   /*****************************稳压电源测量电流转换*******************************************/
;;;1229   //	var32 = Imon_POWE_value;
;;;1230   //	if(flag_CC_MODE==1)
;;;1231   //	{
;;;1232   //		var32 = var32 * CalPara.TestPC[0] + CalPara.OffsetTestPC[0];	   
;;;1233   ////		if ((CLists.CPolar6 & 0x01) == 0x01)			   
;;;1234   ////		{
;;;1235   ////			if (var32 < CLists.CREG_POWERA_Offset_CC) var32 = 0;
;;;1236   ////			else var32 = var32 - CLists.CREG_POWERA_Offset_CC;
;;;1237   ////		}
;;;1238   ////		else
;;;1239   ////		{
;;;1240   ////			var32 = var32 + CLists.CREG_POWERA_Offset_CC;
;;;1241   ////		}	
;;;1242   ////		var32 = var32 >> 12;
;;;1243   //		Para.CCurrent = var32;
;;;1244   ////		DISS_POW_Current=Para.CCurrent;
;;;1245   		DISS_POW_Current=(float)Para.CCurrent/100;//计算显示电流
0003c0  6b03              LDR      r3,[r0,#0x30]  ; Para
0003c2  eddf0a1d          VLDR     s1,|L2.1080|
0003c6  ee003a10          VMOV     s0,r3
0003ca  4b1c              LDR      r3,|L2.1084|
0003cc  eeb80a40          VCVT.F32.U32 s0,s0
0003d0  ee801a20          VDIV.F32 s2,s0,s1
0003d4  ed831a00          VSTR     s2,[r3,#0]
;;;1246   //	}
;;;1247   //	else
;;;1248   //	{
;;;1249   //		var32 = var32 * CLists.CREG_POWER_CorrectionA_CV;	   
;;;1250   //		if ((CLists.CPolar6 & 0x08) == 0x08)			   
;;;1251   //		{
;;;1252   //			if (var32 < CLists.CREG_POWERA_Offset_CV) var32 = 0;
;;;1253   //			else var32 = var32 - CLists.CREG_POWERA_Offset_CV;
;;;1254   //		}
;;;1255   //		else
;;;1256   //		{
;;;1257   //			var32 = var32 + CLists.CREG_POWERA_Offset_CV;
;;;1258   //		}	
;;;1259   //		var32 = var32 >> 12;
;;;1260   //		Para.CCurrent = var32;;
;;;1261   ////		DISS_POW_Current=Para.CCurrent;
;;;1262   //		DISS_POW_Current=(float)Para.CCurrent/1000;//计算显示电流
;;;1263   //	}
;;;1264   /**************************稳压电源设置电压转换******************************************/
;;;1265   	var32 = Para.CSET_Voltage;
0003d8  6883              LDR      r3,[r0,#8]  ; Para
;;;1266   	var32 = var32 * CalPara.SetPV[0] + CalPara.OffsetSetPV[0];   
0003da  9300              STR      r3,[sp,#0]
0003dc  ee003a90          VMOV     s1,r3
0003e0  ed910a06          VLDR     s0,[r1,#0x18]
0003e4  ed911a02          VLDR     s2,[r1,#8]
0003e8  eef80a60          VCVT.F32.U32 s1,s1
0003ec  ee000a81          VMLA.F32 s0,s1,s2
0003f0  eebc0ac0          VCVT.U32.F32 s0,s0
0003f4  ed8d0a00          VSTR     s0,[sp,#0]
;;;1267   //	if ((CLists.CPolar5 & 0x04) == 0)			   
;;;1268   //	{
;;;1269   //		if (var32 < CLists.CSET_POWERV_Offset) var32 = 0;
;;;1270   //		else var32 = var32 - CLists.CSET_POWERV_Offset;
;;;1271   //	}
;;;1272   //	else var32 = var32 + CLists.CSET_POWERV_Offset;
;;;1273   //	var32 = var32/CLists.CSET_POWER_CorrectionV;
;;;1274   //	var32=var32>>1;
;;;1275   	Contr_Voltage = var32;
0003f8  e022              B        |L2.1088|
0003fa  0000              DCW      0x0000
                  |L2.1020|
                          DCD      ||area_number.7||
                  |L2.1024|
                          DCD      Vmon_Load_value
                  |L2.1028|
                          DCD      DISS_Voltage
                  |L2.1032|
000408  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.1036|
                          DCD      CalPara
                  |L2.1040|
                          DCD      Para
                  |L2.1044|
                          DCD      lockflag
                  |L2.1048|
                          DCD      DISS_Current
                  |L2.1052|
                          DCD      Imon_Load_value
                  |L2.1056|
                          DCD      mainswitch
                  |L2.1060|
                          DCD      Contr_Laod
                  |L2.1064|
                          DCD      finishdelay
                  |L2.1068|
                          DCD      Rmon_value
                  |L2.1072|
                          DCD      finishflag
                  |L2.1076|
                          DCD      DISS_POW_Voltage
                  |L2.1080|
000438  42c80000          DCFS     0x42c80000 ; 100
                  |L2.1084|
                          DCD      DISS_POW_Current
                  |L2.1088|
000440  4b2c              LDR      r3,|L2.1268|
000442  ee104a10          VMOV     r4,s0
000446  801c              STRH     r4,[r3,#0]
;;;1276   	if(Para.CSET_Voltage==0)
000448  6884              LDR      r4,[r0,#8]  ; Para
00044a  b904              CBNZ     r4,|L2.1102|
;;;1277   	{
;;;1278   		Contr_Voltage=0;
00044c  801a              STRH     r2,[r3,#0]
                  |L2.1102|
;;;1279   	}
;;;1280   	var32 = 0;
;;;1281   /**************************稳压电源设置电流转换**************************************/
;;;1282   	var32 = Para.CSET_Current;
00044e  68c3              LDR      r3,[r0,#0xc]  ; Para
;;;1283   	var32 = var32 * CalPara.SetPC[0] + CalPara.OffsetPC[0];  
000450  9300              STR      r3,[sp,#0]
000452  ee003a90          VMOV     s1,r3
000456  ed910a22          VLDR     s0,[r1,#0x88]
00045a  ed911a14          VLDR     s2,[r1,#0x50]
00045e  eef80a60          VCVT.F32.U32 s1,s1
;;;1284   //	if ((CLists.CPolar6 & 0x04) == 0)			   
;;;1285   //	{
;;;1286   //		if (var32 < CLists.CSET_POWERA_Offset) var32 = 0;
;;;1287   //		else var32 = var32 - CLists.CSET_POWERA_Offset;
;;;1288   //	}
;;;1289   //	else var32 = var32 + CLists.CSET_POWERA_Offset;
;;;1290   //	var32 = var32/CLists.CSET_POWER_CorrectionA;
;;;1291   //	var32=var32>>1;
;;;1292   	Contr_Current = var32;
000462  4b25              LDR      r3,|L2.1272|
000464  ee000a81          VMLA.F32 s0,s1,s2              ;1283
000468  eebc0ac0          VCVT.U32.F32 s0,s0                 ;1283
00046c  ee104a10          VMOV     r4,s0
000470  ed8d0a00          VSTR     s0,[sp,#0]            ;1283
000474  801c              STRH     r4,[r3,#0]
;;;1293   	if(Para.CSET_Current==0)
000476  68c4              LDR      r4,[r0,#0xc]  ; Para
000478  b904              CBNZ     r4,|L2.1148|
;;;1294   	{
;;;1295   		Contr_Current=0;
00047a  801a              STRH     r2,[r3,#0]
                  |L2.1148|
;;;1296   	}
;;;1297   	var32 = 0;
;;;1298   	
;;;1299   /********************识别电阻1转换******************************/
;;;1300   //	var32=(R1mon_value*1000)/(65535-R1mon_value);
;;;1301   	var32 = (R1mon_value*1000)/(65535-R1mon_value);
00047c  4b1f              LDR      r3,|L2.1276|
00047e  881c              LDRH     r4,[r3,#0]  ; R1mon_value
000480  f44f757a          MOV      r5,#0x3e8
000484  436c              MULS     r4,r5,r4
000486  881d              LDRH     r5,[r3,#0]  ; R1mon_value
000488  f64f73ff          MOV      r3,#0xffff
00048c  1b5d              SUBS     r5,r3,r5
00048e  fbb4f4f5          UDIV     r4,r4,r5
;;;1302   	var32 = var32 * CalPara.TestR1[0] + CalPara.OffsetR1[0];  
000492  ee004a90          VMOV     s1,r4
000496  9400              STR      r4,[sp,#0]
000498  ed910a2c          VLDR     s0,[r1,#0xb0]
00049c  eef80a60          VCVT.F32.U32 s1,s1
0004a0  ed911a27          VLDR     s2,[r1,#0x9c]
0004a4  ee000a81          VMLA.F32 s0,s1,s2
0004a8  eebc0ac0          VCVT.U32.F32 s0,s0
;;;1303   //	if ((CLists.CPolar7 & 0x01) == 0x01)		  
;;;1304   //	{
;;;1305   //		if (var32 < CLists.CREG_ReadR1_Offset) 
;;;1306   //		{
;;;1307   //			var32 = 0;
;;;1308   //		}
;;;1309   //		else var32 = var32 - CLists.CREG_ReadR1_Offset;
;;;1310   //	}
;;;1311   //	else var32 = var32 + CLists.CREG_ReadR1_Offset;
;;;1312   //	var32 = var32 >> 12;
;;;1313   //	if (var32 < 1)
;;;1314   //	{
;;;1315   //		var32 = 0;				  //清零
;;;1316   //	}
;;;1317   	Para.CR1_VLUE = var32;
0004ac  ee104a10          VMOV     r4,s0
0004b0  ed8d0a00          VSTR     s0,[sp,#0]            ;1302
0004b4  63c4              STR      r4,[r0,#0x3c]  ; Para
;;;1318   //	if(R1mon_value > 34000)
;;;1319   //	{
;;;1320   //		Para.CR1_VLUE = 100;
;;;1321   //	}
;;;1322   	var32 = 0;	
;;;1323   	
;;;1324   	
;;;1325   /********************识别电阻2转换******************************/	
;;;1326   	var32 = (R2mon_value*1000)/(65535-R2mon_value);
0004b6  4c12              LDR      r4,|L2.1280|
0004b8  8825              LDRH     r5,[r4,#0]  ; R2mon_value
0004ba  f44f767a          MOV      r6,#0x3e8
0004be  8824              LDRH     r4,[r4,#0]  ; R2mon_value
0004c0  4375              MULS     r5,r6,r5
0004c2  1b1b              SUBS     r3,r3,r4
0004c4  fbb5f3f3          UDIV     r3,r5,r3
;;;1327   	var32 = var32 * CalPara.TestR2[0] + CalPara.OffsetR2[0];   
0004c8  ee003a10          VMOV     s0,r3
0004cc  9300              STR      r3,[sp,#0]
0004ce  edd10a2d          VLDR     s1,[r1,#0xb4]
0004d2  eeb80a40          VCVT.F32.U32 s0,s0
0004d6  ed911a28          VLDR     s2,[r1,#0xa0]
0004da  ee400a01          VMLA.F32 s1,s0,s2
0004de  eebc0ae0          VCVT.U32.F32 s0,s1
;;;1328   //	if ((CLists.CPolar7 & 0x04) == 0x04)		  
;;;1329   //	{
;;;1330   //		if (var32 < CLists.CREG_ReadR2_Offset) 
;;;1331   //		{
;;;1332   //			var32 = 0;
;;;1333   //		}
;;;1334   //		else var32 = var32 - CLists.CREG_ReadR2_Offset;
;;;1335   //	}
;;;1336   //	else var32 = var32 + CLists.CREG_ReadR2_Offset;
;;;1337   //	var32 = var32 >> 12;
;;;1338   //	if (var32 < 1)
;;;1339   //	{
;;;1340   //		var32 = 0;				  //清零
;;;1341   //	}
;;;1342   	Para.CR2_VLUE = var32;
0004e2  ee101a10          VMOV     r1,s0
0004e6  ed8d0a00          VSTR     s0,[sp,#0]            ;1327
0004ea  6401              STR      r1,[r0,#0x40]  ; Para
;;;1343   	var32 = 0;	
0004ec  9200              STR      r2,[sp,#0]
;;;1344   }
0004ee  e8bd8ff8          POP      {r3-r11,pc}
;;;1345   /********************************************************************************
                          ENDP

0004f2  0000              DCW      0x0000
                  |L2.1268|
                          DCD      Contr_Voltage
                  |L2.1272|
                          DCD      Contr_Current
                  |L2.1276|
                          DCD      R1mon_value
                  |L2.1280|
                          DCD      R2mon_value

                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;46     //===========================MODBUS协议=============================//
;;;47     void UART_Action(void)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;48     {//RUT格式：
;;;49     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;50     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;51     	if (UART_Buffer_Rece[0] == ADDR)
000004  f8df83f0          LDR      r8,|L3.1016|
000008  f8980000          LDRB     r0,[r8,#0]  ; UART_Buffer_Rece
00000c  4cfb              LDR      r4,|L3.1020|
00000e  7821              LDRB     r1,[r4,#0]  ; ADDR
;;;52     	{
;;;53     		if (UART_Buffer_Rece[1] == (0x03))	//命令3 读数据   
;;;54     		{																		 
;;;55     			vu8 i;
;;;56     			vu16 crc_result;
;;;57     			crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;58     			if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )
;;;59     			{
;;;60     				if (UART_Buffer_Rece[3] < 0x07)    								//如果寄存器在可读范围内
;;;61     				{
;;;62     					if ((UART_Buffer_Rece[3] + UART_Buffer_Rece[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;63     					{							
;;;64     						UART_Buffer_Send[0] = ADDR;
000010  4efb              LDR      r6,|L3.1024|
;;;65     						UART_Buffer_Send[1] = 0x03;
;;;66     						UART_Buffer_Send[2] = UART_Buffer_Rece[5]*2;
;;;67     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;68     						{
;;;69     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2] >> 8;
;;;70     							else UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2];														
;;;71     						}
;;;72     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;73     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;74     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;75     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
000012  f8dfa3f0          LDR      r10,|L3.1028|
;;;76     						UART_SEND_flag=1;
000016  4ffc              LDR      r7,|L3.1032|
000018  f8df93f0          LDR      r9,|L3.1036|
00001c  2500              MOVS     r5,#0                 ;69
00001e  4288              CMP      r0,r1                 ;51
000020  d168              BNE      |L3.244|
000022  f8980001          LDRB     r0,[r8,#1]            ;53  ; UART_Buffer_Rece
000026  2803              CMP      r0,#3                 ;53
000028  d164              BNE      |L3.244|
00002a  f8980007          LDRB     r0,[r8,#7]            ;57  ; UART_Buffer_Rece
00002e  f8981006          LDRB     r1,[r8,#6]            ;57  ; UART_Buffer_Rece
000032  eb002001          ADD      r0,r0,r1,LSL #8       ;57
000036  f8ad0004          STRH     r0,[sp,#4]            ;57
00003a  2106              MOVS     r1,#6                 ;58
00003c  4640              MOV      r0,r8                 ;58
00003e  f7fffffe          BL       Hardware_CRC
000042  f8bd1004          LDRH     r1,[sp,#4]            ;58
000046  4288              CMP      r0,r1                 ;58
000048  d002              BEQ      |L3.80|
00004a  f8bd0004          LDRH     r0,[sp,#4]            ;58
00004e  bbe8              CBNZ     r0,|L3.204|
                  |L3.80|
000050  f8980003          LDRB     r0,[r8,#3]            ;60  ; UART_Buffer_Rece
000054  2807              CMP      r0,#7                 ;60
000056  d24d              BCS      |L3.244|
000058  f8980003          LDRB     r0,[r8,#3]            ;62  ; UART_Buffer_Rece
00005c  f8981005          LDRB     r1,[r8,#5]            ;62  ; UART_Buffer_Rece
000060  4408              ADD      r0,r0,r1              ;62
000062  280f              CMP      r0,#0xf               ;62
000064  d246              BCS      |L3.244|
000066  7820              LDRB     r0,[r4,#0]            ;64  ; ADDR
000068  7030              STRB     r0,[r6,#0]            ;64
00006a  2003              MOVS     r0,#3                 ;65
00006c  7070              STRB     r0,[r6,#1]            ;65
00006e  f8980005          LDRB     r0,[r8,#5]            ;66  ; UART_Buffer_Rece
000072  0040              LSLS     r0,r0,#1              ;66
000074  70b0              STRB     r0,[r6,#2]            ;66
000076  f88d5000          STRB     r5,[sp,#0]            ;67
00007a  4648              MOV      r0,r9                 ;69
00007c  e016              B        |L3.172|
00007e  bf00              NOP                            ;69
                  |L3.128|
000080  f89d1000          LDRB     r1,[sp,#0]            ;69
000084  07c9              LSLS     r1,r1,#31             ;69
000086  f8981003          LDRB     r1,[r8,#3]            ;70  ; UART_Buffer_Rece
00008a  f89d2000          LDRB     r2,[sp,#0]            ;70
00008e  eb010152          ADD      r1,r1,r2,LSR #1       ;70
000092  f8501021          LDR      r1,[r0,r1,LSL #2]     ;70
000096  d100              BNE      |L3.154|
000098  0a09              LSRS     r1,r1,#8              ;69
                  |L3.154|
00009a  f89d2000          LDRB     r2,[sp,#0]            ;70
00009e  4432              ADD      r2,r2,r6              ;70
0000a0  70d1              STRB     r1,[r2,#3]            ;70
0000a2  f89d1000          LDRB     r1,[sp,#0]            ;67
0000a6  1c49              ADDS     r1,r1,#1              ;67
0000a8  f88d1000          STRB     r1,[sp,#0]            ;67
                  |L3.172|
0000ac  78b1              LDRB     r1,[r6,#2]            ;67  ; UART_Buffer_Send
0000ae  f89d2000          LDRB     r2,[sp,#0]            ;67
0000b2  4291              CMP      r1,r2                 ;67
0000b4  d8e4              BHI      |L3.128|
0000b6  78b0              LDRB     r0,[r6,#2]            ;72  ; UART_Buffer_Send
0000b8  1cc0              ADDS     r0,r0,#3              ;72
0000ba  b2c1              UXTB     r1,r0                 ;72
0000bc  48d0              LDR      r0,|L3.1024|
0000be  f7fffffe          BL       Hardware_CRC
0000c2  f8ad0004          STRH     r0,[sp,#4]            ;72
0000c6  f8bd0004          LDRH     r0,[sp,#4]            ;73
0000ca  e000              B        |L3.206|
                  |L3.204|
0000cc  e012              B        |L3.244|
                  |L3.206|
0000ce  78b2              LDRB     r2,[r6,#2]            ;73  ; UART_Buffer_Send
0000d0  0a01              LSRS     r1,r0,#8              ;73
0000d2  48cb              LDR      r0,|L3.1024|
0000d4  1cc0              ADDS     r0,r0,#3              ;73
0000d6  5411              STRB     r1,[r2,r0]            ;73
0000d8  f8bd0004          LDRH     r0,[sp,#4]            ;74
0000dc  78b2              LDRB     r2,[r6,#2]            ;74  ; UART_Buffer_Send
0000de  49c8              LDR      r1,|L3.1024|
0000e0  1d09              ADDS     r1,r1,#4              ;74
0000e2  5450              STRB     r0,[r2,r1]            ;74
0000e4  78b0              LDRB     r0,[r6,#2]            ;75  ; UART_Buffer_Send
0000e6  1d40              ADDS     r0,r0,#5              ;75
0000e8  f88a0000          STRB     r0,[r10,#0]           ;75
0000ec  6839              LDR      r1,[r7,#0]  ; flagA
0000ee  f0410110          ORR      r1,r1,#0x10
0000f2  6039              STR      r1,[r7,#0]  ; flagA
                  |L3.244|
;;;77     					}
;;;78     				}
;;;79     			}	
;;;80     		}
;;;81     	} 
;;;82     //===============================写寄存器=================================
;;;83     	if ((UART_Buffer_Rece[0] == 0) ||  (UART_Buffer_Rece[0] == ADDR) || (UART_Buffer_Rece[0] == ((ADDR-1)/4+100)))	 
0000f4  f8980000          LDRB     r0,[r8,#0]  ; UART_Buffer_Rece
0000f8  b180              CBZ      r0,|L3.284|
0000fa  f8981000          LDRB     r1,[r8,#0]  ; UART_Buffer_Rece
0000fe  7820              LDRB     r0,[r4,#0]  ; ADDR
000100  4281              CMP      r1,r0
000102  d00b              BEQ      |L3.284|
000104  7820              LDRB     r0,[r4,#0]  ; ADDR
000106  f8981000          LDRB     r1,[r8,#0]  ; UART_Buffer_Rece
00010a  1e40              SUBS     r0,r0,#1
00010c  17c2              ASRS     r2,r0,#31
00010e  eb007292          ADD      r2,r0,r2,LSR #30
000112  2064              MOVS     r0,#0x64
000114  eb0000a2          ADD      r0,r0,r2,ASR #2
000118  4281              CMP      r1,r0
00011a  d171              BNE      |L3.512|
                  |L3.284|
;;;84     	{
;;;85     		vu8 var8;
;;;86     		vu8 a=0;
00011c  f88d5008          STRB     r5,[sp,#8]
;;;87     		vu16 var16;
;;;88     		vu16 crc_result;
;;;89     //=========================以下命令6 写单个寄存器===========================
;;;90     		if (UART_Buffer_Rece[1] == 6)                                 //判断第二个字节是否为命令6
000120  f8980001          LDRB     r0,[r8,#1]  ; UART_Buffer_Rece
;;;91     		{
;;;92     			if (UART_Buffer_Rece[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;93     			{
;;;94     				crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;95     				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )		  //检查CRC
;;;96     				{
;;;97     					var16 = (UART_Buffer_Rece[4] << 8) + UART_Buffer_Rece[5];	//第5 6个字节为要写入的数据
;;;98     					var8 = UART_Buffer_Rece[3];	        						//第3 4个字节为要写入的地址
;;;99     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;100    
;;;101    					if (UART_Buffer_Rece[0] == ADDR)							//广播模式下不返回数据
;;;102    					{
;;;103    						for (a=0;a<8;a++)
;;;104    						{UART_Buffer_Send[a] = UART_Buffer_Rece[a];}
;;;105    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
000124  f04f0b08          MOV      r11,#8
000128  2806              CMP      r0,#6                 ;90
00012a  d147              BNE      |L3.444|
00012c  f8980003          LDRB     r0,[r8,#3]            ;92  ; UART_Buffer_Rece
000130  2805              CMP      r0,#5                 ;92
000132  d243              BCS      |L3.444|
000134  f8980007          LDRB     r0,[r8,#7]            ;94  ; UART_Buffer_Rece
000138  f8981006          LDRB     r1,[r8,#6]            ;94  ; UART_Buffer_Rece
00013c  eb002001          ADD      r0,r0,r1,LSL #8       ;94
000140  f8ad0004          STRH     r0,[sp,#4]            ;94
000144  2106              MOVS     r1,#6                 ;95
000146  48ac              LDR      r0,|L3.1016|
000148  f7fffffe          BL       Hardware_CRC
00014c  f8bd1004          LDRH     r1,[sp,#4]            ;95
000150  4288              CMP      r0,r1                 ;95
000152  d002              BEQ      |L3.346|
000154  f8bd0004          LDRH     r0,[sp,#4]            ;95
000158  bb80              CBNZ     r0,|L3.444|
                  |L3.346|
00015a  f8980005          LDRB     r0,[r8,#5]            ;97  ; UART_Buffer_Rece
00015e  f8981004          LDRB     r1,[r8,#4]            ;97  ; UART_Buffer_Rece
000162  eb002001          ADD      r0,r0,r1,LSL #8       ;97
000166  f8ad000c          STRH     r0,[sp,#0xc]          ;97
00016a  f8980003          LDRB     r0,[r8,#3]            ;98  ; UART_Buffer_Rece
00016e  f88d0000          STRB     r0,[sp,#0]            ;98
000172  f8bd100c          LDRH     r1,[sp,#0xc]          ;99
000176  f89d2000          LDRB     r2,[sp,#0]            ;99
00017a  f8491022          STR      r1,[r9,r2,LSL #2]     ;99
00017e  f8980000          LDRB     r0,[r8,#0]            ;101  ; UART_Buffer_Rece
000182  7821              LDRB     r1,[r4,#0]            ;101  ; ADDR
000184  4288              CMP      r0,r1                 ;101
000186  d119              BNE      |L3.444|
000188  f88d5008          STRB     r5,[sp,#8]            ;103
00018c  e00c              B        |L3.424|
00018e  bf00              NOP                            ;104
                  |L3.400|
000190  f89d0008          LDRB     r0,[sp,#8]            ;104
000194  f8180000          LDRB     r0,[r8,r0]            ;104
000198  f89d1008          LDRB     r1,[sp,#8]            ;104
00019c  5470              STRB     r0,[r6,r1]            ;104
00019e  f89d0008          LDRB     r0,[sp,#8]            ;103
0001a2  1c40              ADDS     r0,r0,#1              ;103
0001a4  f88d0008          STRB     r0,[sp,#8]            ;103
                  |L3.424|
0001a8  f89d0008          LDRB     r0,[sp,#8]            ;103
0001ac  2808              CMP      r0,#8                 ;103
0001ae  d3ef              BCC      |L3.400|
0001b0  f88ab000          STRB     r11,[r10,#0]
;;;106    						UART_SEND_flag=1;
0001b4  6839              LDR      r1,[r7,#0]  ; flagA
0001b6  f0410110          ORR      r1,r1,#0x10
0001ba  6039              STR      r1,[r7,#0]  ; flagA
                  |L3.444|
;;;107    					}
;;;108    				}
;;;109    			}
;;;110    		}
;;;111    //=======================================以下是命令16，连写寄存器===========================================
;;;112    //功能码16格式:
;;;113    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;114    //返回数据格式:
;;;115    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;116    		if (UART_Buffer_Rece[1] == 16)										  
0001bc  f8980001          LDRB     r0,[r8,#1]  ; UART_Buffer_Rece
0001c0  2810              CMP      r0,#0x10
0001c2  d160              BNE      |L3.646|
;;;117    		{	
;;;118    			if ((UART_Buffer_Rece[6] == 6) && (UART_Buffer_Rece[3] == 0x00))	//规定连写寄存器的个数
0001c4  f8980006          LDRB     r0,[r8,#6]  ; UART_Buffer_Rece
0001c8  2806              CMP      r0,#6
0001ca  d15c              BNE      |L3.646|
0001cc  f8980003          LDRB     r0,[r8,#3]  ; UART_Buffer_Rece
0001d0  b9b0              CBNZ     r0,|L3.512|
;;;119    			{
;;;120    				crc_result = (UART_Buffer_Rece[13] << 8) + UART_Buffer_Rece[14];
0001d2  f898000e          LDRB     r0,[r8,#0xe]  ; UART_Buffer_Rece
0001d6  f898100d          LDRB     r1,[r8,#0xd]  ; UART_Buffer_Rece
0001da  eb002001          ADD      r0,r0,r1,LSL #8
0001de  f8ad0004          STRH     r0,[sp,#4]
;;;121    				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,13)) ||(crc_result == 0) )	   //检查CRC
0001e2  210d              MOVS     r1,#0xd
0001e4  4884              LDR      r0,|L3.1016|
0001e6  f7fffffe          BL       Hardware_CRC
0001ea  f8bd1004          LDRH     r1,[sp,#4]
0001ee  4288              CMP      r0,r1
0001f0  d002              BEQ      |L3.504|
0001f2  f8bd0004          LDRH     r0,[sp,#4]
0001f6  b918              CBNZ     r0,|L3.512|
                  |L3.504|
;;;122    				{												
;;;123    					for (var8=0;var8<3;var8++) Run_Control[var8] = (UART_Buffer_Rece[var8*2+7] << 8) + UART_Buffer_Rece[var8*2+8];
0001f8  f88d5000          STRB     r5,[sp,#0]
0001fc  4648              MOV      r0,r9                 ;69
0001fe  e016              B        |L3.558|
                  |L3.512|
000200  e041              B        |L3.646|
000202  bf00              NOP      
                  |L3.516|
000204  f89d1000          LDRB     r1,[sp,#0]
000208  eb080141          ADD      r1,r8,r1,LSL #1
00020c  7a09              LDRB     r1,[r1,#8]
00020e  f89d2000          LDRB     r2,[sp,#0]
000212  eb080242          ADD      r2,r8,r2,LSL #1
000216  79d2              LDRB     r2,[r2,#7]
000218  eb012102          ADD      r1,r1,r2,LSL #8
00021c  f89d2000          LDRB     r2,[sp,#0]
000220  f8401022          STR      r1,[r0,r2,LSL #2]
000224  f89d1000          LDRB     r1,[sp,#0]
000228  1c49              ADDS     r1,r1,#1
00022a  f88d1000          STRB     r1,[sp,#0]
                  |L3.558|
00022e  f89d1000          LDRB     r1,[sp,#0]
000232  2903              CMP      r1,#3
000234  d3e6              BCC      |L3.516|
;;;124    
;;;125    					if (UART_Buffer_Rece[0] == ADDR)					  //广播模式不返回数据
000236  f8980000          LDRB     r0,[r8,#0]  ; UART_Buffer_Rece
00023a  7821              LDRB     r1,[r4,#0]  ; ADDR
00023c  4288              CMP      r0,r1
00023e  d122              BNE      |L3.646|
;;;126    					{
;;;127    						UART_Buffer_Send[0] = ADDR;
000240  7820              LDRB     r0,[r4,#0]  ; ADDR
000242  7030              STRB     r0,[r6,#0]
;;;128    						UART_Buffer_Send[1] = 16;
000244  2010              MOVS     r0,#0x10
000246  7070              STRB     r0,[r6,#1]
;;;129    						UART_Buffer_Send[2] = UART_Buffer_Rece[2];
000248  f8980002          LDRB     r0,[r8,#2]  ; UART_Buffer_Rece
00024c  70b0              STRB     r0,[r6,#2]
;;;130    						UART_Buffer_Send[3] = UART_Buffer_Rece[3];
00024e  f8980003          LDRB     r0,[r8,#3]  ; UART_Buffer_Rece
000252  70f0              STRB     r0,[r6,#3]
;;;131    						UART_Buffer_Send[4] = UART_Buffer_Rece[4];
000254  f8980004          LDRB     r0,[r8,#4]  ; UART_Buffer_Rece
000258  7130              STRB     r0,[r6,#4]
;;;132    						UART_Buffer_Send[5] = UART_Buffer_Rece[5];
00025a  f8980005          LDRB     r0,[r8,#5]  ; UART_Buffer_Rece
00025e  7170              STRB     r0,[r6,#5]
;;;133    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
000260  2106              MOVS     r1,#6
000262  4867              LDR      r0,|L3.1024|
000264  f7fffffe          BL       Hardware_CRC
000268  f8ad0004          STRH     r0,[sp,#4]
;;;134    						UART_Buffer_Send[6] = crc_result>>8;
00026c  f8bd0004          LDRH     r0,[sp,#4]
000270  0a00              LSRS     r0,r0,#8
000272  71b0              STRB     r0,[r6,#6]
;;;135    						UART_Buffer_Send[7] = crc_result;				 
000274  f8bd0004          LDRH     r0,[sp,#4]
000278  71f0              STRB     r0,[r6,#7]
;;;136    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
00027a  f88ab000          STRB     r11,[r10,#0]
;;;137    						UART_SEND_flag=1;
00027e  6839              LDR      r1,[r7,#0]  ; flagA
000280  f0410110          ORR      r1,r1,#0x10
000284  6039              STR      r1,[r7,#0]  ; flagA
                  |L3.646|
;;;138    					}
;;;139    				}
;;;140    			}			 
;;;141    		}
;;;142    	}
;;;143    /*************************************以下为校准部分**************************************************************************/
;;;144    	if (((UART_Buffer_Rece[0] == 0x01)&&(UART_Buffer_Rece[2] == 0xA5)))			   //校准开始
000286  f8980000          LDRB     r0,[r8,#0]  ; UART_Buffer_Rece
00028a  2801              CMP      r0,#1
                  |L3.652|
00028c  d17e              BNE      |L3.908|
00028e  f8980002          LDRB     r0,[r8,#2]  ; UART_Buffer_Rece
000292  28a5              CMP      r0,#0xa5
000294  d1fa              BNE      |L3.652|
;;;145    	{ 
;;;146    		vu16 crc_result;
;;;147    		crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
000296  f8980007          LDRB     r0,[r8,#7]  ; UART_Buffer_Rece
00029a  f8981006          LDRB     r1,[r8,#6]  ; UART_Buffer_Rece
00029e  eb002001          ADD      r0,r0,r1,LSL #8
0002a2  f8ad0000          STRH     r0,[sp,#0]
;;;148    		if (crc_result == Hardware_CRC(UART_Buffer_Rece,6) ||crc_result==0)
0002a6  2106              MOVS     r1,#6
0002a8  4853              LDR      r0,|L3.1016|
0002aa  f7fffffe          BL       Hardware_CRC
0002ae  f8bd1000          LDRH     r1,[sp,#0]
0002b2  4288              CMP      r0,r1
0002b4  d003              BEQ      |L3.702|
0002b6  f8bd0000          LDRH     r0,[sp,#0]
0002ba  2800              CMP      r0,#0
0002bc  d1e6              BNE      |L3.652|
                  |L3.702|
;;;149    		{
;;;150    			/**************负载电压低档校准***************************/
;;;151    			if(UART_Buffer_Rece[1] == 0x01)
0002be  f8980001          LDRB     r0,[r8,#1]  ; UART_Buffer_Rece
;;;152    			{
;;;153    				Modify_A_READ=0;
;;;154    				Modify_A_ACT=0;
;;;155    				Modify_A_READ = Vmon_Load_value;//测量电压值
0002c2  4953              LDR      r1,|L3.1040|
0002c4  2801              CMP      r0,#1                 ;151
0002c6  d10a              BNE      |L3.734|
0002c8  6065              STR      r5,[r4,#4]            ;153  ; Modify_A_READ
0002ca  60e5              STR      r5,[r4,#0xc]          ;154  ; Modify_A_ACT
0002cc  8808              LDRH     r0,[r1,#0]  ; Vmon_Load_value
0002ce  6060              STR      r0,[r4,#4]  ; Modify_A_READ
;;;156    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0002d0  f8980004          LDRB     r0,[r8,#4]  ; UART_Buffer_Rece
0002d4  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
0002d8  eb002002          ADD      r0,r0,r2,LSL #8
0002dc  60e0              STR      r0,[r4,#0xc]  ; Modify_A_ACT
                  |L3.734|
;;;157    			}
;;;158    			if (UART_Buffer_Rece[1] == 0x02)			   //电压测量校准完成
0002de  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;159    			{
;;;160    				vu32 var16;
;;;161    				vu32 var32a;
;;;162    				vu32 var32b;
;;;163    				
;;;164    				vu32 var16a;
;;;165    				vu32 var32c;
;;;166    				vu32 var32d;
;;;167    				Modify_B_READ=0;
;;;168    				Modify_B_ACT=0;
;;;169    				Modify_B_READ =Vmon_Load_value;//测量电压值
;;;170    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
;;;171    				var32a = Modify_B_ACT;
;;;172    				var32a = var32a - Modify_A_ACT;
;;;173    				var32a = var32a << 12;
;;;174    				var16 = Modify_B_READ - Modify_A_READ;
;;;175    				var32a = var32a / var16;
;;;176    				CLists.CREG_Load_CorrectionV_LOW = var32a;
0002e2  484c              LDR      r0,|L3.1044|
;;;177    				var32a=0;
;;;178    				var32a = Modify_B_ACT;
;;;179    				var32a = var32a << 12;
;;;180    				var32b = Modify_B_READ;
;;;181    				var32b = var32b * CLists.CREG_Load_CorrectionV_LOW;    //内阻电压测量参数低档	
;;;182    				if (var32a < var32b)
;;;183    				{
;;;184    					var32b = var32b - var32a;
;;;185    					CLists.CREG_LoadV_Offset_LOW = var32b;     //内阻电压测量参数  
;;;186    					CLists.CPolar0 |= 0x01;
;;;187    				}
;;;188    				else 
;;;189    				{
;;;190    					var32a = var32a - var32b;
;;;191    					CLists.CREG_LoadV_Offset_LOW = var32a;
;;;192    					CLists.CPolar0 &= ~0x01;
;;;193    				}			
;;;194    					//参数写进FLASH
;;;195    				Flag_DAC_OFF=0;
0002e4  4e4c              LDR      r6,|L3.1048|
0002e6  2a02              CMP      r2,#2                 ;158
0002e8  d13e              BNE      |L3.872|
0002ea  6125              STR      r5,[r4,#0x10]         ;167  ; Modify_B_READ
0002ec  61a5              STR      r5,[r4,#0x18]         ;168  ; Modify_B_ACT
0002ee  880a              LDRH     r2,[r1,#0]            ;169  ; Vmon_Load_value
0002f0  6122              STR      r2,[r4,#0x10]         ;169  ; Modify_B_READ
0002f2  f8982004          LDRB     r2,[r8,#4]            ;170  ; UART_Buffer_Rece
0002f6  f8983003          LDRB     r3,[r8,#3]            ;170  ; UART_Buffer_Rece
0002fa  eb022203          ADD      r2,r2,r3,LSL #8       ;170
0002fe  61a2              STR      r2,[r4,#0x18]         ;170  ; Modify_B_ACT
000300  69a2              LDR      r2,[r4,#0x18]         ;171  ; Modify_B_ACT
000302  9200              STR      r2,[sp,#0]            ;172
000304  68e3              LDR      r3,[r4,#0xc]          ;172  ; Modify_A_ACT
000306  1ad2              SUBS     r2,r2,r3              ;172
000308  0312              LSLS     r2,r2,#12             ;173
00030a  9200              STR      r2,[sp,#0]            ;174
00030c  6922              LDR      r2,[r4,#0x10]         ;174  ; Modify_B_READ
00030e  6863              LDR      r3,[r4,#4]            ;174  ; Modify_A_READ
000310  1ad2              SUBS     r2,r2,r3              ;174
000312  9201              STR      r2,[sp,#4]            ;174
000314  e9dd2300          LDRD     r2,r3,[sp,#0]         ;174
000318  fbb2f2f3          UDIV     r2,r2,r3              ;175
00031c  9200              STR      r2,[sp,#0]            ;176
00031e  6002              STR      r2,[r0,#0]            ;176  ; CLists
000320  69a2              LDR      r2,[r4,#0x18]         ;178  ; Modify_B_ACT
000322  0312              LSLS     r2,r2,#12             ;179
000324  9200              STR      r2,[sp,#0]            ;180
000326  6922              LDR      r2,[r4,#0x10]         ;180  ; Modify_B_READ
000328  9201              STR      r2,[sp,#4]            ;181
00032a  6802              LDR      r2,[r0,#0]            ;181  ; CLists
00032c  9b01              LDR      r3,[sp,#4]            ;181
00032e  435a              MULS     r2,r3,r2              ;181
000330  9201              STR      r2,[sp,#4]            ;181
000332  e9dd2300          LDRD     r2,r3,[sp,#0]         ;181
000336  429a              CMP      r2,r3                 ;182
000338  d209              BCS      |L3.846|
00033a  461a              MOV      r2,r3                 ;184
00033c  9b00              LDR      r3,[sp,#0]            ;184
00033e  1ad2              SUBS     r2,r2,r3              ;184
000340  9201              STR      r2,[sp,#4]            ;185
000342  6442              STR      r2,[r0,#0x44]         ;185  ; CLists
000344  f8902088          LDRB     r2,[r0,#0x88]         ;186  ; CLists
000348  f0420201          ORR      r2,r2,#1              ;186
00034c  e006              B        |L3.860|
                  |L3.846|
00034e  1ad2              SUBS     r2,r2,r3              ;190
000350  9200              STR      r2,[sp,#0]            ;191
000352  6442              STR      r2,[r0,#0x44]         ;191  ; CLists
000354  f8902088          LDRB     r2,[r0,#0x88]         ;192  ; CLists
000358  f0220201          BIC      r2,r2,#1              ;192
                  |L3.860|
00035c  f8802088          STRB     r2,[r0,#0x88]         ;192
000360  6832              LDR      r2,[r6,#0]  ; flagB
000362  f0220208          BIC      r2,r2,#8
000366  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.872|
;;;196    			}
;;;197    			
;;;198    			/**************负载电压高档校准***************************/
;;;199    			if(UART_Buffer_Rece[1] == 0x03)
000368  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
00036c  2a03              CMP      r2,#3
00036e  d10a              BNE      |L3.902|
;;;200    			{
;;;201    				Modify_A_READ=0;
000370  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;202    				Modify_A_ACT=0;
000372  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;203    				Modify_A_READ = Vmon_Load_value;//测量电压值
000374  880a              LDRH     r2,[r1,#0]  ; Vmon_Load_value
000376  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;204    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000378  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
00037c  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000380  eb022203          ADD      r2,r2,r3,LSL #8
000384  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.902|
;;;205    			}
;;;206    			if (UART_Buffer_Rece[1] == 0x04)			   //电压测量校准完成
000386  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
00038a  e000              B        |L3.910|
                  |L3.908|
00038c  e3e9              B        |L3.2914|
                  |L3.910|
00038e  2a04              CMP      r2,#4
000390  d151              BNE      |L3.1078|
;;;207    			{
;;;208    				vu32 var16;
;;;209    				vu32 var32a;
;;;210    				vu32 var32b;
;;;211    				
;;;212    				vu32 var16a;
;;;213    				vu32 var32c;
;;;214    				vu32 var32d;
;;;215    				Modify_B_READ=0;
000392  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;216    				Modify_B_ACT=0;
000394  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;217    				Modify_B_READ =Vmon_Load_value;//测量电压值
000396  8809              LDRH     r1,[r1,#0]  ; Vmon_Load_value
000398  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;218    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
00039a  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00039e  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
0003a2  eb012102          ADD      r1,r1,r2,LSL #8
0003a6  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;219    				var32a = Modify_B_ACT;
0003a8  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;220    				var32a = var32a - Modify_A_ACT;
0003aa  9100              STR      r1,[sp,#0]
0003ac  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
0003ae  1a89              SUBS     r1,r1,r2
;;;221    				var32a = var32a << 12;
0003b0  0309              LSLS     r1,r1,#12
;;;222    				var16 = Modify_B_READ - Modify_A_READ;
0003b2  9100              STR      r1,[sp,#0]
0003b4  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
0003b6  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
0003b8  1a89              SUBS     r1,r1,r2
0003ba  9101              STR      r1,[sp,#4]
0003bc  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;223    				var32a = var32a / var16;
0003c0  fbb1f1f2          UDIV     r1,r1,r2
;;;224    				CLists.CREG_Load_CorrectionV_HIG = var32a;
0003c4  9100              STR      r1,[sp,#0]
0003c6  6041              STR      r1,[r0,#4]  ; CLists
;;;225    				var32a=0;
;;;226    				var32a = Modify_B_ACT;
0003c8  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;227    				var32a = var32a << 12;
0003ca  0309              LSLS     r1,r1,#12
;;;228    				var32b = Modify_B_READ;
0003cc  9100              STR      r1,[sp,#0]
0003ce  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;229    				var32b = var32b * CLists.CREG_Load_CorrectionV_HIG;      //内阻电压测量参数高档
0003d0  9101              STR      r1,[sp,#4]
0003d2  6841              LDR      r1,[r0,#4]  ; CLists
0003d4  9a01              LDR      r2,[sp,#4]
0003d6  4351              MULS     r1,r2,r1
0003d8  9101              STR      r1,[sp,#4]
0003da  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;230    				if (var32a < var32b)
0003de  4291              CMP      r1,r2
0003e0  d21c              BCS      |L3.1052|
;;;231    				{
;;;232    					var32b = var32b - var32a;
0003e2  4611              MOV      r1,r2
0003e4  9a00              LDR      r2,[sp,#0]
0003e6  1a89              SUBS     r1,r1,r2
;;;233    					CLists.CREG_LoadV_Offset_HIG = var32b;     //内阻电压测量参数
0003e8  9101              STR      r1,[sp,#4]
0003ea  6481              STR      r1,[r0,#0x48]  ; CLists
;;;234    					CLists.CPolar0 |= 0x04;
0003ec  f8901088          LDRB     r1,[r0,#0x88]  ; CLists
0003f0  f0410104          ORR      r1,r1,#4
0003f4  e019              B        |L3.1066|
0003f6  0000              DCW      0x0000
                  |L3.1016|
                          DCD      UART_Buffer_Rece
                  |L3.1020|
                          DCD      ||area_number.11||
                  |L3.1024|
                          DCD      UART_Buffer_Send
                  |L3.1028|
                          DCD      Transmit_BUFFERsize
                  |L3.1032|
                          DCD      flagA
                  |L3.1036|
                          DCD      ||area_number.7||
                  |L3.1040|
                          DCD      Vmon_Load_value
                  |L3.1044|
                          DCD      CLists
                  |L3.1048|
                          DCD      flagB
                  |L3.1052|
;;;235    				}
;;;236    				else 
;;;237    				{
;;;238    					var32a = var32a - var32b;
00041c  1a89              SUBS     r1,r1,r2
;;;239    					CLists.CREG_LoadV_Offset_HIG = var32a;
00041e  9100              STR      r1,[sp,#0]
000420  6481              STR      r1,[r0,#0x48]  ; CLists
;;;240    					CLists.CPolar0 &= ~0x04;
000422  f8901088          LDRB     r1,[r0,#0x88]  ; CLists
000426  f0210104          BIC      r1,r1,#4
                  |L3.1066|
00042a  f8801088          STRB     r1,[r0,#0x88]
;;;241    				}			
;;;242    					//参数写进FLASH
;;;243    				Flag_DAC_OFF=0;
00042e  6831              LDR      r1,[r6,#0]  ; flagB
000430  f0210108          BIC      r1,r1,#8
000434  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1078|
;;;244    			}
;;;245    	     /*****************负载电流测量和控制校准*************************/
;;;246    			if (UART_Buffer_Rece[1] == 0x05)			   //CC模式校准
000436  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;247    			{
;;;248    				Modify_A_READ=0;
;;;249    				Modify_C_READ=0;
;;;250    				Modify_A_ACT=0;
;;;251    				Modify_A_READ = Imon_Load_value;//
00043a  49fe              LDR      r1,|L3.2100|
;;;252    				Modify_C_READ = Contr_Laod;//
00043c  4ffe              LDR      r7,|L3.2104|
00043e  2a05              CMP      r2,#5                 ;246
000440  d10d              BNE      |L3.1118|
000442  6065              STR      r5,[r4,#4]            ;248  ; Modify_A_READ
000444  60a5              STR      r5,[r4,#8]            ;249  ; Modify_C_READ
000446  60e5              STR      r5,[r4,#0xc]          ;250  ; Modify_A_ACT
000448  880a              LDRH     r2,[r1,#0]            ;251  ; Imon_Load_value
00044a  6062              STR      r2,[r4,#4]            ;251  ; Modify_A_READ
00044c  883a              LDRH     r2,[r7,#0]  ; Contr_Laod
00044e  60a2              STR      r2,[r4,#8]  ; Modify_C_READ
;;;253    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000450  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000454  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000458  eb022203          ADD      r2,r2,r3,LSL #8
00045c  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1118|
;;;254    			}
;;;255    			if (UART_Buffer_Rece[1] == 0x06)			   
00045e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000462  2a06              CMP      r2,#6
000464  d172              BNE      |L3.1356|
;;;256    			{
;;;257    				vu32 var16;
;;;258    				vu32 var32a;
;;;259    				vu32 var32b;
;;;260    				
;;;261    				vu32 var16a;
;;;262    				vu32 var32c;
;;;263    				vu32 var32d;
;;;264    				Modify_B_READ=0;
000466  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;265    				Modify_D_READ=0;
000468  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;266    				Modify_B_ACT=0;
00046a  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;267    				
;;;268    				Modify_B_READ = Imon_Load_value;
00046c  880a              LDRH     r2,[r1,#0]  ; Imon_Load_value
00046e  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;269    				Modify_D_READ = Contr_Laod;
000470  883a              LDRH     r2,[r7,#0]  ; Contr_Laod
000472  6162              STR      r2,[r4,#0x14]  ; Modify_D_READ
;;;270    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000474  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000478  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
00047c  eb022203          ADD      r2,r2,r3,LSL #8
000480  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;271    				
;;;272    				var32a = Modify_B_ACT;
000482  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;273    				var32a = var32a - Modify_A_ACT;
000484  9200              STR      r2,[sp,#0]
000486  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000488  1ad2              SUBS     r2,r2,r3
;;;274    				var32a = var32a << 12;
00048a  0312              LSLS     r2,r2,#12
;;;275    				var16 = Modify_B_READ - Modify_A_READ;
00048c  9200              STR      r2,[sp,#0]
00048e  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
000490  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
000492  1ad2              SUBS     r2,r2,r3
000494  9201              STR      r2,[sp,#4]
000496  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;276    				var32a = var32a / var16;
00049a  fbb2f2f3          UDIV     r2,r2,r3
;;;277    				CLists.CREG_Load_CorrectionA_LOW = var32a;
00049e  9200              STR      r2,[sp,#0]
0004a0  6082              STR      r2,[r0,#8]  ; CLists
;;;278    				var32a = Modify_B_ACT;
0004a2  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;279    				var32a = var32a << 12;
0004a4  0312              LSLS     r2,r2,#12
;;;280    				var32b = Modify_B_READ;
0004a6  9200              STR      r2,[sp,#0]
0004a8  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;281    				var32b = var32b * CLists.CREG_Load_CorrectionA_LOW;    //负载CC模式电流测量参数低档
0004aa  9201              STR      r2,[sp,#4]
0004ac  6882              LDR      r2,[r0,#8]  ; CLists
0004ae  9b01              LDR      r3,[sp,#4]
0004b0  435a              MULS     r2,r3,r2
0004b2  9201              STR      r2,[sp,#4]
0004b4  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;282    				if (var32a < var32b)
0004b8  429a              CMP      r2,r3
0004ba  d209              BCS      |L3.1232|
;;;283    				{
;;;284    					var32b = var32b - var32a;
0004bc  461a              MOV      r2,r3
0004be  9b00              LDR      r3,[sp,#0]
0004c0  1ad2              SUBS     r2,r2,r3
;;;285    					CLists.CREG_LoadA_Offset_LOW = var32b;     //负载CC模式电流测量参数
0004c2  9201              STR      r2,[sp,#4]
0004c4  64c2              STR      r2,[r0,#0x4c]  ; CLists
;;;286    					CLists.CPolar2 |= 0x01;
0004c6  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
0004ca  f0420201          ORR      r2,r2,#1
0004ce  e006              B        |L3.1246|
                  |L3.1232|
;;;287    				}
;;;288    				else 
;;;289    				{
;;;290    					var32a = var32a - var32b;
0004d0  1ad2              SUBS     r2,r2,r3
;;;291    					CLists.CREG_LoadA_Offset_LOW = var32a;
0004d2  9200              STR      r2,[sp,#0]
0004d4  64c2              STR      r2,[r0,#0x4c]  ; CLists
;;;292    					CLists.CPolar2 &= ~0x01;					
0004d6  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
0004da  f0220201          BIC      r2,r2,#1
                  |L3.1246|
0004de  f880208a          STRB     r2,[r0,#0x8a]
;;;293    				}
;;;294    	//---------------------------------------------------------------------------------//
;;;295    				var32c = Modify_B_ACT; 
0004e2  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;296    				var32c = var32c - Modify_A_ACT;
0004e4  9200              STR      r2,[sp,#0]
0004e6  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
0004e8  1ad2              SUBS     r2,r2,r3
;;;297    				var32c = var32c << 12;
0004ea  0312              LSLS     r2,r2,#12
;;;298    				var16a=Modify_D_READ-Modify_C_READ;
0004ec  9200              STR      r2,[sp,#0]
0004ee  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
0004f0  68a3              LDR      r3,[r4,#8]  ; Modify_C_READ
0004f2  1ad2              SUBS     r2,r2,r3
;;;299    				var16a=var16a*2;
0004f4  0052              LSLS     r2,r2,#1
0004f6  9201              STR      r2,[sp,#4]
0004f8  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;300    				var32c=var32c/var16a;
0004fc  fbb2f2f3          UDIV     r2,r2,r3
;;;301    				CLists.CSET_Load_CorrectionA_LOW = var32c;
000500  9200              STR      r2,[sp,#0]
000502  6182              STR      r2,[r0,#0x18]  ; CLists
;;;302    				var32c = Modify_B_ACT;
000504  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;303    				var32c = var32c << 12;
000506  0312              LSLS     r2,r2,#12
;;;304    				var32d = CLists.CSET_Load_CorrectionA_LOW;     //负载CC模式控制电流低档
000508  9200              STR      r2,[sp,#0]
00050a  6982              LDR      r2,[r0,#0x18]  ; CLists
;;;305    				var32d = var32d * (Modify_D_READ*2);
00050c  9201              STR      r2,[sp,#4]
00050e  6963              LDR      r3,[r4,#0x14]  ; Modify_D_READ
000510  435a              MULS     r2,r3,r2
000512  0052              LSLS     r2,r2,#1
000514  9201              STR      r2,[sp,#4]
000516  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;306    				if (var32c < var32d)
00051a  429a              CMP      r2,r3
00051c  d209              BCS      |L3.1330|
;;;307    				{
;;;308    					var32d = var32d - var32c;
00051e  461a              MOV      r2,r3
000520  9b00              LDR      r3,[sp,#0]
000522  1ad2              SUBS     r2,r2,r3
;;;309    					CLists.CSET_LoadA_Offset_LOW = var32d;    //负载CC模式控制电流参数  	
000524  9201              STR      r2,[sp,#4]
000526  65c2              STR      r2,[r0,#0x5c]  ; CLists
;;;310    					CLists.CPolar2 |= 0x04;
000528  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
00052c  f0420204          ORR      r2,r2,#4
000530  e006              B        |L3.1344|
                  |L3.1330|
;;;311    				}
;;;312    				else 
;;;313    				{
;;;314    					var32c = var32c - var32d;
000532  1ad2              SUBS     r2,r2,r3
;;;315    					CLists.CSET_LoadA_Offset_LOW = var32c;
000534  9200              STR      r2,[sp,#0]
000536  65c2              STR      r2,[r0,#0x5c]  ; CLists
;;;316    					CLists.CPolar2 &= ~0x04;
000538  f890208a          LDRB     r2,[r0,#0x8a]  ; CLists
00053c  f0220204          BIC      r2,r2,#4
                  |L3.1344|
000540  f880208a          STRB     r2,[r0,#0x8a]
;;;317    				}
;;;318    					
;;;319    				Flag_DAC_OFF =0;
000544  6832              LDR      r2,[r6,#0]  ; flagB
000546  f0220208          BIC      r2,r2,#8
00054a  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.1356|
;;;320    			}
;;;321    			
;;;322    			/*****************负载高档电流测量和控制校准*************************/
;;;323    			if (UART_Buffer_Rece[1] == 0x07)			   //CC模式校准
00054c  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000550  2a07              CMP      r2,#7
000552  d10d              BNE      |L3.1392|
;;;324    			{
;;;325    				Modify_A_READ=0;
000554  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;326    				Modify_C_READ=0;
000556  60a5              STR      r5,[r4,#8]  ; Modify_C_READ
;;;327    				Modify_A_ACT=0;
000558  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;328    				Modify_A_READ = Imon_Load_value;//
00055a  880a              LDRH     r2,[r1,#0]  ; Imon_Load_value
00055c  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;329    				Modify_C_READ = Contr_Laod;//
00055e  883a              LDRH     r2,[r7,#0]  ; Contr_Laod
000560  60a2              STR      r2,[r4,#8]  ; Modify_C_READ
;;;330    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000562  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000566  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
00056a  eb022203          ADD      r2,r2,r3,LSL #8
00056e  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1392|
;;;331    			}
;;;332    			if (UART_Buffer_Rece[1] == 0x08)			   
000570  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000574  2a08              CMP      r2,#8
000576  d172              BNE      |L3.1630|
;;;333    			{
;;;334    				vu32 var16;
;;;335    				vu32 var32a;
;;;336    				vu32 var32b;
;;;337    				
;;;338    				vu32 var16a;
;;;339    				vu32 var32c;
;;;340    				vu32 var32d;
;;;341    				Modify_B_READ=0;
000578  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;342    				Modify_D_READ=0;
00057a  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;343    				Modify_B_ACT=0;
00057c  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;344    				
;;;345    				Modify_B_READ = Imon_Load_value;
00057e  8809              LDRH     r1,[r1,#0]  ; Imon_Load_value
000580  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;346    				Modify_D_READ = Contr_Laod;
000582  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
000584  6161              STR      r1,[r4,#0x14]  ; Modify_D_READ
;;;347    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000586  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00058a  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
00058e  eb012102          ADD      r1,r1,r2,LSL #8
000592  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;348    				
;;;349    				var32a = Modify_B_ACT;
000594  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;350    				var32a = var32a - Modify_A_ACT;
000596  9100              STR      r1,[sp,#0]
000598  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
00059a  1a89              SUBS     r1,r1,r2
;;;351    				var32a = var32a << 12;
00059c  0309              LSLS     r1,r1,#12
;;;352    				var16 = Modify_B_READ - Modify_A_READ;
00059e  9100              STR      r1,[sp,#0]
0005a0  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
0005a2  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
0005a4  1a89              SUBS     r1,r1,r2
0005a6  9101              STR      r1,[sp,#4]
0005a8  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;353    				var32a = var32a / var16;
0005ac  fbb1f1f2          UDIV     r1,r1,r2
;;;354    				CLists.CREG_Load_CorrectionA_LOW = var32a;
0005b0  9100              STR      r1,[sp,#0]
0005b2  6081              STR      r1,[r0,#8]  ; CLists
;;;355    				var32a = Modify_B_ACT;
0005b4  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;356    				var32a = var32a << 12;
0005b6  0309              LSLS     r1,r1,#12
;;;357    				var32b = Modify_B_READ;
0005b8  9100              STR      r1,[sp,#0]
0005ba  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;358    				var32b = var32b * CLists.CREG_Load_CorrectionA_LOW;   //负载CC模式电流测量参数低档
0005bc  9101              STR      r1,[sp,#4]
0005be  6881              LDR      r1,[r0,#8]  ; CLists
0005c0  9a01              LDR      r2,[sp,#4]
0005c2  4351              MULS     r1,r2,r1
0005c4  9101              STR      r1,[sp,#4]
0005c6  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;359    				if (var32a < var32b)
0005ca  4291              CMP      r1,r2
0005cc  d209              BCS      |L3.1506|
;;;360    				{
;;;361    					var32b = var32b - var32a;
0005ce  4611              MOV      r1,r2
0005d0  9a00              LDR      r2,[sp,#0]
0005d2  1a89              SUBS     r1,r1,r2
;;;362    					CLists.CREG_LoadA_Offset_HIG = var32b;     //负载CC模式电流测量参数
0005d4  9101              STR      r1,[sp,#4]
0005d6  6501              STR      r1,[r0,#0x50]  ; CLists
;;;363    					CLists.CPolar3 |= 0x01;
0005d8  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
0005dc  f0410101          ORR      r1,r1,#1
0005e0  e006              B        |L3.1520|
                  |L3.1506|
;;;364    				}
;;;365    				else 
;;;366    				{
;;;367    					var32a = var32a - var32b;
0005e2  1a89              SUBS     r1,r1,r2
;;;368    					CLists.CREG_LoadA_Offset_HIG = var32a;
0005e4  9100              STR      r1,[sp,#0]
0005e6  6501              STR      r1,[r0,#0x50]  ; CLists
;;;369    					CLists.CPolar3 &= ~0x01;					
0005e8  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
0005ec  f0210101          BIC      r1,r1,#1
                  |L3.1520|
0005f0  f880108b          STRB     r1,[r0,#0x8b]
;;;370    				}
;;;371    	//---------------------------------------------------------------------------------//
;;;372    				var32c = Modify_B_ACT; 
0005f4  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;373    				var32c = var32c - Modify_A_ACT;
0005f6  9100              STR      r1,[sp,#0]
0005f8  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
0005fa  1a89              SUBS     r1,r1,r2
;;;374    				var32c = var32c << 12;
0005fc  0309              LSLS     r1,r1,#12
;;;375    				var16a=Modify_D_READ-Modify_C_READ;
0005fe  9100              STR      r1,[sp,#0]
000600  6961              LDR      r1,[r4,#0x14]  ; Modify_D_READ
000602  68a2              LDR      r2,[r4,#8]  ; Modify_C_READ
000604  1a89              SUBS     r1,r1,r2
;;;376    				var16a=var16a*2;
000606  0049              LSLS     r1,r1,#1
000608  9101              STR      r1,[sp,#4]
00060a  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;377    				var32c=var32c/var16a;
00060e  fbb1f1f2          UDIV     r1,r1,r2
;;;378    				CLists.CSET_Load_CorrectionA_HIG = var32c;
000612  9100              STR      r1,[sp,#0]
000614  61c1              STR      r1,[r0,#0x1c]  ; CLists
;;;379    				var32c = Modify_B_ACT;
000616  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;380    				var32c = var32c << 12;
000618  0309              LSLS     r1,r1,#12
;;;381    				var32d = CLists.CSET_Load_CorrectionA_HIG;  //负载CC模式电流测量参数高档
00061a  9100              STR      r1,[sp,#0]
00061c  69c1              LDR      r1,[r0,#0x1c]  ; CLists
;;;382    				var32d = var32d * (Modify_D_READ*2);
00061e  9101              STR      r1,[sp,#4]
000620  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
000622  4351              MULS     r1,r2,r1
000624  0049              LSLS     r1,r1,#1
000626  9101              STR      r1,[sp,#4]
000628  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;383    				if (var32c < var32d)
00062c  4291              CMP      r1,r2
00062e  d209              BCS      |L3.1604|
;;;384    				{
;;;385    					var32d = var32d - var32c;
000630  4611              MOV      r1,r2
000632  9a00              LDR      r2,[sp,#0]
000634  1a89              SUBS     r1,r1,r2
;;;386    					CLists.CSET_LoadA_Offset_HIG = var32d;   //负载CC模式控制电流参数
000636  9101              STR      r1,[sp,#4]
000638  6601              STR      r1,[r0,#0x60]  ; CLists
;;;387    					CLists.CPolar3 |= 0x04;
00063a  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
00063e  f0410104          ORR      r1,r1,#4
000642  e006              B        |L3.1618|
                  |L3.1604|
;;;388    				}
;;;389    				else 
;;;390    				{
;;;391    					var32c = var32c - var32d;
000644  1a89              SUBS     r1,r1,r2
;;;392    					CLists.CSET_LoadA_Offset_HIG = var32c;
000646  9100              STR      r1,[sp,#0]
000648  6601              STR      r1,[r0,#0x60]  ; CLists
;;;393    					CLists.CPolar3 &= ~0x04;
00064a  f890108b          LDRB     r1,[r0,#0x8b]  ; CLists
00064e  f0210104          BIC      r1,r1,#4
                  |L3.1618|
000652  f880108b          STRB     r1,[r0,#0x8b]
;;;394    				}
;;;395    					
;;;396    				Flag_DAC_OFF =0;
000656  6831              LDR      r1,[r6,#0]  ; flagB
000658  f0210108          BIC      r1,r1,#8
00065c  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1630|
;;;397    			}
;;;398    	/*************************负载CV模式电压控制校准低档*******************************/
;;;399    			if(UART_Buffer_Rece[1] == 0x09)
00065e  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
000662  2909              CMP      r1,#9
000664  d10b              BNE      |L3.1662|
;;;400    			{
;;;401    				Modify_A_READ=0;
000666  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;402    				Modify_C_READ=0;
000668  60a5              STR      r5,[r4,#8]  ; Modify_C_READ
;;;403    				Modify_A_ACT=0;
00066a  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;404    				Modify_C_READ = Contr_Laod;//设置电压值
00066c  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
00066e  60a1              STR      r1,[r4,#8]  ; Modify_C_READ
;;;405    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000670  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000674  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000678  eb012102          ADD      r1,r1,r2,LSL #8
00067c  60e1              STR      r1,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1662|
;;;406    			}
;;;407    			if (UART_Buffer_Rece[1] == 0x0A)			   //电压测量校准完成
00067e  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
000682  290a              CMP      r1,#0xa
000684  d140              BNE      |L3.1800|
;;;408    			{
;;;409    				vu32 var16;
;;;410    				vu32 var32a;
;;;411    				vu32 var32b;
;;;412    				
;;;413    				vu32 var16a;
;;;414    				vu32 var32c;
;;;415    				vu32 var32d;
;;;416    				
;;;417    				Modify_B_READ=0;
000686  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;418    				Modify_D_READ=0;
000688  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;419    				Modify_B_ACT=0;
00068a  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;420    			
;;;421    				Modify_D_READ =Contr_Laod;//设置电压值
00068c  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
00068e  6161              STR      r1,[r4,#0x14]  ; Modify_D_READ
;;;422    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段	
000690  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000694  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000698  eb012102          ADD      r1,r1,r2,LSL #8
00069c  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;423    				var32c = Modify_B_ACT; //CV模式电压控制校准
00069e  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;424    				var32c = var32c - Modify_A_ACT;
0006a0  9100              STR      r1,[sp,#0]
0006a2  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
0006a4  1a89              SUBS     r1,r1,r2
;;;425    				var32c = var32c << 12;
0006a6  0309              LSLS     r1,r1,#12
;;;426    				var16a=Modify_D_READ-Modify_C_READ;
0006a8  9100              STR      r1,[sp,#0]
0006aa  6961              LDR      r1,[r4,#0x14]  ; Modify_D_READ
0006ac  68a2              LDR      r2,[r4,#8]  ; Modify_C_READ
0006ae  1a89              SUBS     r1,r1,r2
;;;427    				var16a=(var16a*2);
0006b0  0049              LSLS     r1,r1,#1
0006b2  9101              STR      r1,[sp,#4]
0006b4  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;428    				var32c=var32c/var16a;
0006b8  fbb1f1f2          UDIV     r1,r1,r2
;;;429    				CLists.CSET_Load_CorrectionV_LOW = var32c;
0006bc  9100              STR      r1,[sp,#0]
0006be  6101              STR      r1,[r0,#0x10]  ; CLists
;;;430    				var32c = Modify_B_ACT;
0006c0  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;431    				var32c = var32c << 12;
0006c2  0309              LSLS     r1,r1,#12
;;;432    				var32d = CLists.CSET_Load_CorrectionV_LOW;   //负载CV模式控制电压抵挡
0006c4  9100              STR      r1,[sp,#0]
0006c6  6901              LDR      r1,[r0,#0x10]  ; CLists
;;;433    				var32d = var32d * (Modify_D_READ*2);
0006c8  9101              STR      r1,[sp,#4]
0006ca  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
0006cc  4351              MULS     r1,r2,r1
0006ce  0049              LSLS     r1,r1,#1
0006d0  9101              STR      r1,[sp,#4]
0006d2  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;434    				if (var32c < var32d)
0006d6  4291              CMP      r1,r2
0006d8  d209              BCS      |L3.1774|
;;;435    				{
;;;436    					var32d = var32d - var32c;
0006da  4611              MOV      r1,r2
0006dc  9a00              LDR      r2,[sp,#0]
0006de  1a89              SUBS     r1,r1,r2
;;;437    					CLists.CSET_LoadV_Offset_LOW = var32d;    	//负载CV模式控制电压参数   
0006e0  9101              STR      r1,[sp,#4]
0006e2  6541              STR      r1,[r0,#0x54]  ; CLists
;;;438    					CLists.CPolar1 |= 0x01;
0006e4  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
0006e8  f0410101          ORR      r1,r1,#1
0006ec  e006              B        |L3.1788|
                  |L3.1774|
;;;439    				}
;;;440    				else 
;;;441    				{
;;;442    					var32c = var32c - var32d;
0006ee  1a89              SUBS     r1,r1,r2
;;;443    					CLists.CSET_LoadV_Offset_LOW = var32c;
0006f0  9100              STR      r1,[sp,#0]
0006f2  6541              STR      r1,[r0,#0x54]  ; CLists
;;;444    					CLists.CPolar1 &= ~0x01;
0006f4  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
0006f8  f0210101          BIC      r1,r1,#1
                  |L3.1788|
0006fc  f8801089          STRB     r1,[r0,#0x89]
;;;445    				}
;;;446    					//参数写进FLASH
;;;447    				Flag_DAC_OFF=0;
000700  6831              LDR      r1,[r6,#0]  ; flagB
000702  f0210108          BIC      r1,r1,#8
000706  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1800|
;;;448    			}
;;;449    			/*************************负载CV模式电压控制校准高档*******************************/
;;;450    			if(UART_Buffer_Rece[1] == 0x0B)
000708  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
00070c  290b              CMP      r1,#0xb
00070e  d10b              BNE      |L3.1832|
;;;451    			{
;;;452    				Modify_A_READ=0;
000710  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;453    				Modify_C_READ=0;
000712  60a5              STR      r5,[r4,#8]  ; Modify_C_READ
;;;454    				Modify_A_ACT=0;
000714  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;455    				Modify_C_READ = Contr_Laod;//设置电压值
000716  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
000718  60a1              STR      r1,[r4,#8]  ; Modify_C_READ
;;;456    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
00071a  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00071e  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000722  eb012102          ADD      r1,r1,r2,LSL #8
000726  60e1              STR      r1,[r4,#0xc]  ; Modify_A_ACT
                  |L3.1832|
;;;457    			}
;;;458    			if (UART_Buffer_Rece[1] == 0x0C)			   //电压测量校准完成
000728  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
00072c  290c              CMP      r1,#0xc
00072e  d140              BNE      |L3.1970|
;;;459    			{
;;;460    				vu32 var16;
;;;461    				vu32 var32a;
;;;462    				vu32 var32b;
;;;463    				
;;;464    				vu32 var16a;
;;;465    				vu32 var32c;
;;;466    				vu32 var32d;
;;;467    				
;;;468    				Modify_B_READ=0;
000730  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;469    				Modify_D_READ=0;
000732  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;470    				Modify_B_ACT=0;
000734  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;471    			
;;;472    				Modify_D_READ =Contr_Laod;//设置电压值
000736  8839              LDRH     r1,[r7,#0]  ; Contr_Laod
000738  6161              STR      r1,[r4,#0x14]  ; Modify_D_READ
;;;473    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段	
00073a  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00073e  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000742  eb012102          ADD      r1,r1,r2,LSL #8
000746  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;474    				var32c = Modify_B_ACT; //CV模式电压控制校准
000748  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;475    				var32c = var32c - Modify_A_ACT;
00074a  9100              STR      r1,[sp,#0]
00074c  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
00074e  1a89              SUBS     r1,r1,r2
;;;476    				var32c = var32c << 12;
000750  0309              LSLS     r1,r1,#12
;;;477    				var16a=Modify_D_READ-Modify_C_READ;
000752  9100              STR      r1,[sp,#0]
000754  6961              LDR      r1,[r4,#0x14]  ; Modify_D_READ
000756  68a2              LDR      r2,[r4,#8]  ; Modify_C_READ
000758  1a89              SUBS     r1,r1,r2
;;;478    				var16a=(var16a*2);
00075a  0049              LSLS     r1,r1,#1
00075c  9101              STR      r1,[sp,#4]
00075e  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;479    				var32c=var32c/var16a;
000762  fbb1f1f2          UDIV     r1,r1,r2
;;;480    				CLists.CSET_Load_CorrectionV_LOW = var32c;
000766  9100              STR      r1,[sp,#0]
000768  6101              STR      r1,[r0,#0x10]  ; CLists
;;;481    				var32c = Modify_B_ACT;
00076a  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;482    				var32c = var32c << 12;
00076c  0309              LSLS     r1,r1,#12
;;;483    				var32d = CLists.CSET_Load_CorrectionV_HIG;      //负载CV模式控制电压高档
00076e  9100              STR      r1,[sp,#0]
000770  6941              LDR      r1,[r0,#0x14]  ; CLists
;;;484    				var32d = var32d * (Modify_D_READ*2);
000772  9101              STR      r1,[sp,#4]
000774  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
000776  4351              MULS     r1,r2,r1
000778  0049              LSLS     r1,r1,#1
00077a  9101              STR      r1,[sp,#4]
00077c  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;485    				if (var32c < var32d)
000780  4291              CMP      r1,r2
000782  d209              BCS      |L3.1944|
;;;486    				{
;;;487    					var32d = var32d - var32c;
000784  4611              MOV      r1,r2
000786  9a00              LDR      r2,[sp,#0]
000788  1a89              SUBS     r1,r1,r2
;;;488    					CLists.CSET_LoadV_Offset_HIG = var32d;
00078a  9101              STR      r1,[sp,#4]
00078c  6581              STR      r1,[r0,#0x58]  ; CLists
;;;489    					CLists.CPolar1 |= 0x04;
00078e  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
000792  f0410104          ORR      r1,r1,#4
000796  e006              B        |L3.1958|
                  |L3.1944|
;;;490    				}
;;;491    				else 
;;;492    				{
;;;493    					var32c = var32c - var32d;
000798  1a89              SUBS     r1,r1,r2
;;;494    					CLists.CSET_LoadV_Offset_HIG = var32c;      //负载CV模式控制电压参数
00079a  9100              STR      r1,[sp,#0]
00079c  6581              STR      r1,[r0,#0x58]  ; CLists
;;;495    					CLists.CPolar1 &= ~0x04;
00079e  f8901089          LDRB     r1,[r0,#0x89]  ; CLists
0007a2  f0210104          BIC      r1,r1,#4
                  |L3.1958|
0007a6  f8801089          STRB     r1,[r0,#0x89]
;;;496    				}
;;;497    					//参数写进FLASH
;;;498    				Flag_DAC_OFF=0;
0007aa  6831              LDR      r1,[r6,#0]  ; flagB
0007ac  f0210108          BIC      r1,r1,#8
0007b0  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.1970|
;;;499    			}
;;;500    	/************************内阻校准低档**********************************/
;;;501    			if(UART_Buffer_Rece[1] == 0x0D)
0007b2  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;502    			{
;;;503    				Modify_A_READ=0;
;;;504    				Modify_A_ACT=0;
;;;505    				Modify_A_READ = Rmon_value;//测量电阻值
0007b6  4921              LDR      r1,|L3.2108|
0007b8  2a0d              CMP      r2,#0xd               ;501
0007ba  d10a              BNE      |L3.2002|
0007bc  6065              STR      r5,[r4,#4]            ;503  ; Modify_A_READ
0007be  60e5              STR      r5,[r4,#0xc]          ;504  ; Modify_A_ACT
0007c0  880a              LDRH     r2,[r1,#0]  ; Rmon_value
0007c2  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;506    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0007c4  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
0007c8  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
0007cc  eb022203          ADD      r2,r2,r3,LSL #8
0007d0  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2002|
;;;507    			}
;;;508    			if (UART_Buffer_Rece[1] == 0x0E)			   
0007d2  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
0007d6  2a0e              CMP      r2,#0xe
0007d8  d147              BNE      |L3.2154|
;;;509    			{
;;;510    				vu16 var16;
;;;511    				vu32 var32a;
;;;512    				vu32 var32b;		
;;;513    				vu16 var16a;
;;;514    				vu32 var32c;
;;;515    				vu32 var32d;
;;;516    				Modify_B_READ=0;
0007da  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;517    				Modify_B_ACT=0;
0007dc  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;518    				Modify_B_READ =Rmon_value;//测量电阻值
0007de  880a              LDRH     r2,[r1,#0]  ; Rmon_value
0007e0  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;519    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
0007e2  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
0007e6  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
0007ea  eb022203          ADD      r2,r2,r3,LSL #8
0007ee  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;520    				var32a = Modify_B_ACT;
0007f0  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;521    				var32a = var32a - Modify_A_ACT;
0007f2  9200              STR      r2,[sp,#0]
0007f4  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
0007f6  1ad2              SUBS     r2,r2,r3
;;;522    				var32a = var32a << 12;
0007f8  0312              LSLS     r2,r2,#12
;;;523    				var16 = Modify_B_READ - Modify_A_READ;
0007fa  9200              STR      r2,[sp,#0]
0007fc  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
0007fe  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
000800  1ad2              SUBS     r2,r2,r3
000802  f8ad2004          STRH     r2,[sp,#4]
;;;524    				var32a = var32a / var16;
000806  f8bd3004          LDRH     r3,[sp,#4]
00080a  9a00              LDR      r2,[sp,#0]
00080c  fbb2f2f3          UDIV     r2,r2,r3
;;;525    				CLists.CREG_CorrectionR_LOW = var32a;
000810  9200              STR      r2,[sp,#0]
000812  6342              STR      r2,[r0,#0x34]  ; CLists
;;;526    				var32a=0;
;;;527    				var32a = Modify_B_ACT;
000814  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;528    				var32a = var32a << 12;
000816  0312              LSLS     r2,r2,#12
;;;529    				var32b = Modify_B_READ;
000818  9200              STR      r2,[sp,#0]
00081a  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;530    				var32b = var32b * CLists.CREG_CorrectionR_LOW;  //内阻测量参数低档
00081c  9201              STR      r2,[sp,#4]
00081e  6b42              LDR      r2,[r0,#0x34]  ; CLists
000820  9b01              LDR      r3,[sp,#4]
000822  435a              MULS     r2,r3,r2
000824  9201              STR      r2,[sp,#4]
000826  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;531    				if (var32a < var32b)
00082a  429a              CMP      r2,r3
00082c  d210              BCS      |L3.2128|
;;;532    				{
;;;533    					var32b = var32b - var32a;
00082e  461a              MOV      r2,r3
000830  9b00              LDR      r3,[sp,#0]
000832  e005              B        |L3.2112|
                  |L3.2100|
                          DCD      Imon_Load_value
                  |L3.2104|
                          DCD      Contr_Laod
                  |L3.2108|
                          DCD      Rmon_value
                  |L3.2112|
000840  1ad2              SUBS     r2,r2,r3
;;;534    					CLists.CREG_ReadR_Offset_LOW = var32b;         //内阻测量系数
000842  9201              STR      r2,[sp,#4]
000844  6782              STR      r2,[r0,#0x78]  ; CLists
;;;535    					CLists.CPolar4 |= 0x01;
000846  f890208c          LDRB     r2,[r0,#0x8c]  ; CLists
00084a  f0420201          ORR      r2,r2,#1
00084e  e006              B        |L3.2142|
                  |L3.2128|
;;;536    				}
;;;537    				else 
;;;538    				{
;;;539    					var32a = var32a - var32b;
000850  1ad2              SUBS     r2,r2,r3
;;;540    					CLists.CREG_ReadR_Offset_LOW = var32a;
000852  9200              STR      r2,[sp,#0]
000854  6782              STR      r2,[r0,#0x78]  ; CLists
;;;541    					CLists.CPolar4 &= ~0x01;
000856  f890208c          LDRB     r2,[r0,#0x8c]  ; CLists
00085a  f0220201          BIC      r2,r2,#1
                  |L3.2142|
00085e  f880208c          STRB     r2,[r0,#0x8c]
;;;542    				}
;;;543    					//参数写进FLASH
;;;544    				Flag_DAC_OFF=0;
000862  6832              LDR      r2,[r6,#0]  ; flagB
000864  f0220208          BIC      r2,r2,#8
000868  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2154|
;;;545    			}		
;;;546    			/************************内阻高档校准**********************************/
;;;547    			if(UART_Buffer_Rece[1] == 0x0F)
00086a  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
00086e  2a0f              CMP      r2,#0xf
000870  d10a              BNE      |L3.2184|
;;;548    			{
;;;549    				Modify_A_READ=0;
000872  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;550    				Modify_A_ACT=0;
000874  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;551    				Modify_A_READ = Rmon_value;//测量电阻值
000876  880a              LDRH     r2,[r1,#0]  ; Rmon_value
000878  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;552    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
00087a  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
00087e  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000882  eb022203          ADD      r2,r2,r3,LSL #8
000886  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2184|
;;;553    			}
;;;554    			if (UART_Buffer_Rece[1] == 0x10)			   
000888  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
00088c  2a10              CMP      r2,#0x10
00088e  d140              BNE      |L3.2322|
;;;555    			{
;;;556    				vu16 var16;
;;;557    				vu32 var32a;
;;;558    				vu32 var32b;		
;;;559    				vu16 var16a;
;;;560    				vu32 var32c;
;;;561    				vu32 var32d;
;;;562    				Modify_B_READ=0;
000890  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;563    				Modify_B_ACT=0;
000892  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;564    				Modify_B_READ =Rmon_value;//测量电阻值
000894  8809              LDRH     r1,[r1,#0]  ; Rmon_value
000896  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;565    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000898  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
00089c  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
0008a0  eb012102          ADD      r1,r1,r2,LSL #8
0008a4  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;566    				var32a = Modify_B_ACT;
0008a6  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;567    				var32a = var32a - Modify_A_ACT;
0008a8  9100              STR      r1,[sp,#0]
0008aa  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
0008ac  1a89              SUBS     r1,r1,r2
;;;568    				var32a = var32a << 12;
0008ae  0309              LSLS     r1,r1,#12
;;;569    				var16 = Modify_B_READ - Modify_A_READ;
0008b0  9100              STR      r1,[sp,#0]
0008b2  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
0008b4  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
0008b6  1a89              SUBS     r1,r1,r2
0008b8  f8ad1004          STRH     r1,[sp,#4]
;;;570    				var32a = var32a / var16;
0008bc  f8bd2004          LDRH     r2,[sp,#4]
0008c0  9900              LDR      r1,[sp,#0]
0008c2  fbb1f1f2          UDIV     r1,r1,r2
;;;571    				CLists.CREG_CorrectionR_HIG = var32a;
0008c6  9100              STR      r1,[sp,#0]
0008c8  6381              STR      r1,[r0,#0x38]  ; CLists
;;;572    				var32a=0;
;;;573    				var32a = Modify_B_ACT;
0008ca  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;574    				var32a = var32a << 12;
0008cc  0309              LSLS     r1,r1,#12
;;;575    				var32b = Modify_B_READ;
0008ce  9100              STR      r1,[sp,#0]
0008d0  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;576    				var32b = var32b * CLists.CREG_CorrectionR_HIG;    //内阻测量参数高档
0008d2  9101              STR      r1,[sp,#4]
0008d4  6b81              LDR      r1,[r0,#0x38]  ; CLists
0008d6  9a01              LDR      r2,[sp,#4]
0008d8  4351              MULS     r1,r2,r1
0008da  9101              STR      r1,[sp,#4]
0008dc  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;577    				if (var32a < var32b)
0008e0  4291              CMP      r1,r2
0008e2  d209              BCS      |L3.2296|
;;;578    				{
;;;579    					var32b = var32b - var32a;
0008e4  4611              MOV      r1,r2
0008e6  9a00              LDR      r2,[sp,#0]
0008e8  1a89              SUBS     r1,r1,r2
;;;580    					CLists.CREG_ReadR_Offset_HIG = var32b;     //内阻测量系数
0008ea  9101              STR      r1,[sp,#4]
0008ec  67c1              STR      r1,[r0,#0x7c]  ; CLists
;;;581    					CLists.CPolar4 |= 0x04;
0008ee  f890108c          LDRB     r1,[r0,#0x8c]  ; CLists
0008f2  f0410104          ORR      r1,r1,#4
0008f6  e006              B        |L3.2310|
                  |L3.2296|
;;;582    				}
;;;583    				else 
;;;584    				{
;;;585    					var32a = var32a - var32b;
0008f8  1a89              SUBS     r1,r1,r2
;;;586    					CLists.CREG_ReadR_Offset_HIG = var32a;
0008fa  9100              STR      r1,[sp,#0]
0008fc  67c1              STR      r1,[r0,#0x7c]  ; CLists
;;;587    					CLists.CPolar4 &= ~0x04;
0008fe  f890108c          LDRB     r1,[r0,#0x8c]  ; CLists
000902  f0210104          BIC      r1,r1,#4
                  |L3.2310|
000906  f880108c          STRB     r1,[r0,#0x8c]
;;;588    				}
;;;589    					//参数写进FLASH
;;;590    				Flag_DAC_OFF=0;
00090a  6831              LDR      r1,[r6,#0]  ; flagB
00090c  f0210108          BIC      r1,r1,#8
000910  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.2322|
;;;591    			}	
;;;592    			
;;;593    			/*******************************电源电压控制和测量校准******************************************/	
;;;594    			if (UART_Buffer_Rece[1] == 0x11)			   //电流测量校准
000912  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
;;;595    			{
;;;596    				Modify_A_READ=0;
;;;597    				Modify_C_READ=0;
;;;598    				Modify_A_ACT=0;
;;;599    				Modify_A_READ = Vmon_POWE_value;//测量电流
000916  4bfe              LDR      r3,|L3.3344|
;;;600    				Modify_C_READ = Contr_Voltage;//设置电流
000918  f8dfa3f8          LDR      r10,|L3.3348|
00091c  2911              CMP      r1,#0x11              ;594
00091e  d10e              BNE      |L3.2366|
000920  6065              STR      r5,[r4,#4]            ;596  ; Modify_A_READ
000922  60a5              STR      r5,[r4,#8]            ;597  ; Modify_C_READ
000924  60e5              STR      r5,[r4,#0xc]          ;598  ; Modify_A_ACT
000926  8819              LDRH     r1,[r3,#0]            ;599  ; Vmon_POWE_value
000928  6061              STR      r1,[r4,#4]            ;599  ; Modify_A_READ
00092a  f8ba1000          LDRH     r1,[r10,#0]  ; Contr_Voltage
00092e  60a1              STR      r1,[r4,#8]  ; Modify_C_READ
;;;601    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000930  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000934  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000938  eb012102          ADD      r1,r1,r2,LSL #8
00093c  60e1              STR      r1,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2366|
;;;602    			}
;;;603    
;;;604    			if (UART_Buffer_Rece[1] == 0x12)			   //电流测量校准完成
00093e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;605    			{
;;;606    				vu16 var16;
;;;607    				vu32 var32a;
;;;608    				vu32 var32b;
;;;609    				
;;;610    				vu16 var16a;
;;;611    				vu32 var32c;
;;;612    				vu32 var32d;
;;;613    				
;;;614    				Modify_D_READ=0;
;;;615    				Modify_B_READ=0;
;;;616    				Modify_B_ACT=0;
;;;617    				
;;;618    				Modify_D_READ = Contr_Voltage;
;;;619    				Modify_B_READ = Vmon_POWE_value;
;;;620    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
;;;621    				var32a = Modify_B_ACT;
;;;622    				var32a = var32a - Modify_A_ACT;
;;;623    				var32a = var32a << 12;
;;;624    				var16 = Modify_B_READ - Modify_A_READ;
;;;625    				var32a = var32a / var16;
;;;626    				CLists.CREG_POWER_CorrectionV = var32a;
;;;627    				var32a = Modify_B_ACT;
;;;628    				var32a = var32a << 12;
;;;629    				var32b = Modify_B_READ;
;;;630    				var32b = var32b * CLists.CREG_POWER_CorrectionV;    //电源测量电压参数
;;;631    				if (var32a < var32b)
;;;632    				{
;;;633    					var32b = var32b - var32a;
;;;634    					CLists.CREG_POWERV_Offset = var32b;     //电源CV模式电压测量参数  
;;;635    					CLists.CPolar5 |= 0x01;
;;;636    				}
;;;637    				else 
;;;638    				{
;;;639    					var32a = var32a - var32b;
;;;640    					CLists.CREG_POWERV_Offset = var32a;
;;;641    					CLists.CPolar5 &= ~0x01;					
;;;642    				}
;;;643    				var32c = Modify_B_ACT; //设置电压校准
;;;644    				var32c = var32c - Modify_A_ACT;
;;;645    				var32c = var32c << 12;
;;;646    				var16a=Modify_D_READ-Modify_C_READ;
;;;647    				var16a=var16a*2;
000942  f64f71ff          MOV      r1,#0xffff
000946  2a12              CMP      r2,#0x12              ;604
000948  d17d              BNE      |L3.2630|
00094a  6165              STR      r5,[r4,#0x14]         ;614  ; Modify_D_READ
00094c  6125              STR      r5,[r4,#0x10]         ;615  ; Modify_B_READ
00094e  61a5              STR      r5,[r4,#0x18]         ;616  ; Modify_B_ACT
000950  f8ba2000          LDRH     r2,[r10,#0]           ;618  ; Contr_Voltage
000954  6162              STR      r2,[r4,#0x14]         ;618  ; Modify_D_READ
000956  881a              LDRH     r2,[r3,#0]            ;619  ; Vmon_POWE_value
000958  6122              STR      r2,[r4,#0x10]         ;619  ; Modify_B_READ
00095a  f8982004          LDRB     r2,[r8,#4]            ;620  ; UART_Buffer_Rece
00095e  f8983003          LDRB     r3,[r8,#3]            ;620  ; UART_Buffer_Rece
000962  eb022203          ADD      r2,r2,r3,LSL #8       ;620
000966  61a2              STR      r2,[r4,#0x18]         ;620  ; Modify_B_ACT
000968  69a2              LDR      r2,[r4,#0x18]         ;621  ; Modify_B_ACT
00096a  9200              STR      r2,[sp,#0]            ;622
00096c  68e3              LDR      r3,[r4,#0xc]          ;622  ; Modify_A_ACT
00096e  1ad2              SUBS     r2,r2,r3              ;622
000970  0312              LSLS     r2,r2,#12             ;623
000972  9200              STR      r2,[sp,#0]            ;624
000974  6922              LDR      r2,[r4,#0x10]         ;624  ; Modify_B_READ
000976  6863              LDR      r3,[r4,#4]            ;624  ; Modify_A_READ
000978  1ad2              SUBS     r2,r2,r3              ;624
00097a  f8ad2004          STRH     r2,[sp,#4]            ;624
00097e  f8bd3004          LDRH     r3,[sp,#4]            ;625
000982  9a00              LDR      r2,[sp,#0]            ;625
000984  fbb2f2f3          UDIV     r2,r2,r3              ;625
000988  9200              STR      r2,[sp,#0]            ;626
00098a  6202              STR      r2,[r0,#0x20]         ;626  ; CLists
00098c  69a2              LDR      r2,[r4,#0x18]         ;627  ; Modify_B_ACT
00098e  0312              LSLS     r2,r2,#12             ;628
000990  9200              STR      r2,[sp,#0]            ;629
000992  6922              LDR      r2,[r4,#0x10]         ;629  ; Modify_B_READ
000994  9201              STR      r2,[sp,#4]            ;630
000996  6a02              LDR      r2,[r0,#0x20]         ;630  ; CLists
000998  9b01              LDR      r3,[sp,#4]            ;630
00099a  435a              MULS     r2,r3,r2              ;630
00099c  9201              STR      r2,[sp,#4]            ;630
00099e  e9dd2300          LDRD     r2,r3,[sp,#0]         ;630
0009a2  429a              CMP      r2,r3                 ;631
0009a4  d209              BCS      |L3.2490|
0009a6  461a              MOV      r2,r3                 ;633
0009a8  9b00              LDR      r3,[sp,#0]            ;633
0009aa  1ad2              SUBS     r2,r2,r3              ;633
0009ac  9201              STR      r2,[sp,#4]            ;634
0009ae  6642              STR      r2,[r0,#0x64]         ;634  ; CLists
0009b0  f890208d          LDRB     r2,[r0,#0x8d]         ;635  ; CLists
0009b4  f0420201          ORR      r2,r2,#1              ;635
0009b8  e006              B        |L3.2504|
                  |L3.2490|
0009ba  1ad2              SUBS     r2,r2,r3              ;639
0009bc  9200              STR      r2,[sp,#0]            ;640
0009be  6642              STR      r2,[r0,#0x64]         ;640  ; CLists
0009c0  f890208d          LDRB     r2,[r0,#0x8d]         ;641  ; CLists
0009c4  f0220201          BIC      r2,r2,#1              ;641
                  |L3.2504|
0009c8  f880208d          STRB     r2,[r0,#0x8d]         ;641
0009cc  69a2              LDR      r2,[r4,#0x18]         ;643  ; Modify_B_ACT
0009ce  9200              STR      r2,[sp,#0]            ;644
0009d0  68e3              LDR      r3,[r4,#0xc]          ;644  ; Modify_A_ACT
0009d2  1ad2              SUBS     r2,r2,r3              ;644
0009d4  0312              LSLS     r2,r2,#12             ;645
0009d6  9200              STR      r2,[sp,#0]            ;646
0009d8  6962              LDR      r2,[r4,#0x14]         ;646  ; Modify_D_READ
0009da  68a3              LDR      r3,[r4,#8]            ;646  ; Modify_C_READ
0009dc  1ad2              SUBS     r2,r2,r3              ;646
0009de  f8ad2004          STRH     r2,[sp,#4]            ;646
0009e2  f8bd2004          LDRH     r2,[sp,#4]
0009e6  ea010242          AND      r2,r1,r2,LSL #1
0009ea  f8ad2004          STRH     r2,[sp,#4]
;;;648    				var32c=var32c/var16a;
0009ee  f8bd3004          LDRH     r3,[sp,#4]
0009f2  9a00              LDR      r2,[sp,#0]
0009f4  fbb2f2f3          UDIV     r2,r2,r3
;;;649    				CLists.CSET_POWER_CorrectionV = var32c;
0009f8  9200              STR      r2,[sp,#0]
0009fa  62c2              STR      r2,[r0,#0x2c]  ; CLists
;;;650    				var32c = Modify_B_ACT;
0009fc  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;651    				var32c = var32c << 12;
0009fe  0312              LSLS     r2,r2,#12
;;;652    				var32d = CLists.CSET_POWER_CorrectionV;    //电源电压控制参数
000a00  9200              STR      r2,[sp,#0]
000a02  6ac2              LDR      r2,[r0,#0x2c]  ; CLists
;;;653    				var32d = var32d * (Modify_D_READ*2);
000a04  9201              STR      r2,[sp,#4]
000a06  6963              LDR      r3,[r4,#0x14]  ; Modify_D_READ
000a08  435a              MULS     r2,r3,r2
000a0a  0052              LSLS     r2,r2,#1
000a0c  9201              STR      r2,[sp,#4]
000a0e  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;654    				if (var32c < var32d)
000a12  429a              CMP      r2,r3
000a14  d20a              BCS      |L3.2604|
;;;655    				{
;;;656    					var32d = var32d - var32c;
000a16  461a              MOV      r2,r3
000a18  9b00              LDR      r3,[sp,#0]
000a1a  1ad2              SUBS     r2,r2,r3
;;;657    					CLists.CSET_POWERV_Offset = var32d;    //电源CV模式电压控制参数    
000a1c  9201              STR      r2,[sp,#4]
000a1e  6702              STR      r2,[r0,#0x70]  ; CLists
;;;658    					CLists.CPolar5 |= 0x04;
000a20  f890208d          LDRB     r2,[r0,#0x8d]  ; CLists
000a24  f0420204          ORR      r2,r2,#4
000a28  e007              B        |L3.2618|
000a2a  e00c              B        |L3.2630|
                  |L3.2604|
;;;659    				}
;;;660    				else 
;;;661    				{
;;;662    					var32c = var32c - var32d;
000a2c  1ad2              SUBS     r2,r2,r3
;;;663    					CLists.CSET_POWERV_Offset = var32c;
000a2e  9200              STR      r2,[sp,#0]
000a30  6702              STR      r2,[r0,#0x70]  ; CLists
;;;664    					CLists.CPolar5 &= ~0x04;
000a32  f890208d          LDRB     r2,[r0,#0x8d]  ; CLists
000a36  f0220204          BIC      r2,r2,#4
                  |L3.2618|
000a3a  f880208d          STRB     r2,[r0,#0x8d]
;;;665    				}
;;;666    					
;;;667    				Flag_DAC_OFF=0;
000a3e  6832              LDR      r2,[r6,#0]  ; flagB
000a40  f0220208          BIC      r2,r2,#8
000a44  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2630|
;;;668    			}
;;;669    	/*******************************电源CC模式电流测量和控制校准******************************************/	
;;;670    			if (UART_Buffer_Rece[1] == 0x13)			   //电流测量校准
000a46  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;671    			{
;;;672    				Modify_A_READ=0;
;;;673    				Modify_C_READ=0;
;;;674    				Modify_A_ACT=0;
;;;675    				Modify_A_READ = Imon_POWE_value;//测量电流
;;;676    				Modify_C_READ = Contr_Current;//设置电流
000a4a  f8df92cc          LDR      r9,|L3.3352|
000a4e  f8dfc2cc          LDR      r12,|L3.3356|
000a52  2a13              CMP      r2,#0x13              ;670
000a54  d10f              BNE      |L3.2678|
000a56  6065              STR      r5,[r4,#4]            ;672  ; Modify_A_READ
000a58  60a5              STR      r5,[r4,#8]            ;673  ; Modify_C_READ
000a5a  60e5              STR      r5,[r4,#0xc]          ;674  ; Modify_A_ACT
000a5c  f8bc2000          LDRH     r2,[r12,#0]           ;675  ; Imon_POWE_value
000a60  6062              STR      r2,[r4,#4]            ;675  ; Modify_A_READ
000a62  f8b92000          LDRH     r2,[r9,#0]  ; Contr_Current
000a66  60a2              STR      r2,[r4,#8]  ; Modify_C_READ
;;;677    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000a68  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000a6c  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000a70  eb022203          ADD      r2,r2,r3,LSL #8
000a74  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2678|
;;;678    			}
;;;679    			if (UART_Buffer_Rece[1] == 0x14)			   //电流测量校准完成
000a76  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000a7a  2a14              CMP      r2,#0x14
000a7c  d17f              BNE      |L3.2942|
;;;680    			{
;;;681    				vu16 var16;
;;;682    				vu32 var32a;
;;;683    				vu32 var32b;
;;;684    				
;;;685    				vu16 var16a;
;;;686    				vu32 var32c;
;;;687    				vu32 var32d;
;;;688    				
;;;689    				Modify_D_READ=0;
000a7e  6165              STR      r5,[r4,#0x14]  ; Modify_D_READ
;;;690    				Modify_B_READ=0;
000a80  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;691    				Modify_B_ACT=0;
000a82  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;692    				
;;;693    				Modify_D_READ = Contr_Current;
000a84  f8b92000          LDRH     r2,[r9,#0]  ; Contr_Current
000a88  6162              STR      r2,[r4,#0x14]  ; Modify_D_READ
;;;694    				Modify_B_READ = Imon_POWE_value;
000a8a  f8bc2000          LDRH     r2,[r12,#0]  ; Imon_POWE_value
000a8e  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;695    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000a90  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000a94  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000a98  eb022203          ADD      r2,r2,r3,LSL #8
000a9c  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;696    				var32a = Modify_B_ACT;
000a9e  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;697    				var32a = var32a - Modify_A_ACT;
000aa0  9200              STR      r2,[sp,#0]
000aa2  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000aa4  1ad2              SUBS     r2,r2,r3
;;;698    				var32a = var32a << 12;
000aa6  0312              LSLS     r2,r2,#12
;;;699    				var16 = Modify_B_READ - Modify_A_READ;
000aa8  9200              STR      r2,[sp,#0]
000aaa  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
000aac  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
000aae  1ad2              SUBS     r2,r2,r3
000ab0  f8ad2004          STRH     r2,[sp,#4]
;;;700    				var32a = var32a / var16;
000ab4  f8bd3004          LDRH     r3,[sp,#4]
000ab8  9a00              LDR      r2,[sp,#0]
000aba  fbb2f2f3          UDIV     r2,r2,r3
;;;701    				CLists.CREG_POWER_CorrectionA_CC = var32a;
000abe  9200              STR      r2,[sp,#0]
000ac0  6242              STR      r2,[r0,#0x24]  ; CLists
;;;702    				var32a = Modify_B_ACT;
000ac2  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;703    				var32a = var32a << 12;
000ac4  0312              LSLS     r2,r2,#12
;;;704    				var32b = Modify_B_READ;
000ac6  9200              STR      r2,[sp,#0]
000ac8  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;705    				var32b = var32b * CLists.CREG_POWER_CorrectionA_CC;    //电源CC模式电流测量参数
000aca  9201              STR      r2,[sp,#4]
000acc  6a42              LDR      r2,[r0,#0x24]  ; CLists
000ace  9b01              LDR      r3,[sp,#4]
000ad0  435a              MULS     r2,r3,r2
000ad2  9201              STR      r2,[sp,#4]
000ad4  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;706    				if (var32a < var32b)
000ad8  429a              CMP      r2,r3
000ada  d209              BCS      |L3.2800|
;;;707    				{
;;;708    					var32b = var32b - var32a;
000adc  461a              MOV      r2,r3
000ade  9b00              LDR      r3,[sp,#0]
000ae0  1ad2              SUBS     r2,r2,r3
;;;709    					CLists.CREG_POWERA_Offset_CC = var32b;    //电源CC模式电流测量参数 
000ae2  9201              STR      r2,[sp,#4]
000ae4  6682              STR      r2,[r0,#0x68]  ; CLists
;;;710    					CLists.CPolar6 |= 0x01;
000ae6  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000aea  f0420201          ORR      r2,r2,#1
000aee  e006              B        |L3.2814|
                  |L3.2800|
;;;711    				}
;;;712    				else 
;;;713    				{
;;;714    					var32a = var32a - var32b;
000af0  1ad2              SUBS     r2,r2,r3
;;;715    					CLists.CREG_POWERA_Offset_CC = var32a;
000af2  9200              STR      r2,[sp,#0]
000af4  6682              STR      r2,[r0,#0x68]  ; CLists
;;;716    					CLists.CPolar6 &= ~0x01;					//电流测量系数和零点校准完成
000af6  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000afa  f0220201          BIC      r2,r2,#1
                  |L3.2814|
000afe  f880208e          STRB     r2,[r0,#0x8e]
;;;717    				}
;;;718    				var32c = Modify_B_ACT; //设置电流校准
000b02  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;719    				var32c = var32c - Modify_A_ACT;
000b04  9200              STR      r2,[sp,#0]
000b06  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000b08  1ad2              SUBS     r2,r2,r3
;;;720    				var32c = var32c << 12;
000b0a  0312              LSLS     r2,r2,#12
;;;721    				var16a=Modify_D_READ-Modify_C_READ;
000b0c  9200              STR      r2,[sp,#0]
000b0e  6962              LDR      r2,[r4,#0x14]  ; Modify_D_READ
000b10  68a3              LDR      r3,[r4,#8]  ; Modify_C_READ
000b12  1ad2              SUBS     r2,r2,r3
000b14  f8ad2004          STRH     r2,[sp,#4]
;;;722    				var16a=var16a*2;
000b18  f8bd2004          LDRH     r2,[sp,#4]
000b1c  ea010242          AND      r2,r1,r2,LSL #1
000b20  f8ad2004          STRH     r2,[sp,#4]
;;;723    				var32c=var32c/var16a;
000b24  f8bd3004          LDRH     r3,[sp,#4]
000b28  9a00              LDR      r2,[sp,#0]
000b2a  fbb2f2f3          UDIV     r2,r2,r3
;;;724    				CLists.CSET_POWER_CorrectionA = var32c;
000b2e  9200              STR      r2,[sp,#0]
000b30  6302              STR      r2,[r0,#0x30]  ; CLists
;;;725    				var32c = Modify_B_ACT;
000b32  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;726    				var32c = var32c << 12;
000b34  0312              LSLS     r2,r2,#12
;;;727    				var32d = CLists.CSET_POWER_CorrectionA;    //电源电流控制参数
000b36  9200              STR      r2,[sp,#0]
000b38  6b02              LDR      r2,[r0,#0x30]  ; CLists
;;;728    				var32d = var32d * (Modify_D_READ*2);
000b3a  9201              STR      r2,[sp,#4]
000b3c  6963              LDR      r3,[r4,#0x14]  ; Modify_D_READ
000b3e  435a              MULS     r2,r3,r2
000b40  0052              LSLS     r2,r2,#1
000b42  9201              STR      r2,[sp,#4]
000b44  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;729    				if (var32c < var32d)
000b48  429a              CMP      r2,r3
000b4a  d20b              BCS      |L3.2916|
;;;730    				{
;;;731    					var32d = var32d - var32c;
000b4c  461a              MOV      r2,r3
000b4e  9b00              LDR      r3,[sp,#0]
000b50  1ad2              SUBS     r2,r2,r3
;;;732    					CLists.CSET_POWERA_Offset = var32d;    //电源CC模式电流控制参数 
000b52  9201              STR      r2,[sp,#4]
000b54  6742              STR      r2,[r0,#0x74]  ; CLists
;;;733    					CLists.CPolar6 |= 0x04;
000b56  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000b5a  f0420204          ORR      r2,r2,#4
000b5e  e008              B        |L3.2930|
000b60  e00d              B        |L3.2942|
                  |L3.2914|
000b62  e156              B        |L3.3602|
                  |L3.2916|
;;;734    				}
;;;735    				else 
;;;736    				{
;;;737    					var32c = var32c - var32d;
000b64  1ad2              SUBS     r2,r2,r3
;;;738    					CLists.CSET_POWERA_Offset = var32c;
000b66  9200              STR      r2,[sp,#0]
000b68  6742              STR      r2,[r0,#0x74]  ; CLists
;;;739    					CLists.CPolar6 &= ~0x04;
000b6a  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000b6e  f0220204          BIC      r2,r2,#4
                  |L3.2930|
000b72  f880208e          STRB     r2,[r0,#0x8e]
;;;740    				}
;;;741    				
;;;742    				Flag_DAC_OFF=0;
000b76  6832              LDR      r2,[r6,#0]  ; flagB
000b78  f0220208          BIC      r2,r2,#8
000b7c  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2942|
;;;743    			}
;;;744    	
;;;745    	/****************电源CV电流测量校准**********************************/
;;;746    			if (UART_Buffer_Rece[1] == 0x15)			  
000b7e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000b82  2a15              CMP      r2,#0x15
000b84  d10b              BNE      |L3.2974|
;;;747    			{ 
;;;748    				Modify_A_READ=0;
000b86  6065              STR      r5,[r4,#4]  ; Modify_A_READ
;;;749    				Modify_A_ACT=0;
000b88  60e5              STR      r5,[r4,#0xc]  ; Modify_A_ACT
;;;750    				Modify_A_READ = Imon_POWE_value;
000b8a  f8bc2000          LDRH     r2,[r12,#0]  ; Imon_POWE_value
000b8e  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;751    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000b90  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000b94  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000b98  eb022203          ADD      r2,r2,r3,LSL #8
000b9c  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.2974|
;;;752    			}
;;;753    
;;;754    			if (UART_Buffer_Rece[1] == 0x16)			   
000b9e  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000ba2  2a16              CMP      r2,#0x16
000ba4  d141              BNE      |L3.3114|
;;;755    			{
;;;756    				vu16 var16;
;;;757    				vu32 var32a;
;;;758    				vu32 var32b;
;;;759    				
;;;760    				vu16 var16a;
;;;761    				vu32 var32c;
;;;762    				vu32 var32d;
;;;763    				
;;;764    				Modify_B_READ=0;
000ba6  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;765    				Modify_B_ACT=0;
000ba8  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;766    				Modify_B_READ = Imon_POWE_value;
000baa  f8bc2000          LDRH     r2,[r12,#0]  ; Imon_POWE_value
000bae  6122              STR      r2,[r4,#0x10]  ; Modify_B_READ
;;;767    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000bb0  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000bb4  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000bb8  eb022203          ADD      r2,r2,r3,LSL #8
000bbc  61a2              STR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;768    				var32a = Modify_B_ACT;
000bbe  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;769    				var32a = var32a - Modify_A_ACT;
000bc0  9200              STR      r2,[sp,#0]
000bc2  68e3              LDR      r3,[r4,#0xc]  ; Modify_A_ACT
000bc4  1ad2              SUBS     r2,r2,r3
;;;770    				var32a = var32a << 12;
000bc6  0312              LSLS     r2,r2,#12
;;;771    				var16 = Modify_B_READ - Modify_A_READ;
000bc8  9200              STR      r2,[sp,#0]
000bca  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
000bcc  6863              LDR      r3,[r4,#4]  ; Modify_A_READ
000bce  1ad2              SUBS     r2,r2,r3
000bd0  f8ad2004          STRH     r2,[sp,#4]
;;;772    				var32a = var32a / var16;
000bd4  f8bd3004          LDRH     r3,[sp,#4]
000bd8  9a00              LDR      r2,[sp,#0]
000bda  fbb2f2f3          UDIV     r2,r2,r3
;;;773    				CLists.CREG_POWER_CorrectionA_CV = var32a;
000bde  9200              STR      r2,[sp,#0]
000be0  6282              STR      r2,[r0,#0x28]  ; CLists
;;;774    				var32a = Modify_B_ACT;
000be2  69a2              LDR      r2,[r4,#0x18]  ; Modify_B_ACT
;;;775    				var32a = var32a << 12;
000be4  0312              LSLS     r2,r2,#12
;;;776    				var32b = Modify_B_READ;
000be6  9200              STR      r2,[sp,#0]
000be8  6922              LDR      r2,[r4,#0x10]  ; Modify_B_READ
;;;777    				var32b = var32b * CLists.CREG_POWER_CorrectionA_CV;   //电源CV模式电流测量参数
000bea  9201              STR      r2,[sp,#4]
000bec  6a82              LDR      r2,[r0,#0x28]  ; CLists
000bee  9b01              LDR      r3,[sp,#4]
000bf0  435a              MULS     r2,r3,r2
000bf2  9201              STR      r2,[sp,#4]
000bf4  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;778    				if (var32a < var32b)
000bf8  429a              CMP      r2,r3
000bfa  d209              BCS      |L3.3088|
;;;779    				{
;;;780    					var32b = var32b - var32a;
000bfc  461a              MOV      r2,r3
000bfe  9b00              LDR      r3,[sp,#0]
000c00  1ad2              SUBS     r2,r2,r3
;;;781    					CLists.CREG_POWERA_Offset_CV = var32b;   //电源CC模式电流测量参数
000c02  9201              STR      r2,[sp,#4]
000c04  66c2              STR      r2,[r0,#0x6c]  ; CLists
;;;782    					CLists.CPolar6 |= 0x08;
000c06  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000c0a  f0420208          ORR      r2,r2,#8
000c0e  e006              B        |L3.3102|
                  |L3.3088|
;;;783    				}
;;;784    				else 
;;;785    				{
;;;786    					var32a = var32a - var32b;
000c10  1ad2              SUBS     r2,r2,r3
;;;787    					CLists.CREG_POWERA_Offset_CV = var32a;
000c12  9200              STR      r2,[sp,#0]
000c14  66c2              STR      r2,[r0,#0x6c]  ; CLists
;;;788    					CLists.CPolar6 &= ~0x08;					
000c16  f890208e          LDRB     r2,[r0,#0x8e]  ; CLists
000c1a  f0220208          BIC      r2,r2,#8
                  |L3.3102|
000c1e  f880208e          STRB     r2,[r0,#0x8e]
;;;789    				}
;;;790    					
;;;791    				Flag_DAC_OFF=0;
000c22  6832              LDR      r2,[r6,#0]  ; flagB
000c24  f0220208          BIC      r2,r2,#8
000c28  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.3114|
;;;792    			}
;;;793    	/****************************识别电阻1校准*****************************************/
;;;794    			if(UART_Buffer_Rece[1] == 0x17)
000c2a  f8983001          LDRB     r3,[r8,#1]  ; UART_Buffer_Rece
;;;795    			{
;;;796    				Modify_A_READ=0;
;;;797    				Modify_A_ACT=0;
;;;798    				//Modify_A_READ = R1mon_value;//测量电压值
;;;799    				Modify_A_READ=(R1mon_value*1000)/(65535-R1mon_value);
000c2e  4a3c              LDR      r2,|L3.3360|
000c30  2b17              CMP      r3,#0x17              ;794
000c32  d114              BNE      |L3.3166|
000c34  6065              STR      r5,[r4,#4]            ;796  ; Modify_A_READ
000c36  60e5              STR      r5,[r4,#0xc]          ;797  ; Modify_A_ACT
000c38  8813              LDRH     r3,[r2,#0]  ; R1mon_value
000c3a  f44f7c7a          MOV      r12,#0x3e8
000c3e  fb03f30c          MUL      r3,r3,r12
000c42  f8b2c000          LDRH     r12,[r2,#0]  ; R1mon_value
000c46  eba10c0c          SUB      r12,r1,r12
000c4a  fbb3f3fc          UDIV     r3,r3,r12
000c4e  6063              STR      r3,[r4,#4]  ; Modify_A_READ
;;;800    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000c50  f8983004          LDRB     r3,[r8,#4]  ; UART_Buffer_Rece
000c54  f898c003          LDRB     r12,[r8,#3]  ; UART_Buffer_Rece
000c58  eb03230c          ADD      r3,r3,r12,LSL #8
000c5c  60e3              STR      r3,[r4,#0xc]  ; Modify_A_ACT
                  |L3.3166|
;;;801    			}
;;;802    			if (UART_Buffer_Rece[1] == 0x18)			   //电压测量校准完成
000c5e  f8983001          LDRB     r3,[r8,#1]  ; UART_Buffer_Rece
000c62  2b18              CMP      r3,#0x18
000c64  d14a              BNE      |L3.3324|
;;;803    			{
;;;804    				vu16 var16;
;;;805    				vu32 var32a;
;;;806    				vu32 var32b;
;;;807    				
;;;808    				vu16 var16a;
;;;809    				vu32 var32c;
;;;810    				vu32 var32d;
;;;811    				Modify_B_READ=0;
000c66  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;812    				Modify_B_ACT=0;
000c68  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;813    				//Modify_B_READ =R1mon_value;//测量电压值
;;;814    				Modify_B_READ=(R1mon_value*1000)/(65535-R1mon_value);
000c6a  8813              LDRH     r3,[r2,#0]  ; R1mon_value
000c6c  f44f7c7a          MOV      r12,#0x3e8
000c70  8812              LDRH     r2,[r2,#0]  ; R1mon_value
000c72  fb03f30c          MUL      r3,r3,r12
000c76  1a89              SUBS     r1,r1,r2
000c78  fbb3f1f1          UDIV     r1,r3,r1
000c7c  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;815    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000c7e  f8981004          LDRB     r1,[r8,#4]  ; UART_Buffer_Rece
000c82  f8982003          LDRB     r2,[r8,#3]  ; UART_Buffer_Rece
000c86  eb012102          ADD      r1,r1,r2,LSL #8
000c8a  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;816    				var32a = Modify_B_ACT;
000c8c  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;817    				var32a = var32a - Modify_A_ACT;
000c8e  9100              STR      r1,[sp,#0]
000c90  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
000c92  1a89              SUBS     r1,r1,r2
;;;818    				var32a = var32a << 12;
000c94  0309              LSLS     r1,r1,#12
;;;819    				var16 = Modify_B_READ - Modify_A_READ;
000c96  9100              STR      r1,[sp,#0]
000c98  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
000c9a  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
000c9c  1a89              SUBS     r1,r1,r2
000c9e  f8ad1004          STRH     r1,[sp,#4]
;;;820    				var32a = var32a / var16;
000ca2  f8bd2004          LDRH     r2,[sp,#4]
000ca6  9900              LDR      r1,[sp,#0]
000ca8  fbb1f1f2          UDIV     r1,r1,r2
;;;821    				CLists.CREG_CorrectionR1 = var32a;     //识别电阻1参数
000cac  9100              STR      r1,[sp,#0]
000cae  63c1              STR      r1,[r0,#0x3c]  ; CLists
;;;822    				var32a=0;
;;;823    				var32a = Modify_B_ACT;
000cb0  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;824    				var32a = var32a << 12;
000cb2  0309              LSLS     r1,r1,#12
;;;825    				var32b = Modify_B_READ;
000cb4  9100              STR      r1,[sp,#0]
000cb6  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;826    				var32b = var32b * CLists.CREG_CorrectionR1;
000cb8  9101              STR      r1,[sp,#4]
000cba  6bc1              LDR      r1,[r0,#0x3c]  ; CLists
000cbc  9a01              LDR      r2,[sp,#4]
000cbe  4351              MULS     r1,r2,r1
000cc0  9101              STR      r1,[sp,#4]
000cc2  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;827    				if (var32a < var32b)
000cc6  4291              CMP      r1,r2
000cc8  d20a              BCS      |L3.3296|
;;;828    				{
;;;829    					var32b = var32b - var32a;
000cca  4611              MOV      r1,r2
000ccc  9a00              LDR      r2,[sp,#0]
000cce  1a89              SUBS     r1,r1,r2
;;;830    					CLists.CREG_ReadR1_Offset = var32b;    //内阻测量系数
000cd0  9101              STR      r1,[sp,#4]
000cd2  f8c01080          STR      r1,[r0,#0x80]  ; CLists
;;;831    					CLists.CPolar7 |= 0x01;
000cd6  f890108f          LDRB     r1,[r0,#0x8f]  ; CLists
000cda  f0410101          ORR      r1,r1,#1
000cde  e007              B        |L3.3312|
                  |L3.3296|
;;;832    				}
;;;833    				else 
;;;834    				{
;;;835    					var32a = var32a - var32b;
000ce0  1a89              SUBS     r1,r1,r2
;;;836    					CLists.CREG_ReadR1_Offset = var32a;
000ce2  9100              STR      r1,[sp,#0]
000ce4  f8c01080          STR      r1,[r0,#0x80]  ; CLists
;;;837    					CLists.CPolar7 &= ~0x01;
000ce8  f890108f          LDRB     r1,[r0,#0x8f]  ; CLists
000cec  f0210101          BIC      r1,r1,#1
                  |L3.3312|
000cf0  f880108f          STRB     r1,[r0,#0x8f]
;;;838    				}
;;;839    					//参数写进FLASH
;;;840    				Flag_DAC_OFF=0;
000cf4  6831              LDR      r1,[r6,#0]  ; flagB
000cf6  f0210108          BIC      r1,r1,#8
000cfa  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.3324|
;;;841    			}	
;;;842    			/***************************识别电阻2校准**************************************/
;;;843    			if(UART_Buffer_Rece[1] == 0x19)
000cfc  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
;;;844    			{
;;;845    				Modify_A_READ=0;
;;;846    				Modify_A_ACT=0;
;;;847    				Modify_A_READ = R2mon_value;//测量电压值
000d00  4908              LDR      r1,|L3.3364|
000d02  2a19              CMP      r2,#0x19              ;843
000d04  d117              BNE      |L3.3382|
000d06  6065              STR      r5,[r4,#4]            ;845  ; Modify_A_READ
000d08  60e5              STR      r5,[r4,#0xc]          ;846  ; Modify_A_ACT
000d0a  880a              LDRH     r2,[r1,#0]  ; R2mon_value
000d0c  6062              STR      r2,[r4,#4]  ; Modify_A_READ
;;;848    				Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000d0e  e00b              B        |L3.3368|
                  |L3.3344|
                          DCD      Vmon_POWE_value
                  |L3.3348|
                          DCD      Contr_Voltage
                  |L3.3352|
                          DCD      Contr_Current
                  |L3.3356|
                          DCD      Imon_POWE_value
                  |L3.3360|
                          DCD      R1mon_value
                  |L3.3364|
                          DCD      R2mon_value
                  |L3.3368|
000d28  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000d2c  f8983003          LDRB     r3,[r8,#3]  ; UART_Buffer_Rece
000d30  eb022203          ADD      r2,r2,r3,LSL #8
000d34  60e2              STR      r2,[r4,#0xc]  ; Modify_A_ACT
                  |L3.3382|
;;;849    			}
;;;850    			if (UART_Buffer_Rece[1] == 0x1A)			   //电压测量校准完成
000d36  f8982001          LDRB     r2,[r8,#1]  ; UART_Buffer_Rece
000d3a  2a1a              CMP      r2,#0x1a
000d3c  d13f              BNE      |L3.3518|
;;;851    			{
;;;852    				vu16 var16;
;;;853    				vu32 var32a;
;;;854    				vu32 var32b;
;;;855    				
;;;856    				vu16 var16a;
;;;857    				vu32 var32c;
;;;858    				vu32 var32d;
;;;859    				Modify_B_READ=0;
000d3e  6125              STR      r5,[r4,#0x10]  ; Modify_B_READ
;;;860    				Modify_B_ACT=0;
000d40  61a5              STR      r5,[r4,#0x18]  ; Modify_B_ACT
;;;861    				Modify_B_READ =R2mon_value;//测量电压值
000d42  8809              LDRH     r1,[r1,#0]  ; R2mon_value
000d44  6121              STR      r1,[r4,#0x10]  ; Modify_B_READ
;;;862    				Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000d46  f8982004          LDRB     r2,[r8,#4]  ; UART_Buffer_Rece
000d4a  f8981003          LDRB     r1,[r8,#3]  ; UART_Buffer_Rece
000d4e  eb022101          ADD      r1,r2,r1,LSL #8
000d52  61a1              STR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;863    				var32a = Modify_B_ACT;
000d54  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;864    				var32a = var32a - Modify_A_ACT;
000d56  9100              STR      r1,[sp,#0]
000d58  68e2              LDR      r2,[r4,#0xc]  ; Modify_A_ACT
000d5a  1a89              SUBS     r1,r1,r2
;;;865    				var32a = var32a << 12;
000d5c  0309              LSLS     r1,r1,#12
;;;866    				var16 = Modify_B_READ - Modify_A_READ;
000d5e  9100              STR      r1,[sp,#0]
000d60  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
000d62  6862              LDR      r2,[r4,#4]  ; Modify_A_READ
000d64  1a89              SUBS     r1,r1,r2
000d66  f8ad1004          STRH     r1,[sp,#4]
;;;867    				var32a = var32a / var16;
000d6a  f8bd2004          LDRH     r2,[sp,#4]
000d6e  9900              LDR      r1,[sp,#0]
000d70  fbb1f1f2          UDIV     r1,r1,r2
;;;868    				CLists.CREG_CorrectionR2 = var32a;
000d74  9100              STR      r1,[sp,#0]
000d76  6401              STR      r1,[r0,#0x40]  ; CLists
;;;869    				var32a=0;
;;;870    				var32a = Modify_B_ACT;
000d78  69a1              LDR      r1,[r4,#0x18]  ; Modify_B_ACT
;;;871    				var32a = var32a << 12;
000d7a  0309              LSLS     r1,r1,#12
;;;872    				var32b = Modify_B_READ;
000d7c  9100              STR      r1,[sp,#0]
000d7e  6921              LDR      r1,[r4,#0x10]  ; Modify_B_READ
;;;873    				var32b = var32b * CLists.CREG_CorrectionR2;    	//识别电阻2参数    
000d80  9101              STR      r1,[sp,#4]
000d82  6c01              LDR      r1,[r0,#0x40]  ; CLists
000d84  9a01              LDR      r2,[sp,#4]
000d86  4351              MULS     r1,r2,r1
000d88  9101              STR      r1,[sp,#4]
000d8a  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;874    				if (var32a < var32b)
000d8e  4291              CMP      r1,r2
000d90  d209              BCS      |L3.3494|
;;;875    				{
;;;876    					var32b = var32b - var32a;
000d92  4611              MOV      r1,r2
000d94  9a00              LDR      r2,[sp,#0]
000d96  1a89              SUBS     r1,r1,r2
;;;877    					CLists.CREG_ReadR2_Offset = var32b;    //内阻测量系数  
000d98  9101              STR      r1,[sp,#4]
000d9a  f8401f84          STR      r1,[r0,#0x84]!  ; CLists
;;;878    					CLists.CPolar7 |= 0x04;
000d9e  7ac1              LDRB     r1,[r0,#0xb]  ; CLists
000da0  f0410104          ORR      r1,r1,#4
000da4  e006              B        |L3.3508|
                  |L3.3494|
;;;879    				}
;;;880    				else 
;;;881    				{
;;;882    					var32a = var32a - var32b;
000da6  1a89              SUBS     r1,r1,r2
;;;883    					CLists.CREG_ReadR2_Offset = var32a;
000da8  9100              STR      r1,[sp,#0]
000daa  f8401f84          STR      r1,[r0,#0x84]!  ; CLists
;;;884    					CLists.CPolar7 &= ~0x04;
000dae  7ac1              LDRB     r1,[r0,#0xb]  ; CLists
000db0  f0210104          BIC      r1,r1,#4
                  |L3.3508|
000db4  72c1              STRB     r1,[r0,#0xb]
;;;885    				}
;;;886    					//参数写进FLASH
;;;887    				Flag_DAC_OFF=0;
000db6  6830              LDR      r0,[r6,#0]  ; flagB
000db8  f0200008          BIC      r0,r0,#8
000dbc  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.3518|
;;;888    			}	
;;;889    	
;;;890    			Write_Flash_Bytes();
000dbe  f7fffffe          BL       Write_Flash_Bytes
;;;891    			
;;;892    	/***********接受DAC*******************************************/
;;;893    			if (UART_Buffer_Rece[1] == 0x1B)			   
000dc2  f8981001          LDRB     r1,[r8,#1]  ; UART_Buffer_Rece
000dc6  4640              MOV      r0,r8
000dc8  291b              CMP      r1,#0x1b
000dca  d108              BNE      |L3.3550|
;;;894    			{
;;;895    				Contr_Laod = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000dcc  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000dce  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
000dd0  eb012102          ADD      r1,r1,r2,LSL #8
000dd4  8039              STRH     r1,[r7,#0]
;;;896    				Flag_DAC_OFF=1;
000dd6  6831              LDR      r1,[r6,#0]  ; flagB
000dd8  f0410108          ORR      r1,r1,#8
000ddc  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.3550|
;;;897    			}
;;;898    			if (UART_Buffer_Rece[1] == 0x1C)			   
000dde  7841              LDRB     r1,[r0,#1]  ; UART_Buffer_Rece
000de0  291c              CMP      r1,#0x1c
000de2  d109              BNE      |L3.3576|
;;;899    			{
;;;900    				Contr_Voltage = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000de4  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000de6  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
000de8  eb012102          ADD      r1,r1,r2,LSL #8
000dec  f8aa1000          STRH     r1,[r10,#0]
;;;901    				Flag_DAC_OFF=1;
000df0  6831              LDR      r1,[r6,#0]  ; flagB
000df2  f0410108          ORR      r1,r1,#8
000df6  6031              STR      r1,[r6,#0]  ; flagB
                  |L3.3576|
;;;902    			}
;;;903    			if (UART_Buffer_Rece[1] == 0x1D)			   
000df8  7841              LDRB     r1,[r0,#1]  ; UART_Buffer_Rece
000dfa  291d              CMP      r1,#0x1d
000dfc  d109              BNE      |L3.3602|
;;;904    			{
;;;905    				Contr_Current = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000dfe  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000e00  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
000e02  eb012000          ADD      r0,r1,r0,LSL #8
000e06  f8a90000          STRH     r0,[r9,#0]
;;;906    				Flag_DAC_OFF=1;
000e0a  6830              LDR      r0,[r6,#0]  ; flagB
000e0c  f0400008          ORR      r0,r0,#8
000e10  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.3602|
;;;907    			}
;;;908    		}
;;;909    //===================================================================================
;;;910    	}
;;;911    }
000e12  e8bd9fff          POP      {r0-r12,pc}
;;;912    //===============================AD值转换成测量值============================================//
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        68

                          AREA ||area_number.6||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.bss||
                  Correct_Strong
                          %        68

                          AREA ||area_number.7||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.bss||
                  Run_Control
                          %        68

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  ADDR
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  Modify_A_READ
                          DCD      0x00000000
                  Modify_C_READ
                          DCD      0x00000000
                  Modify_A_ACT
                          DCD      0x00000000
                  Modify_B_READ
                          DCD      0x00000000
                  Modify_D_READ
                          DCD      0x00000000
                  Modify_B_ACT
                          DCD      0x00000000

                          AREA ||area_number.12||, DATA, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.data||
                  correct_por
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 144
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
