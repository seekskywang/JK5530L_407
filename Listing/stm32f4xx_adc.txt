; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_adc.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_adc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_adc.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;454      */
;;;455    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  6842              LDR      r2,[r0,#4]
;;;456    {
;;;457      uint32_t tmpreg = 0;
;;;458      /* Check the parameters */
;;;459      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;460      assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;461      
;;;462      /* Get the old register value */
;;;463      tmpreg = ADCx->CR1;
;;;464      
;;;465      /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;466      tmpreg &= CR1_AWDMode_RESET;
000002  4b02              LDR      r3,|L1.12|
000004  401a              ANDS     r2,r2,r3
;;;467      
;;;468      /* Set the analog watchdog enable mode */
;;;469      tmpreg |= ADC_AnalogWatchdog;
000006  430a              ORRS     r2,r2,r1
;;;470      
;;;471      /* Store the new register value */
;;;472      ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;473    }
00000a  4770              BX       lr
;;;474    
                          ENDP

                  |L1.12|
                          DCD      0xff3ffdff

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;524      */
;;;525    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  6842              LDR      r2,[r0,#4]
;;;526    {
;;;527      uint32_t tmpreg = 0;
;;;528      /* Check the parameters */
;;;529      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;530      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;531      
;;;532      /* Get the old register value */
;;;533      tmpreg = ADCx->CR1;
;;;534      
;;;535      /* Clear the Analog watchdog channel select bits */
;;;536      tmpreg &= CR1_AWDCH_RESET;
000002  f022021f          BIC      r2,r2,#0x1f
;;;537      
;;;538      /* Set the Analog watchdog channel */
;;;539      tmpreg |= ADC_Channel;
000006  430a              ORRS     r2,r2,r1
;;;540      
;;;541      /* Store the new register value */
;;;542      ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;543    }
00000a  4770              BX       lr
;;;544    /**
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;483      */
;;;484    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  6241              STR      r1,[r0,#0x24]
;;;485                                            uint16_t LowThreshold)
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;489      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;490      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;491      
;;;492      /* Set the ADCx high threshold */
;;;493      ADCx->HTR = HighThreshold;
;;;494      
;;;495      /* Set the ADCx low threshold */
;;;496      ADCx->LTR = LowThreshold;
000002  6282              STR      r2,[r0,#0x28]
;;;497    }
000004  4770              BX       lr
;;;498    
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;1422     */
;;;1423   void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1424   {
;;;1425     /* Check the parameters */
;;;1426     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1427     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1428     if (NewState != DISABLE)
;;;1429     {
;;;1430       /* Enable the selected ADC automatic injected group conversion */
;;;1431       ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
;;;1432     }
;;;1433     else
;;;1434     {
;;;1435       /* Disable the selected ADC automatic injected group conversion */
;;;1436       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L4.12|
000006  f4416180          ORR      r1,r1,#0x400          ;1431
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L4.16|
000010  6041              STR      r1,[r0,#4]            ;1431
;;;1437     }
;;;1438   }
000012  4770              BX       lr
;;;1439   
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;1655     */
;;;1656   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  43c9              MVNS     r1,r1
;;;1657   {
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1660     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1661   
;;;1662     /* Clear the selected ADC flags */
;;;1663     ADCx->SR = ~(uint32_t)ADC_FLAG;
000002  6001              STR      r1,[r0,#0]
;;;1664   }
000004  4770              BX       lr
;;;1665   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;1717     */
;;;1718   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  ea6f2111          MVN      r1,r1,LSR #8
;;;1719   {
;;;1720     uint8_t itmask = 0;
;;;1721     /* Check the parameters */
;;;1722     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1723     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1724     /* Get the ADC IT index */
;;;1725     itmask = (uint8_t)(ADC_IT >> 8);
;;;1726     /* Clear the selected ADC interrupt pending bits */
;;;1727     ADCx->SR = ~(uint32_t)itmask;
000004  6001              STR      r1,[r0,#0]
;;;1728   }                    
000006  4770              BX       lr
;;;1729   /**
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;398      */
;;;399    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Set the ADON bit to wake up the ADC from power down mode */
;;;407        ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the selected ADC peripheral */
;;;412        ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;407
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  6081              STR      r1,[r0,#8]            ;407
;;;413      }
;;;414    }
000012  4770              BX       lr
;;;415    /**
                          ENDP


                          AREA ||i.ADC_CommonInit||, CODE, READONLY, ALIGN=2

                  ADC_CommonInit PROC
;;;340      */
;;;341    void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000000  4b08              LDR      r3,|L8.36|
;;;342    {
000002  b510              PUSH     {r4,lr}
;;;343      uint32_t tmpreg1 = 0;
;;;344      /* Check the parameters */
;;;345      assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
;;;346      assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
;;;347      assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
;;;348      assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
;;;349      /*---------------------------- ADC CCR Configuration -----------------*/
;;;350      /* Get the ADC CCR value */
;;;351      tmpreg1 = ADC->CCR;
000004  f8d32304          LDR      r2,[r3,#0x304]
;;;352      
;;;353      /* Clear MULTI, DELAY, DMA and ADCPRE bits */
;;;354      tmpreg1 &= CR_CLEAR_MASK;
000008  4907              LDR      r1,|L8.40|
00000a  400a              ANDS     r2,r2,r1
00000c  e9d01400          LDRD     r1,r4,[r0,#0]
;;;355      
;;;356      /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
;;;357         and DMA access mode for multimode */
;;;358      /* Set MULTI bits according to ADC_Mode value */
;;;359      /* Set ADCPRE bits according to ADC_Prescaler value */
;;;360      /* Set DMA bits according to ADC_DMAAccessMode value */
;;;361      /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
;;;362      tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
000010  4321              ORRS     r1,r1,r4
000012  e9d04002          LDRD     r4,r0,[r0,#8]
000016  4304              ORRS     r4,r4,r0
000018  4321              ORRS     r1,r1,r4
00001a  4311              ORRS     r1,r1,r2
;;;363                            ADC_CommonInitStruct->ADC_Prescaler | 
;;;364                            ADC_CommonInitStruct->ADC_DMAAccessMode | 
;;;365                            ADC_CommonInitStruct->ADC_TwoSamplingDelay);
;;;366                            
;;;367      /* Write to ADC CCR */
;;;368      ADC->CCR = tmpreg1;
00001c  f8c31304          STR      r1,[r3,#0x304]
;;;369    }
000020  bd10              POP      {r4,pc}
;;;370    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40012000
                  |L8.40|
                          DCD      0xfffc30e0

                          AREA ||i.ADC_CommonStructInit||, CODE, READONLY, ALIGN=1

                  ADC_CommonStructInit PROC
;;;376      */
;;;377    void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000000  2100              MOVS     r1,#0
;;;378    {
;;;379      /* Initialize the ADC_Mode member */
;;;380      ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
;;;381    
;;;382      /* initialize the ADC_Prescaler member */
;;;383      ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
000002  6001              STR      r1,[r0,#0]
;;;384    
;;;385      /* Initialize the ADC_DMAAccessMode member */
;;;386      ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
000004  6041              STR      r1,[r0,#4]
;;;387    
;;;388      /* Initialize the ADC_TwoSamplingDelay member */
;;;389      ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;390    }
00000a  4770              BX       lr
;;;391    
                          ENDP


                          AREA ||i.ADC_ContinuousModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_ContinuousModeCmd PROC
;;;903      */
;;;904    void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;905    {
;;;906      /* Check the parameters */
;;;907      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;908      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;909      
;;;910      if (NewState != DISABLE)
;;;911      {
;;;912        /* Enable the selected ADC continuous conversion mode */
;;;913        ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
;;;914      }
;;;915      else
;;;916      {
;;;917        /* Disable the selected ADC continuous conversion mode */
;;;918        ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L10.12|
000006  f0410102          ORR      r1,r1,#2              ;913
00000a  e001              B        |L10.16|
                  |L10.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L10.16|
000010  6081              STR      r1,[r0,#8]            ;913
;;;919      }
;;;920    }
000012  4770              BX       lr
;;;921    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;1051     */
;;;1052   void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1056     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1057     if (NewState != DISABLE)
;;;1058     {
;;;1059       /* Enable the selected ADC DMA request */
;;;1060       ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
;;;1061     }
;;;1062     else
;;;1063     {
;;;1064       /* Disable the selected ADC DMA request */
;;;1065       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L11.12|
000006  f4417180          ORR      r1,r1,#0x100          ;1060
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L11.16|
000010  6081              STR      r1,[r0,#8]            ;1060
;;;1066     }
;;;1067   }
000012  4770              BX       lr
;;;1068   
                          ENDP


                          AREA ||i.ADC_DMARequestAfterLastTransferCmd||, CODE, READONLY, ALIGN=1

                  ADC_DMARequestAfterLastTransferCmd PROC
;;;1075     */
;;;1076   void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1077   {
;;;1078     /* Check the parameters */
;;;1079     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1080     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1081     if (NewState != DISABLE)
;;;1082     {
;;;1083       /* Enable the selected ADC DMA request after last transfer */
;;;1084       ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
;;;1085     }
;;;1086     else
;;;1087     {
;;;1088       /* Disable the selected ADC DMA request after last transfer */
;;;1089       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L12.12|
000006  f4417100          ORR      r1,r1,#0x200          ;1084
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  f4217100          BIC      r1,r1,#0x200
                  |L12.16|
000010  6081              STR      r1,[r0,#8]            ;1084
;;;1090     }
;;;1091   }
000012  4770              BX       lr
;;;1092   
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;212      */
;;;213    void ADC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;214    {
;;;215      /* Enable all ADCs reset state */
;;;216      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
000002  2101              MOVS     r1,#1
000004  020c              LSLS     r4,r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;217      
;;;218      /* Release all ADCs from reset state */
;;;219      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;220    }
;;;221    
                          ENDP


                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;929      */
;;;930    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  6842              LDR      r2,[r0,#4]
;;;931    {
;;;932      uint32_t tmpreg1 = 0;
;;;933      uint32_t tmpreg2 = 0;
;;;934      
;;;935      /* Check the parameters */
;;;936      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;937      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;938      
;;;939      /* Get the old register value */
;;;940      tmpreg1 = ADCx->CR1;
;;;941      
;;;942      /* Clear the old discontinuous mode channel count */
;;;943      tmpreg1 &= CR1_DISCNUM_RESET;
000002  1e49              SUBS     r1,r1,#1
000004  f4224260          BIC      r2,r2,#0xe000
;;;944      
;;;945      /* Set the discontinuous mode channel count */
;;;946      tmpreg2 = Number - 1;
;;;947      tmpreg1 |= tmpreg2 << 13;
000008  ea423141          ORR      r1,r2,r1,LSL #13
;;;948      
;;;949      /* Store the new register value */
;;;950      ADCx->CR1 = tmpreg1;
00000c  6041              STR      r1,[r0,#4]
;;;951    }
00000e  4770              BX       lr
;;;952    
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;961      */
;;;962    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;963    {
;;;964      /* Check the parameters */
;;;965      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;966      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;967      
;;;968      if (NewState != DISABLE)
;;;969      {
;;;970        /* Enable the selected ADC regular discontinuous mode */
;;;971        ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
;;;972      }
;;;973      else
;;;974      {
;;;975        /* Disable the selected ADC regular discontinuous mode */
;;;976        ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L15.12|
000006  f4416100          ORR      r1,r1,#0x800          ;971
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L15.16|
000010  6041              STR      r1,[r0,#4]            ;971
;;;977      }
;;;978    }
000012  4770              BX       lr
;;;979    
                          ENDP


                          AREA ||i.ADC_EOCOnEachRegularChannelCmd||, CODE, READONLY, ALIGN=1

                  ADC_EOCOnEachRegularChannelCmd PROC
;;;878      */
;;;879    void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;880    {
;;;881      /* Check the parameters */
;;;882      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;883      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;884      
;;;885      if (NewState != DISABLE)
;;;886      {
;;;887        /* Enable the selected ADC EOC rising on each regular channel conversion */
;;;888        ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
;;;889      }
;;;890      else
;;;891      {
;;;892        /* Disable the selected ADC EOC rising on each regular channel conversion */
;;;893        ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L16.12|
000006  f4416180          ORR      r1,r1,#0x400          ;888
00000a  e001              B        |L16.16|
                  |L16.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L16.16|
000010  6081              STR      r1,[r0,#8]            ;888
;;;894      }
;;;895    }
000012  4770              BX       lr
;;;896    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;1325     */
;;;1326   void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000000  6882              LDR      r2,[r0,#8]
;;;1327   {
;;;1328     uint32_t tmpreg = 0;
;;;1329     /* Check the parameters */
;;;1330     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1331     assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;1332     
;;;1333     /* Get the old register value */
;;;1334     tmpreg = ADCx->CR2;
;;;1335     
;;;1336     /* Clear the old external event selection for injected group */
;;;1337     tmpreg &= CR2_JEXTSEL_RESET;
000002  f4222270          BIC      r2,r2,#0xf0000
;;;1338     
;;;1339     /* Set the external event selection for injected group */
;;;1340     tmpreg |= ADC_ExternalTrigInjecConv;
000006  430a              ORRS     r2,r2,r1
;;;1341     
;;;1342     /* Store the new register value */
;;;1343     ADCx->CR2 = tmpreg;
000008  6082              STR      r2,[r0,#8]
;;;1344   }
00000a  4770              BX       lr
;;;1345   
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvEdgeConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvEdgeConfig PROC
;;;1359     */
;;;1360   void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
000000  6882              LDR      r2,[r0,#8]
;;;1361   {
;;;1362     uint32_t tmpreg = 0;
;;;1363     /* Check the parameters */
;;;1364     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1365     assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
;;;1366     /* Get the old register value */
;;;1367     tmpreg = ADCx->CR2;
;;;1368     /* Clear the old external trigger edge for injected group */
;;;1369     tmpreg &= CR2_JEXTEN_RESET;
000002  f4221240          BIC      r2,r2,#0x300000
;;;1370     /* Set the new external trigger edge for injected group */
;;;1371     tmpreg |= ADC_ExternalTrigInjecConvEdge;
000006  430a              ORRS     r2,r2,r1
;;;1372     /* Store the new register value */
;;;1373     ADCx->CR2 = tmpreg;
000008  6082              STR      r2,[r0,#8]
;;;1374   }
00000a  4770              BX       lr
;;;1375   
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;984      */
;;;985    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  6cc0              LDR      r0,[r0,#0x4c]
;;;986    {
;;;987      /* Check the parameters */
;;;988      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;989      
;;;990      /* Return the selected ADC conversion value */
;;;991      return (uint16_t) ADCx->DR;
000002  b280              UXTH     r0,r0
;;;992    }
000004  4770              BX       lr
;;;993    
                          ENDP


                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;1620     */
;;;1621   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  4602              MOV      r2,r0
;;;1622   {
;;;1623     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1624     /* Check the parameters */
;;;1625     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1626     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1627   
;;;1628     /* Check the status of the specified ADC flag */
;;;1629     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L20.12|
;;;1630     {
;;;1631       /* ADC_FLAG is set */
;;;1632       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L20.12|
;;;1633     }
;;;1634     else
;;;1635     {
;;;1636       /* ADC_FLAG is reset */
;;;1637       bitstatus = RESET;
;;;1638     }
;;;1639     /* Return the ADC_FLAG status */
;;;1640     return  bitstatus;
;;;1641   }
00000c  4770              BX       lr
;;;1642   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1676     */
;;;1677   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1678   {
000002  4602              MOV      r2,r0
;;;1679     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1680     uint32_t itmask = 0, enablestatus = 0;
;;;1681   
;;;1682     /* Check the parameters */
;;;1683     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1684     assert_param(IS_ADC_IT(ADC_IT));
;;;1685   
;;;1686     /* Get the ADC IT index */
;;;1687     itmask = ADC_IT >> 8;
;;;1688   
;;;1689     /* Get the ADC_IT enable bit status */
;;;1690     enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
000006  6853              LDR      r3,[r2,#4]
000008  0a0c              LSRS     r4,r1,#8              ;1687
00000a  2501              MOVS     r5,#1
00000c  408d              LSLS     r5,r5,r1
;;;1691   
;;;1692     /* Check the status of the specified ADC interrupt */
;;;1693     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
00000e  6811              LDR      r1,[r2,#0]
000010  402b              ANDS     r3,r3,r5              ;1690
000012  4221              TST      r1,r4
000014  d002              BEQ      |L21.28|
000016  2b00              CMP      r3,#0
000018  d000              BEQ      |L21.28|
;;;1694     {
;;;1695       /* ADC_IT is set */
;;;1696       bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L21.28|
;;;1697     }
;;;1698     else
;;;1699     {
;;;1700       /* ADC_IT is reset */
;;;1701       bitstatus = RESET;
;;;1702     }
;;;1703     /* Return the ADC_IT status */
;;;1704     return  bitstatus;
;;;1705   }
00001c  bd30              POP      {r4,r5,pc}
;;;1706   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;1476     */
;;;1477   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000000  b508              PUSH     {r3,lr}
;;;1478   {
;;;1479     __IO uint32_t tmp = 0;
;;;1480     
;;;1481     /* Check the parameters */
;;;1482     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1483     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1484   
;;;1485     tmp = (uint32_t)ADCx;
;;;1486     tmp += ADC_InjectedChannel + JDR_OFFSET;
000002  4408              ADD      r0,r0,r1
000004  3028              ADDS     r0,r0,#0x28
;;;1487     
;;;1488     /* Returns the selected injected channel conversion data value */
;;;1489     return (uint16_t) (*(__IO uint32_t*)  tmp); 
000006  9000              STR      r0,[sp,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  b280              UXTH     r0,r0
;;;1490   }
00000c  bd08              POP      {r3,pc}
;;;1491   /**
                          ENDP


                          AREA ||i.ADC_GetMultiModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetMultiModeConversionValue PROC
;;;1005     */
;;;1006   uint32_t ADC_GetMultiModeConversionValue(void)
000000  4801              LDR      r0,|L23.8|
;;;1007   {
;;;1008     /* Return the multi mode conversion value */
;;;1009     return (*(__IO uint32_t *) CDR_ADDRESS);
000002  f8d00308          LDR      r0,[r0,#0x308]
;;;1010   }
000006  4770              BX       lr
;;;1011   /**
                          ENDP

                  |L23.8|
                          DCD      0x40012000

                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartConvStatus PROC
;;;848      */
;;;849    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;850    {
;;;851      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;852      /* Check the parameters */
;;;853      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;854      
;;;855      /* Check the status of SWSTART bit */
;;;856      if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0049              LSLS     r1,r1,#1
000008  d500              BPL      |L24.12|
;;;857      {
;;;858        /* SWSTART bit is set */
;;;859        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L24.12|
;;;860      }
;;;861      else
;;;862      {
;;;863        /* SWSTART bit is reset */
;;;864        bitstatus = RESET;
;;;865      }
;;;866      
;;;867      /* Return the SWSTART bit status */
;;;868      return  bitstatus;
;;;869    }
00000c  4770              BX       lr
;;;870    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;1393     */
;;;1394   FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;1395   {
;;;1396     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1397     /* Check the parameters */
;;;1398     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1399     
;;;1400     /* Check the status of JSWSTART bit */
;;;1401     if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0249              LSLS     r1,r1,#9
000008  d500              BPL      |L25.12|
;;;1402     {
;;;1403       /* JSWSTART bit is set */
;;;1404       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L25.12|
;;;1405     }
;;;1406     else
;;;1407     {
;;;1408       /* JSWSTART bit is reset */
;;;1409       bitstatus = RESET;
;;;1410     }
;;;1411     /* Return the JSWSTART bit status */
;;;1412     return  bitstatus;
;;;1413   }
00000c  4770              BX       lr
;;;1414   
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;1583     */
;;;1584   void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
000000  2301              MOVS     r3,#1
;;;1585   {
;;;1586     uint32_t itmask = 0;
;;;1587     /* Check the parameters */
;;;1588     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1589     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1590     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1591   
;;;1592     /* Get the ADC IT index */
;;;1593     itmask = (uint8_t)ADC_IT;
;;;1594     itmask = (uint32_t)0x01 << itmask;    
000002  408b              LSLS     r3,r3,r1
;;;1595   
;;;1596     if (NewState != DISABLE)
;;;1597     {
;;;1598       /* Enable the selected ADC interrupts */
;;;1599       ADCx->CR1 |= itmask;
;;;1600     }
;;;1601     else
;;;1602     {
;;;1603       /* Disable the selected ADC interrupts */
;;;1604       ADCx->CR1 &= (~(uint32_t)itmask);
000004  6841              LDR      r1,[r0,#4]
000006  b10a              CBZ      r2,|L26.12|
000008  4319              ORRS     r1,r1,r3              ;1599
00000a  e000              B        |L26.14|
                  |L26.12|
00000c  4399              BICS     r1,r1,r3
                  |L26.14|
00000e  6041              STR      r1,[r0,#4]            ;1599
;;;1605     }
;;;1606   }
000010  4770              BX       lr
;;;1607   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;234      */
;;;235    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;236    {
;;;237      uint32_t tmpreg1 = 0;
;;;238      uint8_t tmpreg2 = 0;
;;;239      /* Check the parameters */
;;;240      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;241      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
;;;242      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;243      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
;;;244      assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
;;;245      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
;;;246      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;247      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
;;;248      
;;;249      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;250      /* Get the ADCx CR1 value */
;;;251      tmpreg1 = ADCx->CR1;
000002  6842              LDR      r2,[r0,#4]
;;;252      
;;;253      /* Clear RES and SCAN bits */
;;;254      tmpreg1 &= CR1_CLEAR_MASK;
000004  4b0f              LDR      r3,|L27.68|
;;;255      
;;;256      /* Configure ADCx: scan conversion mode and resolution */
;;;257      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;258      /* Set RES bit according to ADC_Resolution value */ 
;;;259      tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
000006  790c              LDRB     r4,[r1,#4]
000008  401a              ANDS     r2,r2,r3              ;254
00000a  680b              LDR      r3,[r1,#0]
00000c  ea422204          ORR      r2,r2,r4,LSL #8
000010  4313              ORRS     r3,r3,r2
;;;260                                       ADC_InitStruct->ADC_Resolution);
;;;261      /* Write to ADCx CR1 */
;;;262      ADCx->CR1 = tmpreg1;
000012  6043              STR      r3,[r0,#4]
;;;263      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;264      /* Get the ADCx CR2 value */
;;;265      tmpreg1 = ADCx->CR2;
000014  6882              LDR      r2,[r0,#8]
;;;266      
;;;267      /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
;;;268      tmpreg1 &= CR2_CLEAR_MASK;
000016  4b0c              LDR      r3,|L27.72|
;;;269      
;;;270      /* Configure ADCx: external trigger event and edge, data alignment and 
;;;271         continuous conversion mode */
;;;272      /* Set ALIGN bit according to ADC_DataAlign value */
;;;273      /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
;;;274      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;275      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;276      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
000018  794d              LDRB     r5,[r1,#5]
00001a  401a              ANDS     r2,r2,r3              ;268
00001c  e9d14303          LDRD     r4,r3,[r1,#0xc]       ;268
000020  4323              ORRS     r3,r3,r4
000022  688c              LDR      r4,[r1,#8]
000024  ea440445          ORR      r4,r4,r5,LSL #1
000028  4323              ORRS     r3,r3,r4
00002a  4313              ORRS     r3,r3,r2
;;;277                            ADC_InitStruct->ADC_ExternalTrigConv | 
;;;278                            ADC_InitStruct->ADC_ExternalTrigConvEdge | \
;;;279                            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;280                            
;;;281      /* Write to ADCx CR2 */
;;;282      ADCx->CR2 = tmpreg1;
00002c  6083              STR      r3,[r0,#8]
;;;283      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;284      /* Get the ADCx SQR1 value */
;;;285      tmpreg1 = ADCx->SQR1;
00002e  6ac2              LDR      r2,[r0,#0x2c]
;;;286      
;;;287      /* Clear L bits */
;;;288      tmpreg1 &= SQR1_L_RESET;
;;;289      
;;;290      /* Configure ADCx: regular channel sequence length */
;;;291      /* Set L bits according to ADC_NbrOfConversion value */
;;;292      tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
000030  7d09              LDRB     r1,[r1,#0x14]
000032  f4220270          BIC      r2,r2,#0xf00000       ;288
000036  1e49              SUBS     r1,r1,#1
000038  b2c9              UXTB     r1,r1
;;;293      tmpreg1 |= ((uint32_t)tmpreg2 << 20);
00003a  ea425101          ORR      r1,r2,r1,LSL #20
;;;294      
;;;295      /* Write to ADCx SQR1 */
;;;296      ADCx->SQR1 = tmpreg1;
00003e  62c1              STR      r1,[r0,#0x2c]
;;;297    }
000040  bd30              POP      {r4,r5,pc}
;;;298    
                          ENDP

000042  0000              DCW      0x0000
                  |L27.68|
                          DCD      0xfcfffeff
                  |L27.72|
                          DCD      0xc0fff7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelConfig PROC
;;;1189     */
;;;1190   void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;1191   {
;;;1192     uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;1193     /* Check the parameters */
;;;1194     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1195     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1196     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1197     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1198     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1199     if (ADC_Channel > ADC_Channel_9)
;;;1200     {
;;;1201       /* Get the old register value */
;;;1202       tmpreg1 = ADCx->SMPR1;
;;;1203       /* Calculate the mask to clear */
;;;1204       tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
000002  2607              MOVS     r6,#7
000004  2909              CMP      r1,#9                 ;1199
000006  d90a              BLS      |L28.30|
000008  68c5              LDR      r5,[r0,#0xc]          ;1202
00000a  f1a1040a          SUB      r4,r1,#0xa
00000e  eb040444          ADD      r4,r4,r4,LSL #1
000012  40a6              LSLS     r6,r6,r4
;;;1205       /* Clear the old sample time */
;;;1206       tmpreg1 &= ~tmpreg2;
000014  43b5              BICS     r5,r5,r6
;;;1207       /* Calculate the mask to set */
;;;1208       tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
000016  40a3              LSLS     r3,r3,r4
;;;1209       /* Set the new sample time */
;;;1210       tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;1211       /* Store the new register value */
;;;1212       ADCx->SMPR1 = tmpreg1;
00001a  60c5              STR      r5,[r0,#0xc]
00001c  e007              B        |L28.46|
                  |L28.30|
;;;1213     }
;;;1214     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1215     {
;;;1216       /* Get the old register value */
;;;1217       tmpreg1 = ADCx->SMPR2;
00001e  6905              LDR      r5,[r0,#0x10]
;;;1218       /* Calculate the mask to clear */
;;;1219       tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
000020  eb010441          ADD      r4,r1,r1,LSL #1
000024  40a6              LSLS     r6,r6,r4
;;;1220       /* Clear the old sample time */
;;;1221       tmpreg1 &= ~tmpreg2;
000026  43b5              BICS     r5,r5,r6
;;;1222       /* Calculate the mask to set */
;;;1223       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000028  40a3              LSLS     r3,r3,r4
;;;1224       /* Set the new sample time */
;;;1225       tmpreg1 |= tmpreg2;
00002a  431d              ORRS     r5,r5,r3
;;;1226       /* Store the new register value */
;;;1227       ADCx->SMPR2 = tmpreg1;
00002c  6105              STR      r5,[r0,#0x10]
                  |L28.46|
;;;1228     }
;;;1229     /* Rank configuration */
;;;1230     /* Get the old register value */
;;;1231     tmpreg1 = ADCx->JSQR;
00002e  6b83              LDR      r3,[r0,#0x38]
;;;1232     /* Get JL value: Number = JL+1 */
;;;1233     tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
000030  f3c35401          UBFX     r4,r3,#20,#2
;;;1234     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1235     tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000034  1b12              SUBS     r2,r2,r4
000036  1c92              ADDS     r2,r2,#2
000038  eb020282          ADD      r2,r2,r2,LSL #2
00003c  241f              MOVS     r4,#0x1f
00003e  4094              LSLS     r4,r4,r2
;;;1236     /* Clear the old JSQx bits for the selected rank */
;;;1237     tmpreg1 &= ~tmpreg2;
000040  43a3              BICS     r3,r3,r4
;;;1238     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1239     tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000042  4091              LSLS     r1,r1,r2
;;;1240     /* Set the JSQx bits for the selected rank */
;;;1241     tmpreg1 |= tmpreg2;
000044  430b              ORRS     r3,r3,r1
;;;1242     /* Store the new register value */
;;;1243     ADCx->JSQR = tmpreg1;
000046  6383              STR      r3,[r0,#0x38]
;;;1244   }
000048  bd70              POP      {r4-r6,pc}
;;;1245   
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;1448     */
;;;1449   void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1450   {
;;;1451     /* Check the parameters */
;;;1452     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1453     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1454     if (NewState != DISABLE)
;;;1455     {
;;;1456       /* Enable the selected ADC injected discontinuous mode */
;;;1457       ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
;;;1458     }
;;;1459     else
;;;1460     {
;;;1461       /* Disable the selected ADC injected discontinuous mode */
;;;1462       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L29.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;1457
00000a  e001              B        |L29.16|
                  |L29.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L29.16|
000010  6041              STR      r1,[r0,#4]            ;1457
;;;1463     }
;;;1464   }
000012  4770              BX       lr
;;;1465   
                          ENDP


                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedSequencerLengthConfig PROC
;;;1252     */
;;;1253   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000000  6b82              LDR      r2,[r0,#0x38]
;;;1254   {
;;;1255     uint32_t tmpreg1 = 0;
;;;1256     uint32_t tmpreg2 = 0;
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1259     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1260     
;;;1261     /* Get the old register value */
;;;1262     tmpreg1 = ADCx->JSQR;
;;;1263     
;;;1264     /* Clear the old injected sequence length JL bits */
;;;1265     tmpreg1 &= JSQR_JL_RESET;
000002  1e49              SUBS     r1,r1,#1
000004  f4221240          BIC      r2,r2,#0x300000
;;;1266     
;;;1267     /* Set the injected sequence length JL bits */
;;;1268     tmpreg2 = Length - 1; 
;;;1269     tmpreg1 |= tmpreg2 << 20;
000008  ea425101          ORR      r1,r2,r1,LSL #20
;;;1270     
;;;1271     /* Store the new register value */
;;;1272     ADCx->JSQR = tmpreg1;
00000c  6381              STR      r1,[r0,#0x38]
;;;1273   }
00000e  4770              BX       lr
;;;1274   
                          ENDP


                          AREA ||i.ADC_MultiModeDMARequestAfterLastTransferCmd||, CODE, READONLY, ALIGN=2

                  ADC_MultiModeDMARequestAfterLastTransferCmd PROC
;;;1102     */
;;;1103   void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
000000  4906              LDR      r1,|L31.28|
;;;1104   {
;;;1105     /* Check the parameters */
;;;1106     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1107     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;1108     {
;;;1109       /* Enable the selected ADC DMA request after last transfer */
;;;1110       ADC->CCR |= (uint32_t)ADC_CCR_DDS;
;;;1111     }
;;;1112     else
;;;1113     {
;;;1114       /* Disable the selected ADC DMA request after last transfer */
;;;1115       ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
000004  f8d10304          LDR      r0,[r1,#0x304]
000008  d002              BEQ      |L31.16|
00000a  f4405000          ORR      r0,r0,#0x2000         ;1110
00000e  e001              B        |L31.20|
                  |L31.16|
000010  f4205000          BIC      r0,r0,#0x2000
                  |L31.20|
000014  f8c10304          STR      r0,[r1,#0x304]        ;1110
;;;1116     }
;;;1117   }
000018  4770              BX       lr
;;;1118   /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L31.28|
                          DCD      0x40012000

                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;714      */
;;;715    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;716    {
;;;717      uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;718      /* Check the parameters */
;;;719      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;720      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;721      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;722      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;723      
;;;724      /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;725      if (ADC_Channel > ADC_Channel_9)
;;;726      {
;;;727        /* Get the old register value */
;;;728        tmpreg1 = ADCx->SMPR1;
;;;729        
;;;730        /* Calculate the mask to clear */
;;;731        tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
000002  2607              MOVS     r6,#7
000004  2909              CMP      r1,#9                 ;725
000006  d90a              BLS      |L32.30|
000008  68c5              LDR      r5,[r0,#0xc]          ;728
00000a  f1a1040a          SUB      r4,r1,#0xa
00000e  eb040444          ADD      r4,r4,r4,LSL #1
000012  40a6              LSLS     r6,r6,r4
;;;732        
;;;733        /* Clear the old sample time */
;;;734        tmpreg1 &= ~tmpreg2;
000014  43b5              BICS     r5,r5,r6
;;;735        
;;;736        /* Calculate the mask to set */
;;;737        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000016  40a3              LSLS     r3,r3,r4
;;;738        
;;;739        /* Set the new sample time */
;;;740        tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;741        
;;;742        /* Store the new register value */
;;;743        ADCx->SMPR1 = tmpreg1;
00001a  60c5              STR      r5,[r0,#0xc]
00001c  e007              B        |L32.46|
                  |L32.30|
;;;744      }
;;;745      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;746      {
;;;747        /* Get the old register value */
;;;748        tmpreg1 = ADCx->SMPR2;
00001e  6905              LDR      r5,[r0,#0x10]
;;;749        
;;;750        /* Calculate the mask to clear */
;;;751        tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
000020  eb010441          ADD      r4,r1,r1,LSL #1
000024  40a6              LSLS     r6,r6,r4
;;;752        
;;;753        /* Clear the old sample time */
;;;754        tmpreg1 &= ~tmpreg2;
000026  43b5              BICS     r5,r5,r6
;;;755        
;;;756        /* Calculate the mask to set */
;;;757        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000028  40a3              LSLS     r3,r3,r4
;;;758        
;;;759        /* Set the new sample time */
;;;760        tmpreg1 |= tmpreg2;
00002a  431d              ORRS     r5,r5,r3
;;;761        
;;;762        /* Store the new register value */
;;;763        ADCx->SMPR2 = tmpreg1;
00002c  6105              STR      r5,[r0,#0x10]
                  |L32.46|
;;;764      }
;;;765      /* For Rank 1 to 6 */
;;;766      if (Rank < 7)
;;;767      {
;;;768        /* Get the old register value */
;;;769        tmpreg1 = ADCx->SQR3;
;;;770        
;;;771        /* Calculate the mask to clear */
;;;772        tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
00002e  231f              MOVS     r3,#0x1f
000030  2a07              CMP      r2,#7                 ;766
000032  d209              BCS      |L32.72|
000034  6b44              LDR      r4,[r0,#0x34]         ;769
000036  1e52              SUBS     r2,r2,#1              ;769
000038  eb020282          ADD      r2,r2,r2,LSL #2
00003c  4093              LSLS     r3,r3,r2
;;;773        
;;;774        /* Clear the old SQx bits for the selected rank */
;;;775        tmpreg1 &= ~tmpreg2;
00003e  439c              BICS     r4,r4,r3
;;;776        
;;;777        /* Calculate the mask to set */
;;;778        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
000040  4091              LSLS     r1,r1,r2
;;;779        
;;;780        /* Set the SQx bits for the selected rank */
;;;781        tmpreg1 |= tmpreg2;
000042  430c              ORRS     r4,r4,r1
;;;782        
;;;783        /* Store the new register value */
;;;784        ADCx->SQR3 = tmpreg1;
000044  6344              STR      r4,[r0,#0x34]
;;;785      }
;;;786      /* For Rank 7 to 12 */
;;;787      else if (Rank < 13)
;;;788      {
;;;789        /* Get the old register value */
;;;790        tmpreg1 = ADCx->SQR2;
;;;791        
;;;792        /* Calculate the mask to clear */
;;;793        tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
;;;794        
;;;795        /* Clear the old SQx bits for the selected rank */
;;;796        tmpreg1 &= ~tmpreg2;
;;;797        
;;;798        /* Calculate the mask to set */
;;;799        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
;;;800        
;;;801        /* Set the SQx bits for the selected rank */
;;;802        tmpreg1 |= tmpreg2;
;;;803        
;;;804        /* Store the new register value */
;;;805        ADCx->SQR2 = tmpreg1;
;;;806      }
;;;807      /* For Rank 13 to 16 */
;;;808      else
;;;809      {
;;;810        /* Get the old register value */
;;;811        tmpreg1 = ADCx->SQR1;
;;;812        
;;;813        /* Calculate the mask to clear */
;;;814        tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
;;;815        
;;;816        /* Clear the old SQx bits for the selected rank */
;;;817        tmpreg1 &= ~tmpreg2;
;;;818        
;;;819        /* Calculate the mask to set */
;;;820        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
;;;821        
;;;822        /* Set the SQx bits for the selected rank */
;;;823        tmpreg1 |= tmpreg2;
;;;824        
;;;825        /* Store the new register value */
;;;826        ADCx->SQR1 = tmpreg1;
;;;827      }
;;;828    }
000046  bd70              POP      {r4-r6,pc}
                  |L32.72|
000048  2a0d              CMP      r2,#0xd               ;787
00004a  d209              BCS      |L32.96|
00004c  6b04              LDR      r4,[r0,#0x30]         ;790
00004e  1fd2              SUBS     r2,r2,#7              ;790
000050  eb020282          ADD      r2,r2,r2,LSL #2       ;793
000054  4093              LSLS     r3,r3,r2              ;793
000056  439c              BICS     r4,r4,r3              ;796
000058  4091              LSLS     r1,r1,r2              ;799
00005a  430c              ORRS     r4,r4,r1              ;802
00005c  6304              STR      r4,[r0,#0x30]         ;805
00005e  bd70              POP      {r4-r6,pc}
                  |L32.96|
000060  6ac4              LDR      r4,[r0,#0x2c]         ;811
000062  3a0d              SUBS     r2,r2,#0xd            ;811
000064  eb020282          ADD      r2,r2,r2,LSL #2       ;814
000068  4093              LSLS     r3,r3,r2              ;814
00006a  439c              BICS     r4,r4,r3              ;817
00006c  4091              LSLS     r1,r1,r2              ;820
00006e  430c              ORRS     r4,r4,r1              ;823
000070  62c4              STR      r4,[r0,#0x2c]         ;826
000072  bd70              POP      {r4-r6,pc}
;;;829    
                          ENDP


                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetInjectedOffset PROC
;;;1287     */
;;;1288   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000000  b508              PUSH     {r3,lr}
;;;1289   {
;;;1290       __IO uint32_t tmp = 0;
;;;1291     /* Check the parameters */
;;;1292     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1293     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1294     assert_param(IS_ADC_OFFSET(Offset));
;;;1295     
;;;1296     tmp = (uint32_t)ADCx;
;;;1297     tmp += ADC_InjectedChannel;
000002  4408              ADD      r0,r0,r1
;;;1298     
;;;1299     /* Set the selected injected channel data offset */
;;;1300    *(__IO uint32_t *) tmp = (uint32_t)Offset;
000004  9000              STR      r0,[sp,#0]
000006  6002              STR      r2,[r0,#0]
;;;1301   }
000008  bd08              POP      {r3,pc}
;;;1302   
                          ENDP


                          AREA ||i.ADC_SoftwareStartConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConv PROC
;;;834      */
;;;835    void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;836    {
;;;837      /* Check the parameters */
;;;838      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;839      
;;;840      /* Enable the selected ADC conversion for regular group */
;;;841      ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
000002  f0414180          ORR      r1,r1,#0x40000000
000006  6081              STR      r1,[r0,#8]
;;;842    }
000008  4770              BX       lr
;;;843    
                          ENDP


                          AREA ||i.ADC_SoftwareStartInjectedConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartInjectedConv PROC
;;;1380     */
;;;1381   void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;1382   {
;;;1383     /* Check the parameters */
;;;1384     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1385     /* Enable the selected ADC conversion for injected group */
;;;1386     ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
000002  f4410180          ORR      r1,r1,#0x400000
000006  6081              STR      r1,[r0,#8]
;;;1387   }
000008  4770              BX       lr
;;;1388   
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;309      */
;;;310    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;311    {
;;;312      /* Initialize the ADC_Mode member */
;;;313      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
;;;314    
;;;315      /* initialize the ADC_ScanConvMode member */
;;;316      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000002  6001              STR      r1,[r0,#0]
000004  7101              STRB     r1,[r0,#4]
;;;317    
;;;318      /* Initialize the ADC_ContinuousConvMode member */
;;;319      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;320    
;;;321      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;322      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;323    
;;;324      /* Initialize the ADC_ExternalTrigConv member */
;;;325      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
000008  6081              STR      r1,[r0,#8]
;;;326    
;;;327      /* Initialize the ADC_DataAlign member */
;;;328      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00000a  60c1              STR      r1,[r0,#0xc]
;;;329    
;;;330      /* Initialize the ADC_NbrOfConversion member */
;;;331      ADC_InitStruct->ADC_NbrOfConversion = 1;
00000c  6101              STR      r1,[r0,#0x10]
00000e  2101              MOVS     r1,#1
000010  7501              STRB     r1,[r0,#0x14]
;;;332    }
000012  4770              BX       lr
;;;333    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;588      */
;;;589    void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
000000  4906              LDR      r1,|L37.28|
;;;590    {
;;;591      /* Check the parameters */
;;;592      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;593      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;594      {
;;;595        /* Enable the temperature sensor and Vrefint channel*/
;;;596        ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
;;;597      }
;;;598      else
;;;599      {
;;;600        /* Disable the temperature sensor and Vrefint channel*/
;;;601        ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
000004  f8d10304          LDR      r0,[r1,#0x304]
000008  d002              BEQ      |L37.16|
00000a  f4400000          ORR      r0,r0,#0x800000       ;596
00000e  e001              B        |L37.20|
                  |L37.16|
000010  f4200000          BIC      r0,r0,#0x800000
                  |L37.20|
000014  f8c10304          STR      r0,[r1,#0x304]        ;596
;;;602      }
;;;603    }
000018  4770              BX       lr
;;;604    
                          ENDP

00001a  0000              DCW      0x0000
                  |L37.28|
                          DCD      0x40012000

                          AREA ||i.ADC_VBATCmd||, CODE, READONLY, ALIGN=2

                  ADC_VBATCmd PROC
;;;614      */
;;;615    void ADC_VBATCmd(FunctionalState NewState)                             
000000  4906              LDR      r1,|L38.28|
;;;616    {
;;;617      /* Check the parameters */
;;;618      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;619      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;620      {
;;;621        /* Enable the VBAT channel*/
;;;622        ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
;;;623      }
;;;624      else
;;;625      {
;;;626        /* Disable the VBAT channel*/
;;;627        ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
000004  f8d10304          LDR      r0,[r1,#0x304]
000008  d002              BEQ      |L38.16|
00000a  f4400080          ORR      r0,r0,#0x400000       ;622
00000e  e001              B        |L38.20|
                  |L38.16|
000010  f4200080          BIC      r0,r0,#0x400000
                  |L38.20|
000014  f8c10304          STR      r0,[r1,#0x304]        ;622
;;;628      }
;;;629    }
000018  4770              BX       lr
;;;630    
                          ENDP

00001a  0000              DCW      0x0000
                  |L38.28|
                          DCD      0x40012000

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_adc_c_e11a2ea2____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_adc_c_e11a2ea2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_adc_c_e11a2ea2____REVSH|
#line 144
|__asm___15_stm32f4xx_adc_c_e11a2ea2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
