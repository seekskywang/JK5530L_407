; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_cryp.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_cryp.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_cryp.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_cryp.c]
                          THUMB

                          AREA ||i.CRYP_Cmd||, CODE, READONLY, ALIGN=2

                  CRYP_Cmd PROC
;;;402      */
;;;403    void CRYP_Cmd(FunctionalState NewState)
000000  4905              LDR      r1,|L1.24|
;;;404    {
;;;405      /* Check the parameters */
;;;406      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;407    
;;;408      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;409      {
;;;410        /* Enable the Cryptographic processor */
;;;411        CRYP->CR |= CRYP_CR_CRYPEN;
;;;412      }
;;;413      else
;;;414      {
;;;415        /* Disable the Cryptographic processor */
;;;416        CRYP->CR &= ~CRYP_CR_CRYPEN;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L1.14|
000008  f4404000          ORR      r0,r0,#0x8000         ;411
00000c  e001              B        |L1.18|
                  |L1.14|
00000e  f4204000          BIC      r0,r0,#0x8000
                  |L1.18|
000012  6008              STR      r0,[r1,#0]            ;411
;;;417      }
;;;418    }
000014  4770              BX       lr
;;;419    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x50060000

                          AREA ||i.CRYP_DMACmd||, CODE, READONLY, ALIGN=2

                  CRYP_DMACmd PROC
;;;680      */
;;;681    void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
000000  4a05              LDR      r2,|L2.24|
;;;682    {
;;;683      /* Check the parameters */
;;;684      assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
;;;685      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;686    
;;;687      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;688      {
;;;689        /* Enable the selected CRYP DMA request */
;;;690        CRYP->DMACR |= CRYP_DMAReq;
;;;691      }
;;;692      else
;;;693      {
;;;694        /* Disable the selected CRYP DMA request */
;;;695        CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;690
00000a  e002              B        |L2.18|
                  |L2.12|
00000c  43c0              MVNS     r0,r0
00000e  b2c0              UXTB     r0,r0
000010  4001              ANDS     r1,r1,r0
                  |L2.18|
000012  6111              STR      r1,[r2,#0x10]         ;690
;;;696      }
;;;697    }
000014  4770              BX       lr
;;;698    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataIn||, CODE, READONLY, ALIGN=2

                  CRYP_DataIn PROC
;;;445      */
;;;446    void CRYP_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L3.8|
;;;447    {
;;;448      CRYP->DR = Data;
000002  6088              STR      r0,[r1,#8]
;;;449    }
000004  4770              BX       lr
;;;450    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataOut||, CODE, READONLY, ALIGN=2

                  CRYP_DataOut PROC
;;;455      */
;;;456    uint32_t CRYP_DataOut(void)
000000  4801              LDR      r0,|L4.8|
;;;457    {
;;;458      return CRYP->DOUT;
000002  68c0              LDR      r0,[r0,#0xc]
;;;459    }
000004  4770              BX       lr
;;;460    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DeInit||, CODE, READONLY, ALIGN=1

                  CRYP_DeInit PROC
;;;218      */
;;;219    void CRYP_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221      /* Enable CRYP reset state */
;;;222      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;223    
;;;224      /* Release CRYP from reset state */
;;;225      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2010              MOVS     r0,#0x10
000012  f7ffbffe          B.W      RCC_AHB2PeriphResetCmd
;;;226    }
;;;227    
                          ENDP


                          AREA ||i.CRYP_FIFOFlush||, CODE, READONLY, ALIGN=2

                  CRYP_FIFOFlush PROC
;;;390      */
;;;391    void CRYP_FIFOFlush(void)
000000  4802              LDR      r0,|L6.12|
;;;392    {
;;;393      /* Reset the read and write pointers of the FIFOs */
;;;394      CRYP->CR |= CRYP_CR_FFLUSH;
000002  6801              LDR      r1,[r0,#0]
000004  f4414180          ORR      r1,r1,#0x4000
000008  6001              STR      r1,[r0,#0]
;;;395    }
00000a  4770              BX       lr
;;;396    
                          ENDP

                  |L6.12|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetCmdStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetCmdStatus PROC
;;;852      */
;;;853    FunctionalState CRYP_GetCmdStatus(void)
000000  4903              LDR      r1,|L7.16|
;;;854    {
;;;855      FunctionalState state = DISABLE;
000002  2000              MOVS     r0,#0
;;;856    
;;;857      if ((CRYP->CR & CRYP_CR_CRYPEN) != 0)
000004  6809              LDR      r1,[r1,#0]
000006  0409              LSLS     r1,r1,#16
000008  d500              BPL      |L7.12|
;;;858      {
;;;859        /* CRYPEN bit is set */
;;;860        state = ENABLE;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;861      }
;;;862      else
;;;863      {
;;;864        /* CRYPEN bit is reset */
;;;865        state = DISABLE;
;;;866      }
;;;867      return state;
;;;868    }
00000c  4770              BX       lr
;;;869    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetFlagStatus PROC
;;;882      */
;;;883    FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
000000  4602              MOV      r2,r0
;;;884    {
;;;885      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;886      uint32_t tempreg = 0;
;;;887    
;;;888      /* Check the parameters */
;;;889      assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
;;;890    
;;;891      /* check if the FLAG is in RISR register */
;;;892      if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
;;;893      {
;;;894        tempreg = CRYP->RISR;
000004  4904              LDR      r1,|L8.24|
000006  0693              LSLS     r3,r2,#26             ;892
000008  d501              BPL      |L8.14|
00000a  6989              LDR      r1,[r1,#0x18]
00000c  e000              B        |L8.16|
                  |L8.14|
;;;895      }
;;;896      else  /* The FLAG is in SR register */
;;;897      {
;;;898        tempreg = CRYP->SR;
00000e  6849              LDR      r1,[r1,#4]
                  |L8.16|
;;;899      }
;;;900    
;;;901    
;;;902      /* Check the status of the specified CRYP flag */
;;;903      if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
000010  4211              TST      r1,r2
000012  d000              BEQ      |L8.22|
;;;904      {
;;;905        /* CRYP_FLAG is set */
;;;906        bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L8.22|
;;;907      }
;;;908      else
;;;909      {
;;;910        /* CRYP_FLAG is reset */
;;;911        bitstatus = RESET;
;;;912      }
;;;913    
;;;914      /* Return the CRYP_FLAG status */
;;;915      return  bitstatus;
;;;916    }
000016  4770              BX       lr
;;;917    
                          ENDP

                  |L8.24|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetITStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetITStatus PROC
;;;826      */
;;;827    ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
000000  4a03              LDR      r2,|L9.16|
;;;828    {
000002  4601              MOV      r1,r0
;;;829      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;830      /* Check the parameters */
;;;831      assert_param(IS_CRYP_GET_IT(CRYP_IT));
;;;832    
;;;833      /* Check the status of the specified CRYP interrupt */
;;;834      if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
000006  69d2              LDR      r2,[r2,#0x1c]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L9.14|
;;;835      {
;;;836        /* CRYP_IT is set */
;;;837        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;838      }
;;;839      else
;;;840      {
;;;841        /* CRYP_IT is reset */
;;;842        bitstatus = RESET;
;;;843      }
;;;844      /* Return the CRYP_IT status */
;;;845      return bitstatus;
;;;846    }
00000e  4770              BX       lr
;;;847    
                          ENDP

                  |L9.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_ITConfig||, CODE, READONLY, ALIGN=2

                  CRYP_ITConfig PROC
;;;798      */
;;;799    void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
000000  4a05              LDR      r2,|L10.24|
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
;;;803      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;804    
;;;805      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;806      {
;;;807        /* Enable the selected CRYP interrupt */
;;;808        CRYP->IMSCR |= CRYP_IT;
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable the selected CRYP interrupt */
;;;813        CRYP->IMSCR &= (uint8_t)~CRYP_IT;
000004  6951              LDR      r1,[r2,#0x14]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;808
00000a  e002              B        |L10.18|
                  |L10.12|
00000c  43c0              MVNS     r0,r0
00000e  b2c0              UXTB     r0,r0
000010  4001              ANDS     r1,r1,r0
                  |L10.18|
000012  6151              STR      r1,[r2,#0x14]         ;808
;;;814      }
;;;815    }
000014  4770              BX       lr
;;;816    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVInit||, CODE, READONLY, ALIGN=2

                  CRYP_IVInit PROC
;;;332      */
;;;333    void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  4904              LDR      r1,|L11.20|
;;;334    {
;;;335      CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
000002  6802              LDR      r2,[r0,#0]
000004  640a              STR      r2,[r1,#0x40]
;;;336      CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
000006  6842              LDR      r2,[r0,#4]
000008  644a              STR      r2,[r1,#0x44]
;;;337      CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
00000a  6882              LDR      r2,[r0,#8]
00000c  648a              STR      r2,[r1,#0x48]
;;;338      CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
00000e  68c0              LDR      r0,[r0,#0xc]
000010  64c8              STR      r0,[r1,#0x4c]
;;;339    }
000012  4770              BX       lr
;;;340    
                          ENDP

                  |L11.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_IVStructInit PROC
;;;346      */
;;;347    void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  2100              MOVS     r1,#0
;;;348    {
;;;349      CRYP_IVInitStruct->CRYP_IV0Left  = 0;
;;;350      CRYP_IVInitStruct->CRYP_IV0Right = 0;
000002  6001              STR      r1,[r0,#0]
;;;351      CRYP_IVInitStruct->CRYP_IV1Left  = 0;
000004  6041              STR      r1,[r0,#4]
;;;352      CRYP_IVInitStruct->CRYP_IV1Right = 0;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;353    }
00000a  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.CRYP_Init||, CODE, READONLY, ALIGN=2

                  CRYP_Init PROC
;;;234      */
;;;235    void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
000000  4914              LDR      r1,|L13.84|
;;;236    {
;;;237      /* Check the parameters */
;;;238      assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
;;;239      assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
;;;240      assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
;;;241    
;;;242      /* Select Algorithm mode*/  
;;;243      CRYP->CR &= ~CRYP_CR_ALGOMODE;
000002  680a              LDR      r2,[r1,#0]
000004  4b14              LDR      r3,|L13.88|
000006  401a              ANDS     r2,r2,r3
000008  600a              STR      r2,[r1,#0]
;;;244      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
00000a  680a              LDR      r2,[r1,#0]
00000c  6843              LDR      r3,[r0,#4]
00000e  431a              ORRS     r2,r2,r3
000010  600a              STR      r2,[r1,#0]
;;;245    
;;;246      /* Select dataType */ 
;;;247      CRYP->CR &= ~CRYP_CR_DATATYPE;
000012  680a              LDR      r2,[r1,#0]
000014  f02202c0          BIC      r2,r2,#0xc0
000018  600a              STR      r2,[r1,#0]
;;;248      CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
00001a  680a              LDR      r2,[r1,#0]
00001c  6883              LDR      r3,[r0,#8]
00001e  431a              ORRS     r2,r2,r3
000020  600a              STR      r2,[r1,#0]
000022  6842              LDR      r2,[r0,#4]            ;236
000024  b16a              CBZ      r2,|L13.66|
;;;249    
;;;250      /* select Key size (used only with AES algorithm) */
;;;251      if ((CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_ECB) &&
;;;252          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_CBC) &&
000026  2a08              CMP      r2,#8
000028  d00b              BEQ      |L13.66|
;;;253          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_ECB) &&
00002a  2a10              CMP      r2,#0x10
00002c  d009              BEQ      |L13.66|
;;;254          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_CBC))
00002e  2a18              CMP      r2,#0x18
000030  d007              BEQ      |L13.66|
;;;255      {
;;;256        assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
;;;257        CRYP->CR &= ~CRYP_CR_KEYSIZE;
000032  680a              LDR      r2,[r1,#0]
000034  f4227240          BIC      r2,r2,#0x300
000038  600a              STR      r2,[r1,#0]
;;;258        CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
00003a  680a              LDR      r2,[r1,#0]
00003c  68c3              LDR      r3,[r0,#0xc]
00003e  431a              ORRS     r2,r2,r3
000040  600a              STR      r2,[r1,#0]
                  |L13.66|
;;;259                                                      configured once the key has 
;;;260                                                      been prepared */
;;;261      }
;;;262    
;;;263      /* Select data Direction */ 
;;;264      CRYP->CR &= ~CRYP_CR_ALGODIR;
000042  680a              LDR      r2,[r1,#0]
000044  f0220204          BIC      r2,r2,#4
000048  600a              STR      r2,[r1,#0]
;;;265      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
00004a  680a              LDR      r2,[r1,#0]
00004c  6800              LDR      r0,[r0,#0]
00004e  4302              ORRS     r2,r2,r0
000050  600a              STR      r2,[r1,#0]
;;;266    }
000052  4770              BX       lr
;;;267    
                          ENDP

                  |L13.84|
                          DCD      0x50060000
                  |L13.88|
                          DCD      0xfff7ffc7

                          AREA ||i.CRYP_KeyInit||, CODE, READONLY, ALIGN=2

                  CRYP_KeyInit PROC
;;;295      */
;;;296    void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  4908              LDR      r1,|L14.36|
;;;297    {
;;;298      /* Key Initialisation */
;;;299      CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
000002  6802              LDR      r2,[r0,#0]
000004  620a              STR      r2,[r1,#0x20]
;;;300      CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
000006  6842              LDR      r2,[r0,#4]
000008  624a              STR      r2,[r1,#0x24]
;;;301      CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
00000a  6882              LDR      r2,[r0,#8]
00000c  628a              STR      r2,[r1,#0x28]
;;;302      CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  62ca              STR      r2,[r1,#0x2c]
;;;303      CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
000012  6902              LDR      r2,[r0,#0x10]
000014  630a              STR      r2,[r1,#0x30]
;;;304      CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
000016  6942              LDR      r2,[r0,#0x14]
000018  634a              STR      r2,[r1,#0x34]
;;;305      CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
00001a  6982              LDR      r2,[r0,#0x18]
00001c  638a              STR      r2,[r1,#0x38]
;;;306      CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
00001e  69c0              LDR      r0,[r0,#0x1c]
000020  63c8              STR      r0,[r1,#0x3c]
;;;307    }
000022  4770              BX       lr
;;;308    
                          ENDP

                  |L14.36|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_KeyStructInit PROC
;;;314      */
;;;315    void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  2100              MOVS     r1,#0
;;;316    {
;;;317      CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
;;;318      CRYP_KeyInitStruct->CRYP_Key0Right = 0;
000002  6001              STR      r1,[r0,#0]
;;;319      CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
000004  6041              STR      r1,[r0,#4]
;;;320      CRYP_KeyInitStruct->CRYP_Key1Right = 0;
000006  6081              STR      r1,[r0,#8]
;;;321      CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;322      CRYP_KeyInitStruct->CRYP_Key2Right = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;323      CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
00000c  6141              STR      r1,[r0,#0x14]
;;;324      CRYP_KeyInitStruct->CRYP_Key3Right = 0;
00000e  6181              STR      r1,[r0,#0x18]
000010  61c1              STR      r1,[r0,#0x1c]
;;;325    }
000012  4770              BX       lr
;;;326    /**
                          ENDP


                          AREA ||i.CRYP_PhaseConfig||, CODE, READONLY, ALIGN=2

                  CRYP_PhaseConfig PROC
;;;365      */
;;;366    void CRYP_PhaseConfig(uint32_t CRYP_Phase)
000000  4a03              LDR      r2,|L16.16|
;;;367    { uint32_t tempcr = 0;
;;;368    
;;;369      /* Check the parameter */
;;;370      assert_param(IS_CRYP_PHASE(CRYP_Phase));
;;;371    
;;;372      /* Get the CR register */
;;;373      tempcr = CRYP->CR;
000002  6811              LDR      r1,[r2,#0]
;;;374      
;;;375      /* Reset the phase configuration bits: GCMP_CCMPH */
;;;376      tempcr &= (uint32_t)(~CRYP_CR_GCM_CCMPH);
000004  f4213140          BIC      r1,r1,#0x30000
;;;377      /* Set the selected phase */
;;;378      tempcr |= (uint32_t)CRYP_Phase;
000008  4301              ORRS     r1,r1,r0
;;;379    
;;;380      /* Set the CR register */ 
;;;381      CRYP->CR = tempcr;    
00000a  6011              STR      r1,[r2,#0]
;;;382    }
00000c  4770              BX       lr
;;;383    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_RestoreContext||, CODE, READONLY, ALIGN=2

                  CRYP_RestoreContext PROC
;;;601      */
;;;602    void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
000000  4920              LDR      r1,|L17.132|
;;;603    {
;;;604    
;;;605      /* Configure the processor with the saved configuration */
;;;606      CRYP->CR = CRYP_ContextRestore->CR_CurrentConfig;
000002  6802              LDR      r2,[r0,#0]
000004  f8412b10          STR      r2,[r1],#0x10
;;;607    
;;;608      /* restore The key value */
;;;609      CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
000008  6942              LDR      r2,[r0,#0x14]
00000a  610a              STR      r2,[r1,#0x10]
;;;610      CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
00000c  6982              LDR      r2,[r0,#0x18]
00000e  614a              STR      r2,[r1,#0x14]
;;;611      CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
000010  69c2              LDR      r2,[r0,#0x1c]
000012  618a              STR      r2,[r1,#0x18]
;;;612      CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
000014  6a02              LDR      r2,[r0,#0x20]
000016  61ca              STR      r2,[r1,#0x1c]
;;;613      CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
000018  6a42              LDR      r2,[r0,#0x24]
00001a  620a              STR      r2,[r1,#0x20]
;;;614      CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
00001c  6a82              LDR      r2,[r0,#0x28]
00001e  624a              STR      r2,[r1,#0x24]
;;;615      CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
000020  6ac2              LDR      r2,[r0,#0x2c]
000022  628a              STR      r2,[r1,#0x28]
;;;616      CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
000024  6b02              LDR      r2,[r0,#0x30]
000026  62ca              STR      r2,[r1,#0x2c]
;;;617    
;;;618      /* and the initialization vectors. */
;;;619      CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
000028  6842              LDR      r2,[r0,#4]
00002a  630a              STR      r2,[r1,#0x30]
;;;620      CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
00002c  6882              LDR      r2,[r0,#8]
00002e  634a              STR      r2,[r1,#0x34]
;;;621      CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
000030  68c2              LDR      r2,[r0,#0xc]
000032  638a              STR      r2,[r1,#0x38]
;;;622      CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
000034  6902              LDR      r2,[r0,#0x10]
000036  63ca              STR      r2,[r1,#0x3c]
;;;623    
;;;624      /* Restore the content of context swap registers */
;;;625      CRYP->CSGCMCCM0R = CRYP_ContextRestore->CRYP_CSGCMCCMR[0];
000038  6b42              LDR      r2,[r0,#0x34]
00003a  640a              STR      r2,[r1,#0x40]
;;;626      CRYP->CSGCMCCM1R = CRYP_ContextRestore->CRYP_CSGCMCCMR[1];
00003c  6b82              LDR      r2,[r0,#0x38]
00003e  644a              STR      r2,[r1,#0x44]
;;;627      CRYP->CSGCMCCM2R = CRYP_ContextRestore->CRYP_CSGCMCCMR[2];
000040  6bc2              LDR      r2,[r0,#0x3c]
000042  648a              STR      r2,[r1,#0x48]
;;;628      CRYP->CSGCMCCM3R = CRYP_ContextRestore->CRYP_CSGCMCCMR[3];
000044  6c02              LDR      r2,[r0,#0x40]
000046  64ca              STR      r2,[r1,#0x4c]
;;;629      CRYP->CSGCMCCM4R = CRYP_ContextRestore->CRYP_CSGCMCCMR[4];
000048  6c42              LDR      r2,[r0,#0x44]
00004a  650a              STR      r2,[r1,#0x50]
;;;630      CRYP->CSGCMCCM5R = CRYP_ContextRestore->CRYP_CSGCMCCMR[5];
00004c  6c82              LDR      r2,[r0,#0x48]
00004e  654a              STR      r2,[r1,#0x54]
;;;631      CRYP->CSGCMCCM6R = CRYP_ContextRestore->CRYP_CSGCMCCMR[6];
000050  6cc2              LDR      r2,[r0,#0x4c]
000052  658a              STR      r2,[r1,#0x58]
;;;632      CRYP->CSGCMCCM7R = CRYP_ContextRestore->CRYP_CSGCMCCMR[7];
000054  6d02              LDR      r2,[r0,#0x50]
000056  65ca              STR      r2,[r1,#0x5c]
;;;633      
;;;634      CRYP->CSGCM0R = CRYP_ContextRestore->CRYP_CSGCMR[0];
000058  6d42              LDR      r2,[r0,#0x54]
00005a  660a              STR      r2,[r1,#0x60]
;;;635      CRYP->CSGCM1R = CRYP_ContextRestore->CRYP_CSGCMR[1];
00005c  6d82              LDR      r2,[r0,#0x58]
00005e  664a              STR      r2,[r1,#0x64]
;;;636      CRYP->CSGCM2R = CRYP_ContextRestore->CRYP_CSGCMR[2];
000060  6dc2              LDR      r2,[r0,#0x5c]
000062  668a              STR      r2,[r1,#0x68]
;;;637      CRYP->CSGCM3R = CRYP_ContextRestore->CRYP_CSGCMR[3];
000064  6e02              LDR      r2,[r0,#0x60]
000066  66ca              STR      r2,[r1,#0x6c]
;;;638      CRYP->CSGCM4R = CRYP_ContextRestore->CRYP_CSGCMR[4];
000068  6e42              LDR      r2,[r0,#0x64]
00006a  670a              STR      r2,[r1,#0x70]
;;;639      CRYP->CSGCM5R = CRYP_ContextRestore->CRYP_CSGCMR[5];
00006c  6e82              LDR      r2,[r0,#0x68]
00006e  674a              STR      r2,[r1,#0x74]
;;;640      CRYP->CSGCM6R = CRYP_ContextRestore->CRYP_CSGCMR[6];
000070  6ec2              LDR      r2,[r0,#0x6c]
000072  678a              STR      r2,[r1,#0x78]
;;;641      CRYP->CSGCM7R = CRYP_ContextRestore->CRYP_CSGCMR[7];
000074  6f00              LDR      r0,[r0,#0x70]
000076  67c8              STR      r0,[r1,#0x7c]
;;;642      
;;;643      /* Enable the cryptographic processor */
;;;644      CRYP->CR |= CRYP_CR_CRYPEN;
000078  f8510d10          LDR      r0,[r1,#-0x10]!
00007c  f4404000          ORR      r0,r0,#0x8000
000080  6008              STR      r0,[r1,#0]
;;;645    }
000082  4770              BX       lr
;;;646    /**
                          ENDP

                  |L17.132|
                          DCD      0x50060000

                          AREA ||i.CRYP_SaveContext||, CODE, READONLY, ALIGN=2

                  CRYP_SaveContext PROC
;;;496      */
;;;497    ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
000000  b578              PUSH     {r3-r6,lr}
;;;498                                 CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
;;;499    {
;;;500      __IO uint32_t timeout = 0;
000002  2200              MOVS     r2,#0
;;;501      uint32_t ckeckmask = 0, bitstatus;    
;;;502      ErrorStatus status = ERROR;
;;;503    
;;;504      /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
;;;505      CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
000004  9200              STR      r2,[sp,#0]
000006  4a33              LDR      r2,|L18.212|
000008  6913              LDR      r3,[r2,#0x10]
00000a  f0230301          BIC      r3,r3,#1
00000e  6113              STR      r3,[r2,#0x10]
;;;506        
;;;507      /* Wait until both the IN and OUT FIFOs are empty  
;;;508        (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
;;;509         BUSY bit is cleared. */
;;;510    
;;;511      if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
000010  6813              LDR      r3,[r2,#0]
000012  071b              LSLS     r3,r3,#28
000014  d501              BPL      |L18.26|
;;;512      { 
;;;513        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
000016  2311              MOVS     r3,#0x11
000018  e000              B        |L18.28|
                  |L18.26|
;;;514      }
;;;515      else /* AES or DES */
;;;516      {
;;;517        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
00001a  2315              MOVS     r3,#0x15
                  |L18.28|
;;;518      }           
;;;519       
;;;520      do 
;;;521      {
;;;522        bitstatus = CRYP->SR & ckeckmask;
;;;523        timeout++;
;;;524      }
;;;525      while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
00001c  f64f76ff          MOV      r6,#0xffff
                  |L18.32|
000020  6854              LDR      r4,[r2,#4]            ;522
000022  9d00              LDR      r5,[sp,#0]            ;523
000024  401c              ANDS     r4,r4,r3              ;522
000026  1c6d              ADDS     r5,r5,#1              ;523
000028  9500              STR      r5,[sp,#0]
00002a  42b5              CMP      r5,r6
00002c  d001              BEQ      |L18.50|
00002e  2c01              CMP      r4,#1
000030  d1f6              BNE      |L18.32|
                  |L18.50|
;;;526         
;;;527      if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
000032  6854              LDR      r4,[r2,#4]
000034  401c              ANDS     r4,r4,r3
000036  2c01              CMP      r4,#1
000038  d001              BEQ      |L18.62|
;;;528      {
;;;529        status = ERROR;
00003a  2000              MOVS     r0,#0
;;;530      }
;;;531      else
;;;532      {      
;;;533        /* Stop DMA transfers on the OUT FIFO by 
;;;534           - writing the DOEN bit to 0 in the CRYP_DMACR register 
;;;535           - and clear the CRYPEN bit. */
;;;536    
;;;537        CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
;;;538        CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
;;;539    
;;;540        /* Save the current configuration (bit 19, bit[17:16] and bits [9:2] in the CRYP_CR register) */
;;;541        CRYP_ContextSave->CR_CurrentConfig  = CRYP->CR & (CRYP_CR_GCM_CCMPH |
;;;542                                                          CRYP_CR_KEYSIZE  |
;;;543                                                          CRYP_CR_DATATYPE |
;;;544                                                          CRYP_CR_ALGOMODE |
;;;545                                                          CRYP_CR_ALGODIR);
;;;546    
;;;547        /* and, if not in ECB mode, the initialization vectors. */
;;;548        CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
;;;549        CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
;;;550        CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
;;;551        CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
;;;552    
;;;553        /* save The key value */
;;;554        CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
;;;555        CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
;;;556        CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
;;;557        CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
;;;558        CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
;;;559        CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
;;;560        CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
;;;561        CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
;;;562    
;;;563        /* Save the content of context swap registers */
;;;564        CRYP_ContextSave->CRYP_CSGCMCCMR[0] = CRYP->CSGCMCCM0R;
;;;565        CRYP_ContextSave->CRYP_CSGCMCCMR[1] = CRYP->CSGCMCCM1R;
;;;566        CRYP_ContextSave->CRYP_CSGCMCCMR[2] = CRYP->CSGCMCCM2R;
;;;567        CRYP_ContextSave->CRYP_CSGCMCCMR[3] = CRYP->CSGCMCCM3R;
;;;568        CRYP_ContextSave->CRYP_CSGCMCCMR[4] = CRYP->CSGCMCCM4R;
;;;569        CRYP_ContextSave->CRYP_CSGCMCCMR[5] = CRYP->CSGCMCCM5R;
;;;570        CRYP_ContextSave->CRYP_CSGCMCCMR[6] = CRYP->CSGCMCCM6R;
;;;571        CRYP_ContextSave->CRYP_CSGCMCCMR[7] = CRYP->CSGCMCCM7R;
;;;572        
;;;573        CRYP_ContextSave->CRYP_CSGCMR[0] = CRYP->CSGCM0R;
;;;574        CRYP_ContextSave->CRYP_CSGCMR[1] = CRYP->CSGCM1R;
;;;575        CRYP_ContextSave->CRYP_CSGCMR[2] = CRYP->CSGCM2R;
;;;576        CRYP_ContextSave->CRYP_CSGCMR[3] = CRYP->CSGCM3R;
;;;577        CRYP_ContextSave->CRYP_CSGCMR[4] = CRYP->CSGCM4R;
;;;578        CRYP_ContextSave->CRYP_CSGCMR[5] = CRYP->CSGCM5R;
;;;579        CRYP_ContextSave->CRYP_CSGCMR[6] = CRYP->CSGCM6R;
;;;580        CRYP_ContextSave->CRYP_CSGCMR[7] = CRYP->CSGCM7R;
;;;581        
;;;582       /* When needed, save the DMA status (pointers for IN and OUT messages, 
;;;583          number of remaining bytes, etc.) */
;;;584         
;;;585        status = SUCCESS;
;;;586      }
;;;587    
;;;588       return status;
;;;589    }
00003c  bd78              POP      {r3-r6,pc}
                  |L18.62|
00003e  6913              LDR      r3,[r2,#0x10]         ;537
000040  f0230302          BIC      r3,r3,#2              ;537
000044  6113              STR      r3,[r2,#0x10]         ;537
000046  6813              LDR      r3,[r2,#0]            ;538
000048  f4234300          BIC      r3,r3,#0x8000         ;538
00004c  6013              STR      r3,[r2,#0]            ;538
00004e  6813              LDR      r3,[r2,#0]            ;541
000050  4c21              LDR      r4,|L18.216|
000052  4023              ANDS     r3,r3,r4              ;541
000054  6003              STR      r3,[r0,#0]            ;548
000056  6c13              LDR      r3,[r2,#0x40]         ;548
000058  6043              STR      r3,[r0,#4]            ;549
00005a  6c53              LDR      r3,[r2,#0x44]         ;549
00005c  6083              STR      r3,[r0,#8]            ;550
00005e  6c93              LDR      r3,[r2,#0x48]         ;550
000060  60c3              STR      r3,[r0,#0xc]          ;551
000062  6cd3              LDR      r3,[r2,#0x4c]         ;551
000064  6103              STR      r3,[r0,#0x10]         ;554
000066  680b              LDR      r3,[r1,#0]            ;554
000068  6143              STR      r3,[r0,#0x14]         ;555
00006a  684b              LDR      r3,[r1,#4]            ;555
00006c  6183              STR      r3,[r0,#0x18]         ;556
00006e  688b              LDR      r3,[r1,#8]            ;556
000070  61c3              STR      r3,[r0,#0x1c]         ;557
000072  68cb              LDR      r3,[r1,#0xc]          ;557
000074  6203              STR      r3,[r0,#0x20]         ;558
000076  690b              LDR      r3,[r1,#0x10]         ;558
000078  6243              STR      r3,[r0,#0x24]         ;559
00007a  694b              LDR      r3,[r1,#0x14]         ;559
00007c  6283              STR      r3,[r0,#0x28]         ;560
00007e  698b              LDR      r3,[r1,#0x18]         ;560
000080  62c3              STR      r3,[r0,#0x2c]         ;561
000082  69c9              LDR      r1,[r1,#0x1c]         ;561
000084  6301              STR      r1,[r0,#0x30]         ;564
000086  6d11              LDR      r1,[r2,#0x50]         ;564
000088  6341              STR      r1,[r0,#0x34]         ;565
00008a  6d51              LDR      r1,[r2,#0x54]         ;565
00008c  6381              STR      r1,[r0,#0x38]         ;566
00008e  6d91              LDR      r1,[r2,#0x58]         ;566
000090  63c1              STR      r1,[r0,#0x3c]         ;567
000092  6dd1              LDR      r1,[r2,#0x5c]         ;567
000094  6401              STR      r1,[r0,#0x40]         ;568
000096  6e11              LDR      r1,[r2,#0x60]         ;568
000098  6441              STR      r1,[r0,#0x44]         ;569
00009a  6e51              LDR      r1,[r2,#0x64]         ;569
00009c  6481              STR      r1,[r0,#0x48]         ;570
00009e  6e91              LDR      r1,[r2,#0x68]         ;570
0000a0  64c1              STR      r1,[r0,#0x4c]         ;571
0000a2  6ed1              LDR      r1,[r2,#0x6c]         ;571
0000a4  6501              STR      r1,[r0,#0x50]         ;573
0000a6  6f11              LDR      r1,[r2,#0x70]         ;573
0000a8  6541              STR      r1,[r0,#0x54]         ;574
0000aa  6f51              LDR      r1,[r2,#0x74]         ;574
0000ac  6581              STR      r1,[r0,#0x58]         ;575
0000ae  6f91              LDR      r1,[r2,#0x78]         ;575
0000b0  65c1              STR      r1,[r0,#0x5c]         ;576
0000b2  6fd1              LDR      r1,[r2,#0x7c]         ;576
0000b4  6601              STR      r1,[r0,#0x60]         ;577
0000b6  f8d21080          LDR      r1,[r2,#0x80]         ;577
0000ba  6641              STR      r1,[r0,#0x64]         ;578
0000bc  f8d21084          LDR      r1,[r2,#0x84]         ;578
0000c0  6681              STR      r1,[r0,#0x68]         ;579
0000c2  f8d21088          LDR      r1,[r2,#0x88]         ;579
0000c6  66c1              STR      r1,[r0,#0x6c]         ;580
0000c8  f8d2108c          LDR      r1,[r2,#0x8c]         ;580
0000cc  6701              STR      r1,[r0,#0x70]         ;585
0000ce  2001              MOVS     r0,#1                 ;585
0000d0  bd78              POP      {r3-r6,pc}
;;;590    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L18.212|
                          DCD      0x50060000
                  |L18.216|
                          DCD      0x000b03fc

                          AREA ||i.CRYP_StructInit||, CODE, READONLY, ALIGN=1

                  CRYP_StructInit PROC
;;;273      */
;;;274    void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
000000  2100              MOVS     r1,#0
;;;275    {
;;;276      /* Initialize the CRYP_AlgoDir member */
;;;277      CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
;;;278    
;;;279      /* initialize the CRYP_AlgoMode member */
;;;280      CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
000002  6001              STR      r1,[r0,#0]
;;;281    
;;;282      /* initialize the CRYP_DataType member */
;;;283      CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
000004  6041              STR      r1,[r0,#4]
;;;284      
;;;285      /* Initialize the CRYP_KeySize member */
;;;286      CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;287    }
00000a  4770              BX       lr
;;;288    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_cryp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_cryp_c_459f21d3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH|
#line 144
|__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
