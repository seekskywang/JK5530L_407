; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_dcmi.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_dcmi.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=538 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_dcmi.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_dcmi.c]
                          THUMB

                          AREA ||i.DCMI_CROPCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CROPCmd PROC
;;;222      */
;;;223    void DCMI_CROPCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L1.24|
;;;224    {
;;;225      /* Check the parameters */
;;;226      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;227        
;;;228      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;229      {
;;;230        /* Enable the DCMI Crop feature */
;;;231        DCMI->CR |= (uint32_t)DCMI_CR_CROP;
;;;232      }
;;;233      else
;;;234      {
;;;235        /* Disable the DCMI Crop feature */
;;;236        DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L1.14|
000008  f0400004          ORR      r0,r0,#4              ;231
00000c  e001              B        |L1.18|
                  |L1.14|
00000e  f0200004          BIC      r0,r0,#4
                  |L1.18|
000012  6008              STR      r0,[r1,#0]            ;231
;;;237      }
;;;238    }
000014  4770              BX       lr
;;;239    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_CROPConfig||, CODE, READONLY, ALIGN=2

                  DCMI_CROPConfig PROC
;;;204      */
;;;205    void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
000000  6801              LDR      r1,[r0,#0]
;;;206    {  
;;;207      /* Sets the CROP window coordinates */
;;;208      DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
000002  ea4f4231          ROR      r2,r1,#16
000006  4903              LDR      r1,|L2.20|
000008  620a              STR      r2,[r1,#0x20]
;;;209                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
;;;210    
;;;211      /* Sets the CROP window size */
;;;212      DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
00000a  6840              LDR      r0,[r0,#4]
00000c  ea4f4030          ROR      r0,r0,#16
000010  6248              STR      r0,[r1,#0x24]
;;;213                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
;;;214    }
000012  4770              BX       lr
;;;215    
                          ENDP

                  |L2.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_CaptureCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CaptureCmd PROC
;;;321      */
;;;322    void DCMI_CaptureCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L3.24|
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;326        
;;;327      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;328      {
;;;329        /* Enable the DCMI Capture */
;;;330        DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
;;;331      }
;;;332      else
;;;333      {
;;;334        /* Disable the DCMI Capture */
;;;335        DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L3.14|
000008  f0400001          ORR      r0,r0,#1              ;330
00000c  e001              B        |L3.18|
                  |L3.14|
00000e  f0200001          BIC      r0,r0,#1
                  |L3.18|
000012  6008              STR      r0,[r1,#0]            ;330
;;;336      }
;;;337    }
000014  4770              BX       lr
;;;338    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearFlag||, CODE, READONLY, ALIGN=2

                  DCMI_ClearFlag PROC
;;;460      */
;;;461    void DCMI_ClearFlag(uint16_t DCMI_FLAG)
000000  4901              LDR      r1,|L4.8|
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
;;;465      
;;;466      /* Clear the flag by writing in the ICR register 1 in the corresponding 
;;;467      Flag position*/
;;;468      
;;;469      DCMI->ICR = DCMI_FLAG;
000002  6148              STR      r0,[r1,#0x14]
;;;470    }
000004  4770              BX       lr
;;;471    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DCMI_ClearITPendingBit PROC
;;;514      */
;;;515    void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
000000  4901              LDR      r1,|L5.8|
;;;516    {
;;;517      /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
;;;518      corresponding pending Bit position*/
;;;519      
;;;520      DCMI->ICR = DCMI_IT;
000002  6148              STR      r0,[r1,#0x14]
;;;521    }
000004  4770              BX       lr
;;;522    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_Cmd||, CODE, READONLY, ALIGN=2

                  DCMI_Cmd PROC
;;;298      */
;;;299    void DCMI_Cmd(FunctionalState NewState)
000000  4905              LDR      r1,|L6.24|
;;;300    {
;;;301      /* Check the parameters */
;;;302      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;303      
;;;304      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;305      {
;;;306        /* Enable the DCMI by setting ENABLE bit */
;;;307        DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
;;;308      }
;;;309      else
;;;310      {
;;;311        /* Disable the DCMI by clearing ENABLE bit */
;;;312        DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L6.14|
000008  f4404080          ORR      r0,r0,#0x4000         ;307
00000c  e001              B        |L6.18|
                  |L6.14|
00000e  f4204080          BIC      r0,r0,#0x4000
                  |L6.18|
000012  6008              STR      r0,[r1,#0]            ;307
;;;313      }
;;;314    }
000014  4770              BX       lr
;;;315    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_DeInit||, CODE, READONLY, ALIGN=2

                  DCMI_DeInit PROC
;;;125      */
;;;126    void DCMI_DeInit(void)
000000  4805              LDR      r0,|L7.24|
;;;127    {
;;;128      DCMI->CR = 0x0;
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
;;;129      DCMI->IER = 0x0;
000006  60c1              STR      r1,[r0,#0xc]
;;;130      DCMI->ICR = 0x1F;
000008  221f              MOVS     r2,#0x1f
00000a  6142              STR      r2,[r0,#0x14]
;;;131      DCMI->ESCR = 0x0;
00000c  6181              STR      r1,[r0,#0x18]
;;;132      DCMI->ESUR = 0x0;
00000e  61c1              STR      r1,[r0,#0x1c]
;;;133      DCMI->CWSTRTR = 0x0;
000010  6201              STR      r1,[r0,#0x20]
;;;134      DCMI->CWSIZER = 0x0;
000012  6241              STR      r1,[r0,#0x24]
;;;135    }
000014  4770              BX       lr
;;;136    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetFlagStatus PROC
;;;413      */
;;;414    FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
000000  4602              MOV      r2,r0
;;;415    {
;;;416      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;417      uint32_t dcmireg, tempreg = 0;
;;;418    
;;;419      /* Check the parameters */
;;;420      assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
;;;421      
;;;422      /* Get the DCMI register index */
;;;423      dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
;;;424      
;;;425      if (dcmireg == 0x00) /* The FLAG is in RISR register */
;;;426      {
;;;427        tempreg= DCMI->RISR;
000004  4906              LDR      r1,|L8.32|
000006  0b13              LSRS     r3,r2,#12             ;423
000008  d006              BEQ      |L8.24|
;;;428      }
;;;429      else if (dcmireg == 0x02) /* The FLAG is in SR register */
00000a  2b02              CMP      r3,#2
00000c  d006              BEQ      |L8.28|
;;;430      {
;;;431        tempreg = DCMI->SR;
;;;432      }
;;;433      else /* The FLAG is in MISR register */
;;;434      {
;;;435        tempreg = DCMI->MISR;
00000e  6909              LDR      r1,[r1,#0x10]
                  |L8.16|
;;;436      }
;;;437      
;;;438      if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
000010  4211              TST      r1,r2
000012  d000              BEQ      |L8.22|
;;;439      {
;;;440        bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L8.22|
;;;441      }
;;;442      else
;;;443      {
;;;444        bitstatus = RESET;
;;;445      }
;;;446      /* Return the DCMI_FLAG status */
;;;447      return  bitstatus;
;;;448    }
000016  4770              BX       lr
                  |L8.24|
000018  6889              LDR      r1,[r1,#8]            ;427
00001a  e7f9              B        |L8.16|
                  |L8.28|
00001c  6849              LDR      r1,[r1,#4]            ;431
00001e  e7f7              B        |L8.16|
;;;449    
                          ENDP

                  |L8.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetITStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetITStatus PROC
;;;482      */
;;;483    ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
000000  4903              LDR      r1,|L9.16|
;;;484    {
000002  4602              MOV      r2,r0
;;;485      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;486      uint32_t itstatus = 0;
;;;487      
;;;488      /* Check the parameters */
;;;489      assert_param(IS_DCMI_GET_IT(DCMI_IT));
;;;490      
;;;491      itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
000006  6909              LDR      r1,[r1,#0x10]
000008  4211              TST      r1,r2
00000a  d000              BEQ      |L9.14|
;;;492      
;;;493      if ((itstatus != (uint16_t)RESET))
;;;494      {
;;;495        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;496      }
;;;497      else
;;;498      {
;;;499        bitstatus = RESET;
;;;500      }
;;;501      return bitstatus;
;;;502    }
00000e  4770              BX       lr
;;;503    
                          ENDP

                  |L9.16|
                          DCD      0x50050000

                          AREA ||i.DCMI_ITConfig||, CODE, READONLY, ALIGN=2

                  DCMI_ITConfig PROC
;;;376      */
;;;377    void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
000000  4a05              LDR      r2,|L10.24|
;;;378    {
;;;379      /* Check the parameters */
;;;380      assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
;;;381      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;382      
;;;383      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;384      {
;;;385        /* Enable the Interrupt sources */
;;;386        DCMI->IER |= DCMI_IT;
;;;387      }
;;;388      else
;;;389      {
;;;390        /* Disable the Interrupt sources */
;;;391        DCMI->IER &= (uint16_t)(~DCMI_IT);
000004  68d1              LDR      r1,[r2,#0xc]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;386
00000a  e002              B        |L10.18|
                  |L10.12|
00000c  43c0              MVNS     r0,r0
00000e  b280              UXTH     r0,r0
000010  4001              ANDS     r1,r1,r0
                  |L10.18|
000012  60d1              STR      r1,[r2,#0xc]          ;386
;;;392      }  
;;;393    }
000014  4770              BX       lr
;;;394    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_Init||, CODE, READONLY, ALIGN=2

                  DCMI_Init PROC
;;;142      */
;;;143    void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;144    {
;;;145      uint32_t temp = 0x0;
;;;146      
;;;147      /* Check the parameters */
;;;148      assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
;;;149      assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
;;;150      assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
;;;151      assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
;;;152      assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
;;;153      assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
;;;154      assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
;;;155    
;;;156      /* The DCMI configuration registers should be programmed correctly before 
;;;157      enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
;;;158      DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
000002  4a0d              LDR      r2,|L11.56|
000004  6811              LDR      r1,[r2,#0]
000006  f2440301          MOV      r3,#0x4001
00000a  4399              BICS     r1,r1,r3
00000c  6011              STR      r1,[r2,#0]
;;;159       
;;;160      /* Reset the old DCMI configuration */
;;;161      temp = DCMI->CR;
00000e  6813              LDR      r3,[r2,#0]
;;;162      
;;;163      temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
000010  f64071f2          MOV      r1,#0xff2
000014  438b              BICS     r3,r3,r1
;;;164                          DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
;;;165                          DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
;;;166                      
;;;167      /* Sets the new configuration of the DCMI peripheral */
;;;168      temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
000016  8801              LDRH     r1,[r0,#0]
000018  8844              LDRH     r4,[r0,#2]
00001a  88c5              LDRH     r5,[r0,#6]
00001c  4321              ORRS     r1,r1,r4
00001e  8884              LDRH     r4,[r0,#4]
000020  432c              ORRS     r4,r4,r5
000022  4321              ORRS     r1,r1,r4
000024  8904              LDRH     r4,[r0,#8]
000026  4321              ORRS     r1,r1,r4
000028  8944              LDRH     r4,[r0,#0xa]
00002a  8980              LDRH     r0,[r0,#0xc]
00002c  4321              ORRS     r1,r1,r4
00002e  4301              ORRS     r1,r1,r0
000030  4319              ORRS     r1,r1,r3
;;;169                         DCMI_InitStruct->DCMI_SynchroMode |
;;;170                         DCMI_InitStruct->DCMI_PCKPolarity |
;;;171                         DCMI_InitStruct->DCMI_VSPolarity |
;;;172                         DCMI_InitStruct->DCMI_HSPolarity |
;;;173                         DCMI_InitStruct->DCMI_CaptureRate |
;;;174                         DCMI_InitStruct->DCMI_ExtendedDataMode);
;;;175    
;;;176      DCMI->CR = temp;                              
000032  6011              STR      r1,[r2,#0]
;;;177    }
000034  bd30              POP      {r4,r5,pc}
;;;178    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      0x50050000

                          AREA ||i.DCMI_JPEGCmd||, CODE, READONLY, ALIGN=2

                  DCMI_JPEGCmd PROC
;;;260      */
;;;261    void DCMI_JPEGCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L12.24|
;;;262    {
;;;263      /* Check the parameters */
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265     
;;;266      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;267      {
;;;268        /* Enable the DCMI JPEG format */
;;;269        DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
;;;270      }
;;;271      else
;;;272      {
;;;273        /* Disable the DCMI JPEG format */
;;;274        DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L12.14|
000008  f0400008          ORR      r0,r0,#8              ;269
00000c  e001              B        |L12.18|
                  |L12.14|
00000e  f0200008          BIC      r0,r0,#8
                  |L12.18|
000012  6008              STR      r0,[r1,#0]            ;269
;;;275      }
;;;276    }
000014  4770              BX       lr
;;;277    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_ReadData||, CODE, READONLY, ALIGN=2

                  DCMI_ReadData PROC
;;;343      */
;;;344    uint32_t DCMI_ReadData(void)
000000  4801              LDR      r0,|L13.8|
;;;345    {
;;;346      return DCMI->DR;
000002  6a80              LDR      r0,[r0,#0x28]
;;;347    }
000004  4770              BX       lr
;;;348    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_SetEmbeddedSynchroCodes||, CODE, READONLY, ALIGN=2

                  DCMI_SetEmbeddedSynchroCodes PROC
;;;245      */
;;;246    void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
000000  78c1              LDRB     r1,[r0,#3]
;;;247    {
;;;248      DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
000002  6800              LDR      r0,[r0,#0]
000004  f361601f          BFI      r0,r1,#24,#8
000008  4901              LDR      r1,|L14.16|
00000a  6188              STR      r0,[r1,#0x18]
;;;249                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
;;;250                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
;;;251                              ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
;;;252    }
00000c  4770              BX       lr
;;;253    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x50050000

                          AREA ||i.DCMI_StructInit||, CODE, READONLY, ALIGN=1

                  DCMI_StructInit PROC
;;;184      */
;;;185    void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
000000  2100              MOVS     r1,#0
;;;186    {
;;;187      /* Set the default configuration */
;;;188      DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
000002  8001              STRH     r1,[r0,#0]
;;;189      DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
000004  8041              STRH     r1,[r0,#2]
;;;190      DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
000006  8081              STRH     r1,[r0,#4]
;;;191      DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;192      DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
00000a  8101              STRH     r1,[r0,#8]
;;;193      DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
00000c  8141              STRH     r1,[r0,#0xa]
;;;194      DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
00000e  8181              STRH     r1,[r0,#0xc]
;;;195    }
000010  4770              BX       lr
;;;196    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_dcmi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH|
#line 144
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
