; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_fsmc.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_fsmc.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=537 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_fsmc.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FSMC_ClearFlag PROC
;;;861      */
;;;862    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;863    {
;;;864     /* Check the parameters */
;;;865      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;866      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;867        
;;;868      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d007              BEQ      |L1.24|
;;;869      {
;;;870        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;871      }  
;;;872      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d008              BEQ      |L1.32|
;;;873      {
;;;874        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;875      }
;;;876      /* FSMC_Bank4_PCCARD*/
;;;877      else
;;;878      {
;;;879        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
00000e  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.18|
000012  4388              BICS     r0,r0,r1
000014  6010              STR      r0,[r2,#0]
;;;880      }
;;;881    }
000016  4770              BX       lr
                  |L1.24|
000018  6e50              LDR      r0,[r2,#0x64]         ;870
00001a  4388              BICS     r0,r0,r1              ;870
00001c  6650              STR      r0,[r2,#0x64]         ;870
00001e  4770              BX       lr
                  |L1.32|
000020  f8520f84          LDR      r0,[r2,#0x84]!        ;874
000024  e7f5              B        |L1.18|
;;;882    
                          ENDP


                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FSMC_ClearITPendingBit PROC
;;;947      */
;;;948    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;949    {
;;;950      /* Check the parameters */
;;;951      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;952      assert_param(IS_FSMC_IT(FSMC_IT));
;;;953        
;;;954      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d008              BEQ      |L2.26|
;;;955      {
;;;956        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;957      }  
;;;958      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00a              BEQ      |L2.36|
;;;959      {
;;;960        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;961      }
;;;962      /* FSMC_Bank4_PCCARD*/
;;;963      else
;;;964      {
;;;965        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00000e  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L2.18|
000012  ea2000d1          BIC      r0,r0,r1,LSR #3
000016  6010              STR      r0,[r2,#0]
;;;966      }
;;;967    }
000018  4770              BX       lr
                  |L2.26|
00001a  6e50              LDR      r0,[r2,#0x64]         ;956
00001c  ea2000d1          BIC      r0,r0,r1,LSR #3       ;956
000020  6650              STR      r0,[r2,#0x64]         ;956
000022  4770              BX       lr
                  |L2.36|
000024  f8520f84          LDR      r0,[r2,#0x84]!        ;960
000028  e7f3              B        |L2.18|
;;;968    
                          ENDP


                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=1

                  FSMC_GetECC PROC
;;;545      */
;;;546    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;547    {
;;;548      uint32_t eccval = 0x00000000;
;;;549      
;;;550      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d002              BEQ      |L3.14|
;;;551      {
;;;552        /* Get the ECCR2 register value */
;;;553        eccval = FSMC_Bank2->ECCR2;
;;;554      }
;;;555      else
;;;556      {
;;;557        /* Get the ECCR3 register value */
;;;558        eccval = FSMC_Bank3->ECCR3;
000008  f8d10094          LDR      r0,[r1,#0x94]
;;;559      }
;;;560      /* Return the error correction code value */
;;;561      return(eccval);
;;;562    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6f48              LDR      r0,[r1,#0x74]         ;553
000010  4770              BX       lr
;;;563    /**
                          ENDP


                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetFlagStatus PROC
;;;811      */
;;;812    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  4603              MOV      r3,r0
;;;813    {
;;;814      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;815      uint32_t tmpsr = 0x00000000;
;;;816      
;;;817      /* Check the parameters */
;;;818      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;819      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;820      
;;;821      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;822      {
;;;823        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;821
00000a  d008              BEQ      |L4.30|
;;;824      }  
;;;825      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d007              BEQ      |L4.34|
;;;826      {
;;;827        tmpsr = FSMC_Bank3->SR3;
;;;828      }
;;;829      /* FSMC_Bank4_PCCARD*/
;;;830      else
;;;831      {
;;;832        tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L4.22|
;;;833      } 
;;;834      
;;;835      /* Get the flag status */
;;;836      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000016  420a              TST      r2,r1
000018  d000              BEQ      |L4.28|
;;;837      {
;;;838        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;839      }
;;;840      else
;;;841      {
;;;842        bitstatus = RESET;
;;;843      }
;;;844      /* Return the flag status */
;;;845      return bitstatus;
;;;846    }
00001c  4770              BX       lr
                  |L4.30|
00001e  6e52              LDR      r2,[r2,#0x64]         ;823
000020  e7f9              B        |L4.22|
                  |L4.34|
000022  f8d22084          LDR      r2,[r2,#0x84]         ;827
000026  e7f6              B        |L4.22|
;;;847    
                          ENDP


                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetITStatus PROC
;;;896      */
;;;897    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  4603              MOV      r3,r0
;;;898    {
;;;899      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;900      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;901      
;;;902      /* Check the parameters */
;;;903      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;904      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;905      
;;;906      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;907      {
;;;908        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;906
00000a  d00c              BEQ      |L5.38|
;;;909      }  
;;;910      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d00b              BEQ      |L5.42|
;;;911      {
;;;912        tmpsr = FSMC_Bank3->SR3;
;;;913      }
;;;914      /* FSMC_Bank4_PCCARD*/
;;;915      else
;;;916      {
;;;917        tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L5.22|
;;;918      } 
;;;919      
;;;920      itstatus = tmpsr & FSMC_IT;
000016  420a              TST      r2,r1
;;;921      
;;;922      itenable = tmpsr & (FSMC_IT >> 3);
000018  ea0201d1          AND      r1,r2,r1,LSR #3
;;;923      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
00001c  d002              BEQ      |L5.36|
00001e  2900              CMP      r1,#0
000020  d000              BEQ      |L5.36|
;;;924      {
;;;925        bitstatus = SET;
000022  2001              MOVS     r0,#1
                  |L5.36|
;;;926      }
;;;927      else
;;;928      {
;;;929        bitstatus = RESET;
;;;930      }
;;;931      return bitstatus; 
;;;932    }
000024  4770              BX       lr
                  |L5.38|
000026  6e52              LDR      r2,[r2,#0x64]         ;908
000028  e7f5              B        |L5.22|
                  |L5.42|
00002a  f8d22084          LDR      r2,[r2,#0x84]         ;912
00002e  e7f2              B        |L5.22|
;;;933    
                          ENDP


                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FSMC_ITConfig PROC
;;;751      */
;;;752    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;753    {
;;;754      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;755      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;756      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;757      
;;;758      if (NewState != DISABLE)
;;;759      {
;;;760        /* Enable the selected FSMC_Bank2 interrupts */
;;;761        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;762        {
;;;763          FSMC_Bank2->SR2 |= FSMC_IT;
;;;764        }
;;;765        /* Enable the selected FSMC_Bank3 interrupts */
;;;766        else if (FSMC_Bank == FSMC_Bank3_NAND)
000002  f44f7480          MOV      r4,#0x100
000006  f04f4320          MOV      r3,#0xa0000000        ;763
00000a  b172              CBZ      r2,|L6.42|
00000c  2810              CMP      r0,#0x10              ;761
00000e  d004              BEQ      |L6.26|
000010  42a0              CMP      r0,r4
000012  d105              BNE      |L6.32|
;;;767        {
;;;768          FSMC_Bank3->SR3 |= FSMC_IT;
000014  f8530f84          LDR      r0,[r3,#0x84]!
000018  e004              B        |L6.36|
                  |L6.26|
00001a  6e58              LDR      r0,[r3,#0x64]         ;763
00001c  4308              ORRS     r0,r0,r1              ;763
00001e  e00d              B        |L6.60|
                  |L6.32|
;;;769        }
;;;770        /* Enable the selected FSMC_Bank4 interrupts */
;;;771        else
;;;772        {
;;;773          FSMC_Bank4->SR4 |= FSMC_IT;    
000020  f8530fa4          LDR      r0,[r3,#0xa4]!
                  |L6.36|
000024  4308              ORRS     r0,r0,r1
                  |L6.38|
000026  6018              STR      r0,[r3,#0]
;;;774        }
;;;775      }
;;;776      else
;;;777      {
;;;778        /* Disable the selected FSMC_Bank2 interrupts */
;;;779        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;780        {
;;;781          
;;;782          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;783        }
;;;784        /* Disable the selected FSMC_Bank3 interrupts */
;;;785        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;786        {
;;;787          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;788        }
;;;789        /* Disable the selected FSMC_Bank4 interrupts */
;;;790        else
;;;791        {
;;;792          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;793        }
;;;794      }
;;;795    }
000028  bd10              POP      {r4,pc}
                  |L6.42|
00002a  2810              CMP      r0,#0x10              ;779
00002c  d004              BEQ      |L6.56|
00002e  42a0              CMP      r0,r4                 ;785
000030  d106              BNE      |L6.64|
000032  f8530f84          LDR      r0,[r3,#0x84]!        ;787
000036  e005              B        |L6.68|
                  |L6.56|
000038  6e58              LDR      r0,[r3,#0x64]         ;782
00003a  4388              BICS     r0,r0,r1              ;782
                  |L6.60|
00003c  6658              STR      r0,[r3,#0x64]         ;763
00003e  bd10              POP      {r4,pc}
                  |L6.64|
000040  f8530fa4          LDR      r0,[r3,#0xa4]!        ;792
                  |L6.68|
000044  4388              BICS     r0,r0,r1              ;787
000046  e7ee              B        |L6.38|
;;;796    
                          ENDP


                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;466      */
;;;467    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;468    {
000004  b151              CBZ      r1,|L7.28|
;;;469      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;470      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;471      
;;;472      if (NewState != DISABLE)
;;;473      {
;;;474        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;475        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L7.20|
;;;476        {
;;;477          FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
;;;478        }
;;;479        else
;;;480        {
;;;481          FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400004          ORR      r0,r0,#4
000012  e009              B        |L7.40|
                  |L7.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;477
000016  f0400004          ORR      r0,r0,#4              ;477
00001a  e009              B        |L7.48|
                  |L7.28|
;;;482        }
;;;483      }
;;;484      else
;;;485      {
;;;486        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;487        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;488        {
;;;489          FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
00001c  4905              LDR      r1,|L7.52|
00001e  2810              CMP      r0,#0x10              ;487
000020  d004              BEQ      |L7.44|
;;;490        }
;;;491        else
;;;492        {
;;;493          FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L7.40|
000028  6010              STR      r0,[r2,#0]            ;481
;;;494        }
;;;495      }
;;;496    }
00002a  4770              BX       lr
                  |L7.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;489
00002e  4008              ANDS     r0,r0,r1              ;489
                  |L7.48|
000030  6610              STR      r0,[r2,#0x60]         ;477
000032  4770              BX       lr
;;;497    /**
                          ENDP

                  |L7.52|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDDeInit PROC
;;;341      */
;;;342    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  b510              PUSH     {r4,lr}
;;;343    {
;;;344      /* Check the parameter */
;;;345      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;346      
;;;347      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;348      {
;;;349        /* Set the FSMC_Bank2 registers to their reset values */
;;;350        FSMC_Bank2->PCR2 = 0x00000018;
000002  2318              MOVS     r3,#0x18
;;;351        FSMC_Bank2->SR2 = 0x00000040;
000004  2440              MOVS     r4,#0x40
000006  f04f4120          MOV      r1,#0xa0000000        ;350
;;;352        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;347
000010  d005              BEQ      |L8.30|
;;;353        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;354      }
;;;355      /* FSMC_Bank3_NAND */  
;;;356      else
;;;357      {
;;;358        /* Set the FSMC_Bank3 registers to their reset values */
;;;359        FSMC_Bank3->PCR3 = 0x00000018;
000012  f8413f80          STR      r3,[r1,#0x80]!
;;;360        FSMC_Bank3->SR3 = 0x00000040;
000016  604c              STR      r4,[r1,#4]
;;;361        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000018  608a              STR      r2,[r1,#8]
;;;362        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00001a  60ca              STR      r2,[r1,#0xc]
;;;363      }  
;;;364    }
00001c  bd10              POP      {r4,pc}
                  |L8.30|
00001e  660b              STR      r3,[r1,#0x60]         ;350
000020  664c              STR      r4,[r1,#0x64]         ;351
000022  668a              STR      r2,[r1,#0x68]         ;352
000024  66ca              STR      r2,[r1,#0x6c]         ;353
000026  bd10              POP      {r4,pc}
;;;365    
                          ENDP


                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;506      */
;;;507    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;508    {
000004  b151              CBZ      r1,|L9.28|
;;;509      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;510      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;511      
;;;512      if (NewState != DISABLE)
;;;513      {
;;;514        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;515        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L9.20|
;;;516        {
;;;517          FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
;;;518        }
;;;519        else
;;;520        {
;;;521          FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400040          ORR      r0,r0,#0x40
000012  e009              B        |L9.40|
                  |L9.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;517
000016  f0400040          ORR      r0,r0,#0x40           ;517
00001a  e009              B        |L9.48|
                  |L9.28|
;;;522        }
;;;523      }
;;;524      else
;;;525      {
;;;526        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;527        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;528        {
;;;529          FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
00001c  4905              LDR      r1,|L9.52|
00001e  2810              CMP      r0,#0x10              ;527
000020  d004              BEQ      |L9.44|
;;;530        }
;;;531        else
;;;532        {
;;;533          FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L9.40|
000028  6010              STR      r0,[r2,#0]            ;521
;;;534        }
;;;535      }
;;;536    }
00002a  4770              BX       lr
                  |L9.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;529
00002e  4008              ANDS     r0,r0,r1              ;529
                  |L9.48|
000030  6610              STR      r0,[r2,#0x60]         ;517
000032  4770              BX       lr
;;;537    
                          ENDP

                  |L9.52|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDInit PROC
;;;372      */
;;;373    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;374    {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;375      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;376        
;;;377      /* Check the parameters */
;;;378      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;379      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;380      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;381      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;382      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;383      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;384      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;385      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;386      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;387      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;388      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;389      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;390      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;391      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;392      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;393      
;;;394      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;395      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  ea412142          ORR      r1,r1,r2,LSL #9
000016  6982              LDR      r2,[r0,#0x18]
000018  ea413142          ORR      r1,r1,r2,LSL #13
00001c  f0410408          ORR      r4,r1,#8
;;;396                PCR_MEMORYTYPE_NAND |
;;;397                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;398                FSMC_NANDInitStruct->FSMC_ECC |
;;;399                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;400                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;401                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;402                
;;;403      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;404      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000020  69c1              LDR      r1,[r0,#0x1c]
000022  e9d12300          LDRD     r2,r3,[r1,#0]
000026  ea422203          ORR      r2,r2,r3,LSL #8
00002a  890b              LDRH     r3,[r1,#8]
00002c  7b09              LDRB     r1,[r1,#0xc]
00002e  041b              LSLS     r3,r3,#16
000030  ea436101          ORR      r1,r3,r1,LSL #24
000034  430a              ORRS     r2,r2,r1
;;;405                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;406                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;407                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;408                
;;;409      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;410      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000036  6a01              LDR      r1,[r0,#0x20]
000038  e9d13500          LDRD     r3,r5,[r1,#0]
00003c  ea432305          ORR      r3,r3,r5,LSL #8
000040  890d              LDRH     r5,[r1,#8]
000042  7b09              LDRB     r1,[r1,#0xc]
000044  042d              LSLS     r5,r5,#16
000046  ea456101          ORR      r1,r5,r1,LSL #24
00004a  430b              ORRS     r3,r3,r1
;;;411                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;412                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;413                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;414      
;;;415      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;416      {
;;;417        /* FSMC_Bank2_NAND registers configuration */
;;;418        FSMC_Bank2->PCR2 = tmppcr;
00004c  6801              LDR      r1,[r0,#0]
00004e  f04f4020          MOV      r0,#0xa0000000
000052  2910              CMP      r1,#0x10              ;415
000054  d004              BEQ      |L10.96|
;;;419        FSMC_Bank2->PMEM2 = tmppmem;
;;;420        FSMC_Bank2->PATT2 = tmppatt;
;;;421      }
;;;422      else
;;;423      {
;;;424        /* FSMC_Bank3_NAND registers configuration */
;;;425        FSMC_Bank3->PCR3 = tmppcr;
000056  f8404f80          STR      r4,[r0,#0x80]!
;;;426        FSMC_Bank3->PMEM3 = tmppmem;
00005a  6082              STR      r2,[r0,#8]
;;;427        FSMC_Bank3->PATT3 = tmppatt;
00005c  60c3              STR      r3,[r0,#0xc]
;;;428      }
;;;429    }
00005e  bd30              POP      {r4,r5,pc}
                  |L10.96|
000060  6604              STR      r4,[r0,#0x60]         ;418
000062  6682              STR      r2,[r0,#0x68]         ;419
000064  66c3              STR      r3,[r0,#0x6c]         ;420
000066  bd30              POP      {r4,r5,pc}
;;;430    
                          ENDP


                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;437      */
;;;438    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;439    { 
;;;440      /* Reset NAND Init structure parameters values */
;;;441      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;442      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;443      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000006  6041              STR      r1,[r0,#4]
;;;444      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000008  6081              STR      r1,[r0,#8]
;;;445      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000a  60c1              STR      r1,[r0,#0xc]
;;;446      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000c  6101              STR      r1,[r0,#0x10]
;;;447      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;448      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000010  6181              STR      r1,[r0,#0x18]
000012  69c2              LDR      r2,[r0,#0x1c]
000014  21fc              MOVS     r1,#0xfc
;;;449      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000016  6011              STR      r1,[r2,#0]
000018  69c2              LDR      r2,[r0,#0x1c]
;;;450      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001a  6051              STR      r1,[r2,#4]
00001c  69c2              LDR      r2,[r0,#0x1c]
;;;451      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00001e  6091              STR      r1,[r2,#8]
000020  69c2              LDR      r2,[r0,#0x1c]
;;;452      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000022  60d1              STR      r1,[r2,#0xc]
000024  6a02              LDR      r2,[r0,#0x20]
;;;453      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000026  6011              STR      r1,[r2,#0]
000028  6a02              LDR      r2,[r0,#0x20]
;;;454      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002a  6051              STR      r1,[r2,#4]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;455      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
00002e  6091              STR      r1,[r2,#8]
000030  6a00              LDR      r0,[r0,#0x20]
000032  60c1              STR      r1,[r0,#0xc]
;;;456    }
000034  4770              BX       lr
;;;457    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;268      */
;;;269    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  0080              LSLS     r0,r0,#2
;;;270    {
;;;271      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;272      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;273      
;;;274      if (NewState != DISABLE)
;;;275      {
;;;276        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;277        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
000002  f1a040c0          SUB      r0,r0,#0x60000000
000006  2900              CMP      r1,#0                 ;274
;;;278      }
;;;279      else
;;;280      {
;;;281        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;282        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
000008  6801              LDR      r1,[r0,#0]
00000a  d002              BEQ      |L12.18|
00000c  f0410101          ORR      r1,r1,#1              ;277
000010  e001              B        |L12.22|
                  |L12.18|
000012  4a02              LDR      r2,|L12.28|
000014  4011              ANDS     r1,r1,r2
                  |L12.22|
000016  6001              STR      r1,[r0,#0]            ;277
;;;283      }
;;;284    }
000018  4770              BX       lr
;;;285    /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;128      */
;;;129    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  0081              LSLS     r1,r0,#2
;;;130    {
;;;131      /* Check the parameter */
;;;132      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;133      
;;;134      /* FSMC_Bank1_NORSRAM1 */
;;;135      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;136      {
;;;137        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;138      }
;;;139      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;140      else
;;;141      {   
;;;142        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000002  f1a141c0          SUB      r1,r1,#0x60000000
000006  b140              CBZ      r0,|L13.26|
000008  f24300d2          MOV      r0,#0x30d2
00000c  6008              STR      r0,[r1,#0]
                  |L13.14|
;;;143      }
;;;144      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00000e  f06f4070          MVN      r0,#0xf0000000
000012  6048              STR      r0,[r1,#4]
;;;145      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000014  f8c10104          STR      r0,[r1,#0x104]
;;;146    }
000018  4770              BX       lr
                  |L13.26|
00001a  f04f4220          MOV      r2,#0xa0000000        ;137
00001e  f24300db          MOV      r0,#0x30db            ;137
000022  6010              STR      r0,[r2,#0]            ;137
000024  e7f3              B        |L13.14|
;;;147    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMInit PROC
;;;155      */
;;;156    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b510              PUSH     {r4,lr}
;;;157    { 
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;158      /* Check the parameters */
;;;159      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;160      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;161      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;162      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;163      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;164      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;165      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;166      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;167      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;168      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;169      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;170      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;171      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;172      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;173      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;174      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;175      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;176      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;177      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;178      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;179      
;;;180      /* Bank1 NOR/SRAM control register configuration */ 
;;;181      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  4311              ORRS     r1,r1,r2
000014  6982              LDR      r2,[r0,#0x18]
000016  4311              ORRS     r1,r1,r2
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  4311              ORRS     r1,r1,r2
00001c  6a02              LDR      r2,[r0,#0x20]
00001e  4311              ORRS     r1,r1,r2
000020  6a42              LDR      r2,[r0,#0x24]
000022  4311              ORRS     r1,r1,r2
000024  6a82              LDR      r2,[r0,#0x28]
000026  4311              ORRS     r1,r1,r2
000028  6ac2              LDR      r2,[r0,#0x2c]
00002a  4311              ORRS     r1,r1,r2
00002c  6b02              LDR      r2,[r0,#0x30]
00002e  4311              ORRS     r1,r1,r2
000030  6802              LDR      r2,[r0,#0]
000032  0092              LSLS     r2,r2,#2
000034  f1a242c0          SUB      r2,r2,#0x60000000
000038  6011              STR      r1,[r2,#0]
;;;182                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;183                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;184                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;185                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;186                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;187                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;188                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;189                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;190                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;191                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;192                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;193                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;194      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
00003a  6881              LDR      r1,[r0,#8]
00003c  2908              CMP      r1,#8
00003e  d107              BNE      |L14.80|
;;;195      {
;;;196        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
000040  6801              LDR      r1,[r0,#0]
000042  0089              LSLS     r1,r1,#2
000044  f1a141c0          SUB      r1,r1,#0x60000000
000048  680a              LDR      r2,[r1,#0]
00004a  f0420240          ORR      r2,r2,#0x40
00004e  600a              STR      r2,[r1,#0]
                  |L14.80|
;;;197      }
;;;198      /* Bank1 NOR/SRAM timing register configuration */
;;;199      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
000050  6b41              LDR      r1,[r0,#0x34]
000052  e9d12300          LDRD     r2,r3,[r1,#0]
000056  ea421203          ORR      r2,r2,r3,LSL #4
00005a  688b              LDR      r3,[r1,#8]
00005c  898c              LDRH     r4,[r1,#0xc]
00005e  021b              LSLS     r3,r3,#8
000060  ea434304          ORR      r3,r3,r4,LSL #16
000064  431a              ORRS     r2,r2,r3
000066  8a0b              LDRH     r3,[r1,#0x10]
000068  ea425203          ORR      r2,r2,r3,LSL #20
00006c  7d0b              LDRB     r3,[r1,#0x14]
00006e  6989              LDR      r1,[r1,#0x18]
000070  ea426203          ORR      r2,r2,r3,LSL #24
000074  430a              ORRS     r2,r2,r1
000076  6801              LDR      r1,[r0,#0]
000078  0089              LSLS     r1,r1,#2
00007a  f1a141c0          SUB      r1,r1,#0x60000000
00007e  604a              STR      r2,[r1,#4]
;;;200                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;201                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;202                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;203                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;204                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;205                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;206                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;207                
;;;208        
;;;209      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;210      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
000080  6ac1              LDR      r1,[r0,#0x2c]
000082  f5b14f80          CMP      r1,#0x4000
000086  d008              BEQ      |L14.154|
;;;211      {
;;;212        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;213        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;214        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;215        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;216        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;217        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;218        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;219                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;220                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;221                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;222                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;223                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;224                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;225      }
;;;226      else
;;;227      {
;;;228        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000088  6800              LDR      r0,[r0,#0]
00008a  f06f4170          MVN      r1,#0xf0000000
00008e  0080              LSLS     r0,r0,#2
000090  f1a040c0          SUB      r0,r0,#0x60000000
000094  f8c01104          STR      r1,[r0,#0x104]
;;;229      }
;;;230    }
000098  bd10              POP      {r4,pc}
                  |L14.154|
00009a  6b81              LDR      r1,[r0,#0x38]         ;218
00009c  e9d12300          LDRD     r2,r3,[r1,#0]         ;218
0000a0  ea421203          ORR      r2,r2,r3,LSL #4       ;218
0000a4  688b              LDR      r3,[r1,#8]            ;218
0000a6  8a0c              LDRH     r4,[r1,#0x10]         ;218
0000a8  021b              LSLS     r3,r3,#8              ;218
0000aa  ea435304          ORR      r3,r3,r4,LSL #20      ;218
0000ae  431a              ORRS     r2,r2,r3              ;218
0000b0  7d0b              LDRB     r3,[r1,#0x14]         ;218
0000b2  6989              LDR      r1,[r1,#0x18]         ;218
0000b4  ea426203          ORR      r2,r2,r3,LSL #24      ;218
0000b8  6800              LDR      r0,[r0,#0]            ;218
0000ba  430a              ORRS     r2,r2,r1              ;218
0000bc  0080              LSLS     r0,r0,#2              ;218
0000be  f1a040c0          SUB      r0,r0,#0x60000000     ;218
0000c2  f8c02104          STR      r2,[r0,#0x104]        ;218
0000c6  bd10              POP      {r4,pc}
;;;231    
                          ENDP


                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMStructInit PROC
;;;237      */
;;;238    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  2100              MOVS     r1,#0
;;;239    {  
;;;240      /* Reset NOR/SRAM Init structure parameters values */
;;;241      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
;;;242      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000002  2202              MOVS     r2,#2
000004  e9c01200          STRD     r1,r2,[r0,#0]
;;;243      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;244      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000008  6081              STR      r1,[r0,#8]
;;;245      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000a  60c1              STR      r1,[r0,#0xc]
;;;246      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00000c  6101              STR      r1,[r0,#0x10]
;;;247      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00000e  6141              STR      r1,[r0,#0x14]
;;;248      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000010  6181              STR      r1,[r0,#0x18]
;;;249      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;250      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000012  02d2              LSLS     r2,r2,#11
000014  61c1              STR      r1,[r0,#0x1c]
000016  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;251      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00001a  0052              LSLS     r2,r2,#1
00001c  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;252      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;253      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;254      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)&FSMC_DefaultTimingStruct;
000020  6301              STR      r1,[r0,#0x30]
000022  4902              LDR      r1,|L15.44|
;;;255      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)&FSMC_DefaultTimingStruct;
000024  6341              STR      r1,[r0,#0x34]
000026  6381              STR      r1,[r0,#0x38]
;;;256    }
000028  4770              BX       lr
;;;257    
                          ENDP

00002a  0000              DCW      0x0000
                  |L15.44|
                          DCD      ||.constdata||

                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;704      */
;;;705    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  f04f4120          MOV      r1,#0xa0000000
;;;706    {
;;;707      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;708      
;;;709      if (NewState != DISABLE)
000004  2800              CMP      r0,#0
;;;710      {
;;;711        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;712        FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;717        FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000006  f8510fa0          LDR      r0,[r1,#0xa0]!
00000a  d002              BEQ      |L16.18|
00000c  f0400004          ORR      r0,r0,#4              ;712
000010  e001              B        |L16.22|
                  |L16.18|
000012  4a02              LDR      r2,|L16.28|
000014  4010              ANDS     r0,r0,r2
                  |L16.22|
000016  6008              STR      r0,[r1,#0]            ;712
;;;718      }
;;;719    }
000018  4770              BX       lr
;;;720    /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDDeInit PROC
;;;609      */
;;;610    void FSMC_PCCARDDeInit(void)
000000  f04f4020          MOV      r0,#0xa0000000
;;;611    {
;;;612      /* Set the FSMC_Bank4 registers to their reset values */
;;;613      FSMC_Bank4->PCR4 = 0x00000018; 
000004  2118              MOVS     r1,#0x18
000006  f8401fa0          STR      r1,[r0,#0xa0]!
;;;614      FSMC_Bank4->SR4 = 0x00000000;	
00000a  2100              MOVS     r1,#0
00000c  6041              STR      r1,[r0,#4]
;;;615      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000e  f04f31fc          MOV      r1,#0xfcfcfcfc
000012  6081              STR      r1,[r0,#8]
;;;616      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000014  60c1              STR      r1,[r0,#0xc]
;;;617      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000016  6101              STR      r1,[r0,#0x10]
;;;618    }
000018  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDInit PROC
;;;626      */
;;;627    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  b510              PUSH     {r4,lr}
;;;628    {
000002  e9d01200          LDRD     r1,r2,[r0,#0]
;;;629      /* Check the parameters */
;;;630      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;631      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;632      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;633     
;;;634      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;635      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;636      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;637      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;638      
;;;639      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;640      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;641      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;642      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;643      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;644      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;645      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;646      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;647      
;;;648      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;649      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000006  ea412142          ORR      r1,r1,r2,LSL #9
00000a  6882              LDR      r2,[r0,#8]
00000c  2310              MOVS     r3,#0x10
00000e  ea433242          ORR      r2,r3,r2,LSL #13
000012  4311              ORRS     r1,r1,r2
000014  f04f4220          MOV      r2,#0xa0000000
000018  f8421fa0          STR      r1,[r2,#0xa0]!
;;;650                         FSMC_MemoryDataWidth_16b |  
;;;651                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;652                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;653                
;;;654      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;655      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00001c  68c1              LDR      r1,[r0,#0xc]
00001e  e9d13400          LDRD     r3,r4,[r1,#0]
000022  ea432304          ORR      r3,r3,r4,LSL #8
000026  890c              LDRH     r4,[r1,#8]
000028  7b09              LDRB     r1,[r1,#0xc]
00002a  0424              LSLS     r4,r4,#16
00002c  ea446101          ORR      r1,r4,r1,LSL #24
000030  430b              ORRS     r3,r3,r1
000032  6093              STR      r3,[r2,#8]
;;;656                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;657                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;658                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;659                
;;;660      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;661      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000034  6901              LDR      r1,[r0,#0x10]
000036  e9d13400          LDRD     r3,r4,[r1,#0]
00003a  ea432304          ORR      r3,r3,r4,LSL #8
00003e  890c              LDRH     r4,[r1,#8]
000040  7b09              LDRB     r1,[r1,#0xc]
000042  0424              LSLS     r4,r4,#16
000044  ea446101          ORR      r1,r4,r1,LSL #24
000048  430b              ORRS     r3,r3,r1
00004a  60d3              STR      r3,[r2,#0xc]
;;;662                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;663                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;664                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;665                
;;;666      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;667      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
00004c  6940              LDR      r0,[r0,#0x14]
00004e  e9d01300          LDRD     r1,r3,[r0,#0]
000052  ea412103          ORR      r1,r1,r3,LSL #8
000056  8903              LDRH     r3,[r0,#8]
000058  7b00              LDRB     r0,[r0,#0xc]
00005a  041b              LSLS     r3,r3,#16
00005c  ea436000          ORR      r0,r3,r0,LSL #24
000060  4301              ORRS     r1,r1,r0
000062  6111              STR      r1,[r2,#0x10]
;;;668                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;669                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;670                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;671    }
000064  bd10              POP      {r4,pc}
;;;672    
                          ENDP


                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;678      */
;;;679    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;680    {
;;;681      /* Reset PCCARD Init structure parameters values */
;;;682      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;683      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000002  6001              STR      r1,[r0,#0]
;;;684      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;685      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000006  6081              STR      r1,[r0,#8]
000008  68c2              LDR      r2,[r0,#0xc]
00000a  21fc              MOVS     r1,#0xfc
;;;686      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000c  6011              STR      r1,[r2,#0]
00000e  68c2              LDR      r2,[r0,#0xc]
;;;687      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000010  6051              STR      r1,[r2,#4]
000012  68c2              LDR      r2,[r0,#0xc]
;;;688      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000014  6091              STR      r1,[r2,#8]
000016  68c2              LDR      r2,[r0,#0xc]
;;;689      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000018  60d1              STR      r1,[r2,#0xc]
00001a  6902              LDR      r2,[r0,#0x10]
;;;690      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001c  6011              STR      r1,[r2,#0]
00001e  6902              LDR      r2,[r0,#0x10]
;;;691      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000020  6051              STR      r1,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
;;;692      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000024  6091              STR      r1,[r2,#8]
000026  6902              LDR      r2,[r0,#0x10]
;;;693      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000028  60d1              STR      r1,[r2,#0xc]
00002a  6942              LDR      r2,[r0,#0x14]
;;;694      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002c  6011              STR      r1,[r2,#0]
00002e  6942              LDR      r2,[r0,#0x14]
;;;695      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000030  6051              STR      r1,[r2,#4]
000032  6942              LDR      r2,[r0,#0x14]
;;;696      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000034  6091              STR      r1,[r2,#8]
000036  6940              LDR      r0,[r0,#0x14]
000038  60c1              STR      r1,[r0,#0xc]
;;;697    }
00003a  4770              BX       lr
;;;698    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  FSMC_DefaultTimingStruct
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x000000ff
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_fsmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_fsmc_c_13019877____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____REVSH|
#line 144
|__asm___16_stm32f4xx_fsmc_c_13019877____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
