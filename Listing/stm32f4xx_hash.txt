; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_hash.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_hash.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=537 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_hash.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_hash.c]
                          THUMB

                          AREA ||i.HASH_AutoStartDigest||, CODE, READONLY, ALIGN=2

                  HASH_AutoStartDigest PROC
;;;464      */
;;;465    void HASH_AutoStartDigest(FunctionalState NewState)
000000  4905              LDR      r1,|L1.24|
;;;466    {
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;469    
;;;470      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;471      {
;;;472        /* Enable the auto start of the final message digest at the end of DMA transfer */
;;;473        HASH->CR &= ~HASH_CR_MDMAT;
;;;474      }
;;;475      else
;;;476      {
;;;477        /* Disable the auto start of the final message digest at the end of DMA transfer */
;;;478        HASH->CR |= HASH_CR_MDMAT;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L1.14|
000008  f4205000          BIC      r0,r0,#0x2000         ;473
00000c  e001              B        |L1.18|
                  |L1.14|
00000e  f4405000          ORR      r0,r0,#0x2000
                  |L1.18|
000012  6008              STR      r0,[r1,#0]            ;473
;;;479      }
;;;480    }
000014  4770              BX       lr
;;;481      
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x50060400

                          AREA ||i.HASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  HASH_ClearFlag PROC
;;;650      */
;;;651    void HASH_ClearFlag(uint32_t HASH_FLAG)
000000  4901              LDR      r1,|L2.8|
;;;652    {
;;;653      /* Check the parameters */
;;;654      assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
;;;655      
;;;656      /* Clear the selected HASH flags */
;;;657      HASH->SR = ~(uint32_t)HASH_FLAG;
000002  43c0              MVNS     r0,r0
000004  6008              STR      r0,[r1,#0]
;;;658    }
000006  4770              BX       lr
;;;659    /**
                          ENDP

                  |L2.8|
                          DCD      0x50060424

                          AREA ||i.HASH_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  HASH_ClearITPendingBit PROC
;;;700      */
;;;701    void HASH_ClearITPendingBit(uint32_t HASH_IT)
000000  4901              LDR      r1,|L3.8|
;;;702    {
;;;703      /* Check the parameters */
;;;704      assert_param(IS_HASH_IT(HASH_IT));
;;;705    
;;;706      /* Clear the selected HASH interrupt pending bit */
;;;707      HASH->SR = (uint32_t)(~HASH_IT);
000002  43c0              MVNS     r0,r0
000004  6008              STR      r0,[r1,#0]
;;;708    }
000006  4770              BX       lr
;;;709    
                          ENDP

                  |L3.8|
                          DCD      0x50060424

                          AREA ||i.HASH_DMACmd||, CODE, READONLY, ALIGN=2

                  HASH_DMACmd PROC
;;;488      */
;;;489    void HASH_DMACmd(FunctionalState NewState)
000000  4905              LDR      r1,|L4.24|
;;;490    {
;;;491      /* Check the parameters */
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493    
;;;494      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;495      {
;;;496        /* Enable the HASH DMA request */
;;;497        HASH->CR |= HASH_CR_DMAE;
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Disable the HASH DMA request */
;;;502        HASH->CR &= ~HASH_CR_DMAE;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L4.14|
000008  f0400008          ORR      r0,r0,#8              ;497
00000c  e001              B        |L4.18|
                  |L4.14|
00000e  f0200008          BIC      r0,r0,#8
                  |L4.18|
000012  6008              STR      r0,[r1,#0]            ;497
;;;503      }
;;;504    }
000014  4770              BX       lr
;;;505    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x50060400

                          AREA ||i.HASH_DataIn||, CODE, READONLY, ALIGN=2

                  HASH_DataIn PROC
;;;305      */
;;;306    void HASH_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L5.8|
;;;307    {
;;;308      /* Write in the DIN register a new data */
;;;309      HASH->DIN = Data;
000002  6008              STR      r0,[r1,#0]
;;;310    }
000004  4770              BX       lr
;;;311    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50060404

                          AREA ||i.HASH_DeInit||, CODE, READONLY, ALIGN=1

                  HASH_DeInit PROC
;;;170      */
;;;171    void HASH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173      /* Enable HASH reset state */
;;;174      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;175      /* Release HASH from reset state */
;;;176      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2020              MOVS     r0,#0x20
000012  f7ffbffe          B.W      RCC_AHB2PeriphResetCmd
;;;177    }
;;;178    
                          ENDP


                          AREA ||i.HASH_GetDigest||, CODE, READONLY, ALIGN=2

                  HASH_GetDigest PROC
;;;334      */
;;;335    void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
000000  490f              LDR      r1,|L7.64|
;;;336    {
;;;337      /* Get the data field */
;;;338      HASH_MessageDigest->Data[0] = HASH->HR[0];
000002  6809              LDR      r1,[r1,#0]
;;;339      HASH_MessageDigest->Data[1] = HASH->HR[1];
000004  6001              STR      r1,[r0,#0]
000006  490e              LDR      r1,|L7.64|
000008  1d09              ADDS     r1,r1,#4
00000a  6809              LDR      r1,[r1,#0]
;;;340      HASH_MessageDigest->Data[2] = HASH->HR[2];
00000c  6041              STR      r1,[r0,#4]
00000e  490c              LDR      r1,|L7.64|
000010  3108              ADDS     r1,r1,#8
000012  6809              LDR      r1,[r1,#0]
;;;341      HASH_MessageDigest->Data[3] = HASH->HR[3];
000014  6081              STR      r1,[r0,#8]
000016  490a              LDR      r1,|L7.64|
000018  310c              ADDS     r1,r1,#0xc
00001a  6809              LDR      r1,[r1,#0]
;;;342      HASH_MessageDigest->Data[4] = HASH->HR[4];
00001c  60c1              STR      r1,[r0,#0xc]
00001e  4908              LDR      r1,|L7.64|
000020  3110              ADDS     r1,r1,#0x10
000022  6809              LDR      r1,[r1,#0]
;;;343      HASH_MessageDigest->Data[5] = HASH_DIGEST->HR[5];
000024  6101              STR      r1,[r0,#0x10]
000026  4907              LDR      r1,|L7.68|
000028  6809              LDR      r1,[r1,#0]
;;;344      HASH_MessageDigest->Data[6] = HASH_DIGEST->HR[6];
00002a  6141              STR      r1,[r0,#0x14]
00002c  4905              LDR      r1,|L7.68|
00002e  1d09              ADDS     r1,r1,#4
000030  6809              LDR      r1,[r1,#0]
;;;345      HASH_MessageDigest->Data[7] = HASH_DIGEST->HR[7];
000032  6181              STR      r1,[r0,#0x18]
000034  4903              LDR      r1,|L7.68|
000036  3108              ADDS     r1,r1,#8
000038  6809              LDR      r1,[r1,#0]
00003a  61c1              STR      r1,[r0,#0x1c]
;;;346    }
00003c  4770              BX       lr
;;;347    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x5006040c
                  |L7.68|
                          DCD      0x50060724

                          AREA ||i.HASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetFlagStatus PROC
;;;609      */
;;;610    FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG)
000000  4601              MOV      r1,r0
;;;611    {
;;;612      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;613      uint32_t tempreg = 0;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
;;;617    
;;;618      /* check if the FLAG is in CR register */
;;;619      if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint32_t)RESET ) 
000004  04ca              LSLS     r2,r1,#19
000006  d501              BPL      |L8.12|
;;;620      {
;;;621        tempreg = HASH->CR;
000008  4a04              LDR      r2,|L8.28|
00000a  e001              B        |L8.16|
                  |L8.12|
;;;622      }
;;;623      else /* The FLAG is in SR register */
;;;624      {
;;;625        tempreg = HASH->SR;
00000c  4a03              LDR      r2,|L8.28|
00000e  3224              ADDS     r2,r2,#0x24
                  |L8.16|
000010  6812              LDR      r2,[r2,#0]
;;;626      }
;;;627    
;;;628      /* Check the status of the specified HASH flag */
;;;629      if ((tempreg & HASH_FLAG) != (uint32_t)RESET)
000012  420a              TST      r2,r1
000014  d000              BEQ      |L8.24|
;;;630      {
;;;631        /* HASH is set */
;;;632        bitstatus = SET;
000016  2001              MOVS     r0,#1
                  |L8.24|
;;;633      }
;;;634      else
;;;635      {
;;;636        /* HASH_FLAG is reset */
;;;637        bitstatus = RESET;
;;;638      }
;;;639    
;;;640      /* Return the HASH_FLAG status */
;;;641      return  bitstatus;
;;;642    }
000018  4770              BX       lr
;;;643    /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x50060400

                          AREA ||i.HASH_GetITStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetITStatus PROC
;;;666      */
;;;667    ITStatus HASH_GetITStatus(uint32_t HASH_IT)
000000  4905              LDR      r1,|L9.24|
;;;668    {
000002  4602              MOV      r2,r0
;;;669      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;670      uint32_t tmpreg = 0;
;;;671    
;;;672      /* Check the parameters */
;;;673      assert_param(IS_HASH_GET_IT(HASH_IT));  
;;;674    
;;;675    
;;;676      /* Check the status of the specified HASH interrupt */
;;;677      tmpreg =  HASH->SR;
000006  6809              LDR      r1,[r1,#0]
;;;678    
;;;679      if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
000008  4b03              LDR      r3,|L9.24|
00000a  1f1b              SUBS     r3,r3,#4
00000c  681b              LDR      r3,[r3,#0]
00000e  4011              ANDS     r1,r1,r2
000010  420b              TST      r3,r1
000012  d000              BEQ      |L9.22|
;;;680      {
;;;681        /* HASH_IT is set */
;;;682        bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L9.22|
;;;683      }
;;;684      else
;;;685      {
;;;686        /* HASH_IT is reset */
;;;687        bitstatus = RESET;
;;;688      }
;;;689      /* Return the HASH_IT status */
;;;690      return bitstatus;
;;;691    }
000016  4770              BX       lr
;;;692    
                          ENDP

                  |L9.24|
                          DCD      0x50060424

                          AREA ||i.HASH_GetInFIFOWordsNbr||, CODE, READONLY, ALIGN=2

                  HASH_GetInFIFOWordsNbr PROC
;;;316      */
;;;317    uint8_t HASH_GetInFIFOWordsNbr(void)
000000  4802              LDR      r0,|L10.12|
;;;318    {
;;;319      /* Return the value of NBW bits */
;;;320      return ((HASH->CR & HASH_CR_NBW) >> 8);
000002  6800              LDR      r0,[r0,#0]
000004  f3c02003          UBFX     r0,r0,#8,#4
;;;321    }
000008  4770              BX       lr
;;;322    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x50060400

                          AREA ||i.HASH_ITConfig||, CODE, READONLY, ALIGN=2

                  HASH_ITConfig PROC
;;;580      */
;;;581    void HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;582    {
;;;583      /* Check the parameters */
;;;584      assert_param(IS_HASH_IT(HASH_IT));
;;;585      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;586    
;;;587      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;588      {
;;;589        /* Enable the selected HASH interrupt */
;;;590        HASH->IMR |= HASH_IT;
;;;591      }
;;;592      else
;;;593      {
;;;594        /* Disable the selected HASH interrupt */
;;;595        HASH->IMR &= (uint32_t)(~HASH_IT);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L11.12|
000008  4301              ORRS     r1,r1,r0              ;590
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  4381              BICS     r1,r1,r0
                  |L11.14|
00000e  6011              STR      r1,[r2,#0]            ;590
;;;596      }
;;;597    }
000010  4770              BX       lr
;;;598    
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x50060420

                          AREA ||i.HASH_Init||, CODE, READONLY, ALIGN=2

                  HASH_Init PROC
;;;190      */
;;;191    void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
000000  490e              LDR      r1,|L12.60|
;;;192    {
000002  b510              PUSH     {r4,lr}
;;;193      /* Check the parameters */
;;;194      assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
;;;195      assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
;;;196      assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
;;;197      
;;;198      /* Configure the Algorithm used, algorithm mode and the datatype */
;;;199      HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
000004  680a              LDR      r2,[r1,#0]
000006  4b0e              LDR      r3,|L12.64|
000008  401a              ANDS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;200      HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
00000c  680a              LDR      r2,[r1,#0]
00000e  6803              LDR      r3,[r0,#0]
000010  431a              ORRS     r2,r2,r3
000012  e9d04301          LDRD     r4,r3,[r0,#4]
000016  4323              ORRS     r3,r3,r4
000018  431a              ORRS     r2,r2,r3
00001a  600a              STR      r2,[r1,#0]
;;;201                   HASH_InitStruct->HASH_DataType | \
;;;202                   HASH_InitStruct->HASH_AlgoMode);
;;;203      
;;;204      /* if algorithm mode is HMAC, set the Key */  
;;;205      if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
00001c  6842              LDR      r2,[r0,#4]
00001e  2a40              CMP      r2,#0x40
000020  d107              BNE      |L12.50|
;;;206      {
;;;207        assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
;;;208        HASH->CR &= ~HASH_CR_LKEY;
000022  680a              LDR      r2,[r1,#0]
000024  f4223280          BIC      r2,r2,#0x10000
000028  600a              STR      r2,[r1,#0]
;;;209        HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
00002a  680a              LDR      r2,[r1,#0]
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  4302              ORRS     r2,r2,r0
000030  600a              STR      r2,[r1,#0]
                  |L12.50|
;;;210      }
;;;211    
;;;212      /* Reset the HASH processor core, so that the HASH will be ready to compute 
;;;213         the message digest of a new message */
;;;214      HASH->CR |= HASH_CR_INIT;  
000032  6808              LDR      r0,[r1,#0]
000034  f0400004          ORR      r0,r0,#4
000038  6008              STR      r0,[r1,#0]
;;;215    }
00003a  bd10              POP      {r4,pc}
;;;216    
                          ENDP

                  |L12.60|
                          DCD      0x50060400
                  |L12.64|
                          DCD      0xfffbff0f

                          AREA ||i.HASH_Reset||, CODE, READONLY, ALIGN=2

                  HASH_Reset PROC
;;;248      */
;;;249    void HASH_Reset(void)
000000  4802              LDR      r0,|L13.12|
;;;250    {
;;;251      /* Reset the HASH processor core */
;;;252      HASH->CR |= HASH_CR_INIT;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;253    }
00000a  4770              BX       lr
;;;254    /**
                          ENDP

                  |L13.12|
                          DCD      0x50060400

                          AREA ||i.HASH_RestoreContext||, CODE, READONLY, ALIGN=2

                  HASH_RestoreContext PROC
;;;417      */
;;;418    void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
000000  b510              PUSH     {r4,lr}
;;;419    {
;;;420      uint8_t i = 0;
;;;421      
;;;422      /* restore context registers */
;;;423      HASH->IMR = HASH_ContextRestore->HASH_IMR;   
000002  4b0e              LDR      r3,|L14.60|
000004  6802              LDR      r2,[r0,#0]
000006  2100              MOVS     r1,#0                 ;420
000008  601a              STR      r2,[r3,#0]
;;;424      HASH->STR = HASH_ContextRestore->HASH_STR;     
00000a  4b0c              LDR      r3,|L14.60|
00000c  6842              LDR      r2,[r0,#4]
00000e  3b18              SUBS     r3,r3,#0x18
000010  601a              STR      r2,[r3,#0]
;;;425      HASH->CR = HASH_ContextRestore->HASH_CR;
000012  4a0a              LDR      r2,|L14.60|
000014  6883              LDR      r3,[r0,#8]
000016  3a20              SUBS     r2,r2,#0x20
000018  6013              STR      r3,[r2,#0]
;;;426      
;;;427      /* Initialize the hash processor */
;;;428      HASH->CR |= HASH_CR_INIT; 
00001a  6813              LDR      r3,[r2,#0]
00001c  f0430304          ORR      r3,r3,#4
000020  6013              STR      r3,[r2,#0]
;;;429      
;;;430       /* continue restoring context registers */     
;;;431      for(i=0; i<=53;i++)
;;;432      {
;;;433         HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
000022  4a07              LDR      r2,|L14.64|
                  |L14.36|
000024  eb000381          ADD      r3,r0,r1,LSL #2
000028  eb020481          ADD      r4,r2,r1,LSL #2
00002c  68db              LDR      r3,[r3,#0xc]
00002e  f8c434f8          STR      r3,[r4,#0x4f8]
000032  1c49              ADDS     r1,r1,#1
000034  b2c9              UXTB     r1,r1                 ;431
000036  2935              CMP      r1,#0x35              ;431
000038  d9f4              BLS      |L14.36|
;;;434      }   
;;;435    }
00003a  bd10              POP      {r4,pc}
;;;436    /**
                          ENDP

                  |L14.60|
                          DCD      0x50060420
                  |L14.64|
                          DCD      0x50060000

                          AREA ||i.HASH_SaveContext||, CODE, READONLY, ALIGN=2

                  HASH_SaveContext PROC
;;;395      */
;;;396    void HASH_SaveContext(HASH_Context* HASH_ContextSave)
000000  4a0c              LDR      r2,|L15.52|
;;;397    {
000002  b510              PUSH     {r4,lr}
;;;398      uint8_t i = 0;
;;;399      
;;;400      /* save context registers */
;;;401      HASH_ContextSave->HASH_IMR = HASH->IMR;  
000004  6812              LDR      r2,[r2,#0]
000006  2100              MOVS     r1,#0                 ;398
;;;402      HASH_ContextSave->HASH_STR = HASH->STR;      
000008  6002              STR      r2,[r0,#0]
00000a  4a0a              LDR      r2,|L15.52|
00000c  3a18              SUBS     r2,r2,#0x18
00000e  6812              LDR      r2,[r2,#0]
;;;403      HASH_ContextSave->HASH_CR  = HASH->CR;     
000010  6042              STR      r2,[r0,#4]
000012  4a08              LDR      r2,|L15.52|
000014  3a20              SUBS     r2,r2,#0x20
000016  6812              LDR      r2,[r2,#0]
;;;404      for(i=0; i<=53;i++)
;;;405      {
;;;406         HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
000018  6082              STR      r2,[r0,#8]
00001a  4a07              LDR      r2,|L15.56|
                  |L15.28|
00001c  eb020381          ADD      r3,r2,r1,LSL #2
000020  f8d334f8          LDR      r3,[r3,#0x4f8]
000024  eb000481          ADD      r4,r0,r1,LSL #2
000028  1c49              ADDS     r1,r1,#1
00002a  b2c9              UXTB     r1,r1                 ;404
00002c  60e3              STR      r3,[r4,#0xc]          ;404
00002e  2935              CMP      r1,#0x35              ;404
000030  d9f4              BLS      |L15.28|
;;;407      }   
;;;408    }
000032  bd10              POP      {r4,pc}
;;;409    
                          ENDP

                  |L15.52|
                          DCD      0x50060420
                  |L15.56|
                          DCD      0x50060000

                          AREA ||i.HASH_SetLastWordValidBitsNbr||, CODE, READONLY, ALIGN=2

                  HASH_SetLastWordValidBitsNbr PROC
;;;290      */
;;;291    void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
000000  4904              LDR      r1,|L16.20|
;;;292    {
;;;293      /* Check the parameters */
;;;294      assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
;;;295      
;;;296      /* Configure the Number of valid bits in last word of the message */
;;;297      HASH->STR &= ~(HASH_STR_NBW);
000002  680a              LDR      r2,[r1,#0]
000004  f022021f          BIC      r2,r2,#0x1f
000008  600a              STR      r2,[r1,#0]
;;;298      HASH->STR |= ValidNumber;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;299    }
000010  4770              BX       lr
;;;300    
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      0x50060408

                          AREA ||i.HASH_StartDigest||, CODE, READONLY, ALIGN=2

                  HASH_StartDigest PROC
;;;352      */
;;;353    void HASH_StartDigest(void)
000000  4802              LDR      r0,|L17.12|
;;;354    {
;;;355      /* Start the Digest calculation */
;;;356      HASH->STR |= HASH_STR_DCAL;
000002  6801              LDR      r1,[r0,#0]
000004  f4417180          ORR      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;357    }
00000a  4770              BX       lr
;;;358    /**
                          ENDP

                  |L17.12|
                          DCD      0x50060408

                          AREA ||i.HASH_StructInit||, CODE, READONLY, ALIGN=1

                  HASH_StructInit PROC
;;;224      */
;;;225    void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
000000  2100              MOVS     r1,#0
;;;226    {
;;;227      /* Initialize the HASH_AlgoSelection member */
;;;228      HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
;;;229    
;;;230      /* Initialize the HASH_AlgoMode member */
;;;231      HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
000002  6001              STR      r1,[r0,#0]
;;;232    
;;;233      /* Initialize the HASH_DataType member */
;;;234      HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
000004  6041              STR      r1,[r0,#4]
;;;235    
;;;236      /* Initialize the HASH_HMACKeyType member */
;;;237      HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;238    }
00000a  4770              BX       lr
;;;239    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_hash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_hash_c_90573c7c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REVSH|
#line 144
|__asm___16_stm32f4xx_hash_c_90573c7c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
