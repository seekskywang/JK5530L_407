; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_i2c.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=537 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_i2c.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;717      */
;;;718    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;719    {
;;;720      /* Check the parameters */
;;;721      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;722      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;723      if (NewState != DISABLE)
;;;724      {
;;;725        /* Enable the selected I2C ARP */
;;;726        I2Cx->CR1 |= I2C_CR1_ENARP;
;;;727      }
;;;728      else
;;;729      {
;;;730        /* Disable the selected I2C ARP */
;;;731        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  f0410110          ORR      r1,r1,#0x10           ;726
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L1.16|
000010  8001              STRH     r1,[r0,#0]            ;726
;;;732      }
;;;733    }
000012  4770              BX       lr
;;;734    /**
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;477      */
;;;478    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;479    {
;;;480      /* Check the parameters */
;;;481      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Enable the acknowledgement */
;;;486        I2Cx->CR1 |= I2C_CR1_ACK;
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable the acknowledgement */
;;;491        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  f4416180          ORR      r1,r1,#0x400          ;486
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L2.16|
000010  8001              STRH     r1,[r0,#0]            ;486
;;;492      }
;;;493    }
000012  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.I2C_AnalogFilterCmd||, CODE, READONLY, ALIGN=1

                  I2C_AnalogFilterCmd PROC
;;;341      */
;;;342    void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;346      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;347      if (NewState != DISABLE)
;;;348      {
;;;349        /* Enable the analog filter */
;;;350        I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
;;;351      }
;;;352      else
;;;353      {
;;;354        /* Disable the analog filter */
;;;355        I2Cx->FLTR |= I2C_FLTR_ANOFF;
000002  8c81              LDRH     r1,[r0,#0x24]
000004  d002              BEQ      |L3.12|
000006  f0210110          BIC      r1,r1,#0x10           ;350
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0410110          ORR      r1,r1,#0x10
                  |L3.16|
000010  8481              STRH     r1,[r0,#0x24]         ;350
;;;356      }
;;;357    }
000012  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;854      */
;;;855    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;856    {
;;;857      /* Check the parameters */
;;;858      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;859      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;860      if (NewState != DISABLE)
;;;861      {
;;;862        /* Enable the selected I2C PEC calculation */
;;;863        I2Cx->CR1 |= I2C_CR1_ENPEC;
;;;864      }
;;;865      else
;;;866      {
;;;867        /* Disable the selected I2C PEC calculation */
;;;868        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L4.12|
000006  f0410120          ORR      r1,r1,#0x20           ;863
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L4.16|
000010  8001              STRH     r1,[r0,#0]            ;863
;;;869      }
;;;870    }
000012  4770              BX       lr
;;;871    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1157     */
;;;1158   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  4603              MOV      r3,r0
;;;1159   {
;;;1160     uint32_t lastevent = 0;
;;;1161     uint32_t flag1 = 0, flag2 = 0;
;;;1162     ErrorStatus status = ERROR;
000002  2000              MOVS     r0,#0
;;;1163   
;;;1164     /* Check the parameters */
;;;1165     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1166     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1167   
;;;1168     /* Read the I2Cx status register */
;;;1169     flag1 = I2Cx->SR1;
000004  8a9a              LDRH     r2,[r3,#0x14]
;;;1170     flag2 = I2Cx->SR2;
000006  8b1b              LDRH     r3,[r3,#0x18]
;;;1171     flag2 = flag2 << 16;
;;;1172   
;;;1173     /* Get the last event value from I2C status register */
;;;1174     lastevent = (flag1 | flag2) & FLAG_MASK;
000008  ea424203          ORR      r2,r2,r3,LSL #16
00000c  f022427f          BIC      r2,r2,#0xff000000
;;;1175   
;;;1176     /* Check whether the last event contains the I2C_EVENT */
;;;1177     if ((lastevent & I2C_EVENT) == I2C_EVENT)
000010  4391              BICS     r1,r1,r2
000012  d100              BNE      |L5.22|
;;;1178     {
;;;1179       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1180       status = SUCCESS;
000014  2001              MOVS     r0,#1
                  |L5.22|
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       /* ERROR: last event is different from I2C_EVENT */
;;;1185       status = ERROR;
;;;1186     }
;;;1187     /* Return status */
;;;1188     return status;
;;;1189   }
000016  4770              BX       lr
;;;1190   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1337     */
;;;1338   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1339   {
;;;1340     uint32_t flagpos = 0;
;;;1341     /* Check the parameters */
;;;1342     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1343     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1344     /* Get the I2C flag position */
;;;1345     flagpos = I2C_FLAG & FLAG_MASK;
;;;1346     /* Clear the selected I2C flag */
;;;1347     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1348   }
000004  4770              BX       lr
;;;1349   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1431     */
;;;1432   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1433   {
;;;1434     uint32_t flagpos = 0;
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1437     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1438   
;;;1439     /* Get the I2C flag position */
;;;1440     flagpos = I2C_IT & FLAG_MASK;
;;;1441   
;;;1442     /* Clear the selected I2C flag */
;;;1443     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1444   }
000004  4770              BX       lr
;;;1445   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;312      */
;;;313    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;314    {
;;;315      /* Check the parameters */
;;;316      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      if (NewState != DISABLE)
;;;319      {
;;;320        /* Enable the selected I2C peripheral */
;;;321        I2Cx->CR1 |= I2C_CR1_PE;
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable the selected I2C peripheral */
;;;326        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L8.12|
000006  f0410101          ORR      r1,r1,#1              ;321
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L8.16|
000010  8001              STRH     r1,[r0,#0]            ;321
;;;327      }
;;;328    }
000012  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;909      */
;;;910    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;911    {
;;;912      /* Check the parameters */
;;;913      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;914      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;915      if (NewState != DISABLE)
;;;916      {
;;;917        /* Enable the selected I2C DMA requests */
;;;918        I2Cx->CR2 |= I2C_CR2_DMAEN;
;;;919      }
;;;920      else
;;;921      {
;;;922        /* Disable the selected I2C DMA requests */
;;;923        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L9.12|
000006  f4416100          ORR      r1,r1,#0x800          ;918
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L9.16|
000010  8081              STRH     r1,[r0,#4]            ;918
;;;924      }
;;;925    }
000012  4770              BX       lr
;;;926    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;933      */
;;;934    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;935    {
;;;936      /* Check the parameters */
;;;937      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;938      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;939      if (NewState != DISABLE)
;;;940      {
;;;941        /* Next DMA transfer is the last transfer */
;;;942        I2Cx->CR2 |= I2C_CR2_LAST;
;;;943      }
;;;944      else
;;;945      {
;;;946        /* Next DMA transfer is not the last transfer */
;;;947        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L10.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;942
00000a  e001              B        |L10.16|
                  |L10.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L10.16|
000010  8081              STRH     r1,[r0,#4]            ;942
;;;948      }
;;;949    }
000012  4770              BX       lr
;;;950    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;136      */
;;;137    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  490d              LDR      r1,|L11.56|
;;;138    {
000002  b510              PUSH     {r4,lr}
;;;139      /* Check the parameters */
;;;140      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;141    
;;;142      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L11.14|
;;;143      {
;;;144        /* Enable I2C1 reset state */
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  054c              LSLS     r4,r1,#21
;;;146        /* Release I2C1 from reset state */
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
00000c  e00a              B        |L11.36|
                  |L11.14|
;;;148      }
;;;149      else if (I2Cx == I2C2)
00000e  490b              LDR      r1,|L11.60|
000010  4288              CMP      r0,r1
000012  d102              BNE      |L11.26|
;;;150      {
;;;151        /* Enable I2C2 reset state */
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000014  2101              MOVS     r1,#1
000016  058c              LSLS     r4,r1,#22
;;;153        /* Release I2C2 from reset state */
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
000018  e004              B        |L11.36|
                  |L11.26|
;;;155      }
;;;156      else 
;;;157      {
;;;158        if (I2Cx == I2C3)
00001a  4909              LDR      r1,|L11.64|
00001c  4288              CMP      r0,r1
00001e  d10a              BNE      |L11.54|
;;;159        {
;;;160          /* Enable I2C3 reset state */
;;;161          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
000020  2101              MOVS     r1,#1
000022  05cc              LSLS     r4,r1,#23
                  |L11.36|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;162          /* Release I2C3 from reset state */
;;;163          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  2100              MOVS     r1,#0
000032  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L11.54|
;;;164        }
;;;165      }
;;;166    }
000036  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L11.56|
                          DCD      0x40005400
                  |L11.60|
                          DCD      0x40005800
                  |L11.64|
                          DCD      0x40005c00

                          AREA ||i.I2C_DigitalFilterConfig||, CODE, READONLY, ALIGN=1

                  I2C_DigitalFilterConfig PROC
;;;370      */
;;;371    void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
000000  8c82              LDRH     r2,[r0,#0x24]
;;;372    {
;;;373      uint16_t tmpreg = 0;
;;;374      
;;;375      /* Check the parameters */
;;;376      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;377      assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
;;;378      
;;;379      /* Get the old register value */
;;;380      tmpreg = I2Cx->FLTR;
;;;381      
;;;382      /* Reset I2Cx DNF bit [3:0] */
;;;383      tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
;;;384      
;;;385      /* Set I2Cx DNF coefficient */
;;;386      tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
000002  f001010f          AND      r1,r1,#0xf
000006  f022020f          BIC      r2,r2,#0xf            ;383
00000a  4311              ORRS     r1,r1,r2
;;;387      
;;;388      /* Store the new register value */
;;;389      I2Cx->FLTR = tmpreg;
00000c  8481              STRH     r1,[r0,#0x24]
;;;390    }
00000e  4770              BX       lr
;;;391    
                          ENDP


                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;527      */
;;;528    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;529    {
;;;530      /* Check the parameters */
;;;531      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;532      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;533      if (NewState != DISABLE)
;;;534      {
;;;535        /* Enable dual addressing mode */
;;;536        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
;;;537      }
;;;538      else
;;;539      {
;;;540        /* Disable dual addressing mode */
;;;541        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L13.12|
000006  f0410101          ORR      r1,r1,#1              ;536
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L13.16|
000010  8181              STRH     r1,[r0,#0xc]          ;536
;;;542      }
;;;543    }
000012  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;627      */
;;;628    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;629    {
;;;630      /* Check the parameters */
;;;631      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;632      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;633      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;634      {
;;;635        /* I2C fast mode Tlow/Thigh=2 */
;;;636        I2Cx->CCR &= I2C_DutyCycle_2;
;;;637      }
;;;638      else
;;;639      {
;;;640        /* I2C fast mode Tlow/Thigh=16/9 */
;;;641        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  d002              BEQ      |L14.14|
000008  f4214180          BIC      r1,r1,#0x4000         ;636
00000c  e001              B        |L14.18|
                  |L14.14|
00000e  f4414180          ORR      r1,r1,#0x4000
                  |L14.18|
000012  8381              STRH     r1,[r0,#0x1c]         ;636
;;;642      }
;;;643    }
000014  4770              BX       lr
;;;644    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;551      */
;;;552    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;553    {
;;;554      /* Check the parameters */
;;;555      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;556      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;557      if (NewState != DISABLE)
;;;558      {
;;;559        /* Enable generall call */
;;;560        I2Cx->CR1 |= I2C_CR1_ENGC;
;;;561      }
;;;562      else
;;;563      {
;;;564        /* Disable generall call */
;;;565        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f0410140          ORR      r1,r1,#0x40           ;560
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f0210140          BIC      r1,r1,#0x40
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;560
;;;566      }
;;;567    }
000012  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;398      */
;;;399    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Generate a START condition */
;;;407        I2Cx->CR1 |= I2C_CR1_START;
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the START condition generation */
;;;412        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L16.12|
000006  f4417180          ORR      r1,r1,#0x100          ;407
00000a  e001              B        |L16.16|
                  |L16.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L16.16|
000010  8001              STRH     r1,[r0,#0]            ;407
;;;413      }
;;;414    }
000012  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;422      */
;;;423    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;427      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;428      if (NewState != DISABLE)
;;;429      {
;;;430        /* Generate a STOP condition */
;;;431        I2Cx->CR1 |= I2C_CR1_STOP;
;;;432      }
;;;433      else
;;;434      {
;;;435        /* Disable the STOP condition generation */
;;;436        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L17.12|
000006  f4417100          ORR      r1,r1,#0x200          ;431
00000a  e001              B        |L17.16|
                  |L17.12|
00000c  f4217100          BIC      r1,r1,#0x200
                  |L17.16|
000010  8001              STRH     r1,[r0,#0]            ;431
;;;437      }
;;;438    }
000012  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1260     */
;;;1261   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1262   {
000002  4602              MOV      r2,r0
;;;1263     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1264     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1265   
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1268     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1269   
;;;1270     /* Get the I2Cx peripheral base address */
;;;1271     i2cxbase = (uint32_t)I2Cx;
;;;1272     
;;;1273     /* Read flag register index */
;;;1274     i2creg = I2C_FLAG >> 28;
000006  9200              STR      r2,[sp,#0]
000008  0f0a              LSRS     r2,r1,#28
;;;1275     
;;;1276     /* Get bit[23:0] of the flag */
;;;1277     I2C_FLAG &= FLAG_MASK;
00000a  f021417f          BIC      r1,r1,#0xff000000
00000e  9201              STR      r2,[sp,#4]            ;1262
000010  d002              BEQ      |L18.24|
;;;1278     
;;;1279     if(i2creg != 0)
;;;1280     {
;;;1281       /* Get the I2Cx SR1 register address */
;;;1282       i2cxbase += 0x14;
000012  9a00              LDR      r2,[sp,#0]
000014  3214              ADDS     r2,r2,#0x14
000016  e002              B        |L18.30|
                  |L18.24|
;;;1283     }
;;;1284     else
;;;1285     {
;;;1286       /* Flag in I2Cx SR2 Register */
;;;1287       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
;;;1288       /* Get the I2Cx SR2 register address */
;;;1289       i2cxbase += 0x18;
000018  9a00              LDR      r2,[sp,#0]
00001a  0c09              LSRS     r1,r1,#16             ;1287
00001c  3218              ADDS     r2,r2,#0x18
                  |L18.30|
;;;1290     }
;;;1291     
;;;1292     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00001e  9200              STR      r2,[sp,#0]
000020  6812              LDR      r2,[r2,#0]
000022  420a              TST      r2,r1
000024  d000              BEQ      |L18.40|
;;;1293     {
;;;1294       /* I2C_FLAG is set */
;;;1295       bitstatus = SET;
000026  2001              MOVS     r0,#1
                  |L18.40|
;;;1296     }
;;;1297     else
;;;1298     {
;;;1299       /* I2C_FLAG is reset */
;;;1300       bitstatus = RESET;
;;;1301     }
;;;1302     
;;;1303     /* Return the I2C_FLAG status */
;;;1304     return  bitstatus;
;;;1305   }
000028  bd0c              POP      {r2,r3,pc}
;;;1306   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1371     */
;;;1372   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1373   {
000002  4603              MOV      r3,r0
;;;1374     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1375     uint32_t enablestatus = 0;
;;;1376   
;;;1377     /* Check the parameters */
;;;1378     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1379     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1380   
;;;1381     /* Check if the interrupt source is enabled or not */
;;;1382     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000006  889a              LDRH     r2,[r3,#4]
000008  f44f64e0          MOV      r4,#0x700
00000c  ea044411          AND      r4,r4,r1,LSR #16
;;;1383     
;;;1384     /* Get bit[23:0] of the flag */
;;;1385     I2C_IT &= FLAG_MASK;
;;;1386   
;;;1387     /* Check the status of the specified I2C flag */
;;;1388     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000010  8a9b              LDRH     r3,[r3,#0x14]
000012  4022              ANDS     r2,r2,r4              ;1382
000014  f021417f          BIC      r1,r1,#0xff000000     ;1385
000018  420b              TST      r3,r1
00001a  d002              BEQ      |L19.34|
00001c  2a00              CMP      r2,#0
00001e  d000              BEQ      |L19.34|
;;;1389     {
;;;1390       /* I2C_IT is set */
;;;1391       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L19.34|
;;;1392     }
;;;1393     else
;;;1394     {
;;;1395       /* I2C_IT is reset */
;;;1396       bitstatus = RESET;
;;;1397     }
;;;1398     /* Return the I2C_IT status */
;;;1399     return  bitstatus;
;;;1400   }
000022  bd10              POP      {r4,pc}
;;;1401   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1205     */
;;;1206   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;1207   {
;;;1208     uint32_t lastevent = 0;
;;;1209     uint32_t flag1 = 0, flag2 = 0;
;;;1210   
;;;1211     /* Check the parameters */
;;;1212     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1213   
;;;1214     /* Read the I2Cx status register */
;;;1215     flag1 = I2Cx->SR1;
;;;1216     flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;1217     flag2 = flag2 << 16;
;;;1218   
;;;1219     /* Get the last event value from I2C status register */
;;;1220     lastevent = (flag1 | flag2) & FLAG_MASK;
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  f021407f          BIC      r0,r1,#0xff000000
;;;1221   
;;;1222     /* Return status */
;;;1223     return lastevent;
;;;1224   }
00000c  4770              BX       lr
;;;1225   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;876      */
;;;877    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;878    {
;;;879      /* Check the parameters */
;;;880      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;881      /* Return the selected I2C PEC value */
;;;882      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;883    }
000004  4770              BX       lr
;;;884    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1098     */
;;;1099   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1100   {
;;;1101     /* Check the parameters */
;;;1102     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1103     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1104     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1105     
;;;1106     if (NewState != DISABLE)
;;;1107     {
;;;1108       /* Enable the selected I2C interrupts */
;;;1109       I2Cx->CR2 |= I2C_IT;
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       /* Disable the selected I2C interrupts */
;;;1114       I2Cx->CR2 &= (uint16_t)~I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L22.10|
000006  430a              ORRS     r2,r2,r1              ;1109
000008  e000              B        |L22.12|
                  |L22.10|
00000a  438a              BICS     r2,r2,r1
                  |L22.12|
00000c  8082              STRH     r2,[r0,#4]            ;1109
;;;1115     }
;;;1116   }
00000e  4770              BX       lr
;;;1117   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;179      */
;;;180    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182      uint16_t tmpreg = 0, freqrange = 0;
;;;183      uint16_t result = 0x04;
;;;184      uint32_t pclk1 = 8000000;
;;;185      RCC_ClocksTypeDef  rcc_clocks;
;;;186      /* Check the parameters */
;;;187      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;188      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;189      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;190      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;191      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;192      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;193      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;194    
;;;195    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;196      /* Get the I2Cx CR2 value */
;;;197      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  460d              MOV      r5,r1                 ;181
;;;198      /* Clear frequency FREQ[5:0] bits */
;;;199      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
000008  f020063f          BIC      r6,r0,#0x3f
;;;200      /* Get pclk1 frequency value */
;;;201      RCC_GetClocksFreq(&rcc_clocks);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       RCC_GetClocksFreq
;;;202      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;203      /* Set frequency bits depending on pclk1 value */
;;;204      freqrange = (uint16_t)(pclk1 / 1000000);
000012  4927              LDR      r1,|L23.176|
000014  9802              LDR      r0,[sp,#8]
000016  fbb0f1f1          UDIV     r1,r0,r1
00001a  b289              UXTH     r1,r1
;;;205      tmpreg |= freqrange;
00001c  430e              ORRS     r6,r6,r1
;;;206      /* Write to I2Cx CR2 */
;;;207      I2Cx->CR2 = tmpreg;
00001e  80a6              STRH     r6,[r4,#4]
;;;208    
;;;209    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;210      /* Disable the selected I2C peripheral to configure TRISE */
;;;211      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000020  8822              LDRH     r2,[r4,#0]
000022  f0220201          BIC      r2,r2,#1
000026  8022              STRH     r2,[r4,#0]
;;;212      /* Reset tmpreg value */
;;;213      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;214      tmpreg = 0;
;;;215    
;;;216      /* Configure speed in standard mode */
;;;217      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000028  4b22              LDR      r3,|L23.180|
00002a  682a              LDR      r2,[r5,#0]
00002c  429a              CMP      r2,r3
00002e  d81b              BHI      |L23.104|
;;;218      {
;;;219        /* Standard mode speed calculate */
;;;220        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000030  0052              LSLS     r2,r2,#1
000032  fbb0f0f2          UDIV     r0,r0,r2
000036  b280              UXTH     r0,r0
;;;221        /* Test if CCR value is under 0x4*/
;;;222        if (result < 0x04)
000038  2804              CMP      r0,#4
00003a  d200              BCS      |L23.62|
;;;223        {
;;;224          /* Set minimum allowed value */
;;;225          result = 0x04;  
00003c  2004              MOVS     r0,#4
                  |L23.62|
00003e  1c49              ADDS     r1,r1,#1
;;;226        }
;;;227        /* Set speed value for standard mode */
;;;228        tmpreg |= result;	  
;;;229        /* Set Maximum Rise Time for standard mode */
;;;230        I2Cx->TRISE = freqrange + 1; 
000040  8421              STRH     r1,[r4,#0x20]
;;;231      }
;;;232      /* Configure speed in fast mode */
;;;233      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;234         input clock) must be a multiple of 10 MHz */
;;;235      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;236      {
;;;237        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;238        {
;;;239          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;240          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;241        }
;;;242        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;243        {
;;;244          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;245          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;246          /* Set DUTY bit */
;;;247          result |= I2C_DutyCycle_16_9;
;;;248        }
;;;249    
;;;250        /* Test if CCR value is under 0x1*/
;;;251        if ((result & I2C_CCR_CCR) == 0)
;;;252        {
;;;253          /* Set minimum allowed value */
;;;254          result |= (uint16_t)0x0001;  
;;;255        }
;;;256        /* Set speed value and set F/S bit for fast mode */
;;;257        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
;;;258        /* Set Maximum Rise Time for fast mode */
;;;259        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
;;;260      }
;;;261    
;;;262      /* Write to I2Cx CCR */
;;;263      I2Cx->CCR = tmpreg;
000042  83a0              STRH     r0,[r4,#0x1c]
;;;264      /* Enable the selected I2C peripheral */
;;;265      I2Cx->CR1 |= I2C_CR1_PE;
000044  8820              LDRH     r0,[r4,#0]
000046  f0400001          ORR      r0,r0,#1
00004a  8020              STRH     r0,[r4,#0]
;;;266    
;;;267    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;268      /* Get the I2Cx CR1 value */
;;;269      tmpreg = I2Cx->CR1;
00004c  8820              LDRH     r0,[r4,#0]
;;;270      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;271      tmpreg &= CR1_CLEAR_MASK;
00004e  f64f31f5          MOV      r1,#0xfbf5
000052  4008              ANDS     r0,r0,r1
;;;272      /* Configure I2Cx: mode and acknowledgement */
;;;273      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;274      /* Set ACK bit according to I2C_Ack value */
;;;275      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000054  88a9              LDRH     r1,[r5,#4]
000056  896a              LDRH     r2,[r5,#0xa]
000058  4311              ORRS     r1,r1,r2
00005a  4301              ORRS     r1,r1,r0
;;;276      /* Write to I2Cx CR1 */
;;;277      I2Cx->CR1 = tmpreg;
00005c  8021              STRH     r1,[r4,#0]
;;;278    
;;;279    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;280      /* Set I2Cx Own Address1 and acknowledged address */
;;;281      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
00005e  89a8              LDRH     r0,[r5,#0xc]
000060  8929              LDRH     r1,[r5,#8]
000062  4308              ORRS     r0,r0,r1
000064  8120              STRH     r0,[r4,#8]
;;;282    }
000066  bd7f              POP      {r0-r6,pc}
                  |L23.104|
000068  88eb              LDRH     r3,[r5,#6]            ;237
00006a  f5a3463f          SUB      r6,r3,#0xbf00         ;237
00006e  3eff              SUBS     r6,r6,#0xff           ;237
000070  d00b              BEQ      |L23.138|
000072  eb0203c2          ADD      r3,r2,r2,LSL #3       ;245
000076  eb031202          ADD      r2,r3,r2,LSL #4       ;245
00007a  fbb0f0f2          UDIV     r0,r0,r2              ;245
00007e  b280              UXTH     r0,r0                 ;245
000080  f4404080          ORR      r0,r0,#0x4000         ;247
                  |L23.132|
000084  0502              LSLS     r2,r0,#20             ;251
000086  d006              BEQ      |L23.150|
000088  e007              B        |L23.154|
                  |L23.138|
00008a  eb020242          ADD      r2,r2,r2,LSL #1       ;240
00008e  fbb0f0f2          UDIV     r0,r0,r2              ;240
000092  b280              UXTH     r0,r0                 ;240
000094  e7f6              B        |L23.132|
                  |L23.150|
000096  f0400001          ORR      r0,r0,#1              ;254
                  |L23.154|
00009a  f44f7296          MOV      r2,#0x12c             ;259
00009e  4351              MULS     r1,r2,r1              ;259
0000a0  f44f727a          MOV      r2,#0x3e8             ;259
0000a4  fbb1f1f2          UDIV     r1,r1,r2              ;259
0000a8  f4404000          ORR      r0,r0,#0x8000         ;257
0000ac  e7c7              B        |L23.62|
;;;283    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L23.176|
                          DCD      0x000f4240
                  |L23.180|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;665      */
;;;666    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;667    {
;;;668      /* Check the parameters */
;;;669      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;670      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;671      
;;;672      /* Check the input parameter */
;;;673      if (I2C_NACKPosition == I2C_NACKPosition_Next)
;;;674      {
;;;675        /* Next byte in shift register is the last received byte */
;;;676        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;677      }
;;;678      else
;;;679      {
;;;680        /* Current byte in shift register is the last received byte */
;;;681        I2Cx->CR1 &= I2C_NACKPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L24.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L24.12|
00000c  8001              STRH     r1,[r0,#0]            ;676
;;;682      }
;;;683    }
00000e  4770              BX       lr
                  |L24.16|
000010  f4416100          ORR      r1,r1,#0x800          ;676
000014  e7fa              B        |L24.12|
;;;684    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;500      */
;;;501    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;502    {
;;;503      uint16_t tmpreg = 0;
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;507    
;;;508      /* Get the old register value */
;;;509      tmpreg = I2Cx->OAR2;
;;;510    
;;;511      /* Reset I2Cx Own address2 bit [7:1] */
;;;512      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
;;;513    
;;;514      /* Set I2Cx Own address2 */
;;;515      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;512
00000a  4311              ORRS     r1,r1,r2
;;;516    
;;;517      /* Store the new register value */
;;;518      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;519    }
00000e  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;830      */
;;;831    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;832    {
;;;833      /* Check the parameters */
;;;834      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;835      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;836      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;837      {
;;;838        /* Next byte in shift register is PEC */
;;;839        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;840      }
;;;841      else
;;;842      {
;;;843        /* Current byte in shift register is PEC */
;;;844        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L26.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L26.12|
00000c  8001              STRH     r1,[r0,#0]            ;839
;;;845      }
;;;846    }
00000e  4770              BX       lr
                  |L26.16|
000010  f4416100          ORR      r1,r1,#0x800          ;839
000014  e7fa              B        |L26.12|
;;;847    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1071     */
;;;1072   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;1073   {
;;;1074     __IO uint32_t tmp = 0;
;;;1075   
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1078     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1079   
;;;1080     tmp = (uint32_t) I2Cx;
;;;1081     tmp += I2C_Register;
000002  4408              ADD      r0,r0,r1
;;;1082   
;;;1083     /* Return the selected register value */
;;;1084     return (*(__IO uint16_t *) tmp);
000004  9000              STR      r0,[sp,#0]
000006  8800              LDRH     r0,[r0,#0]
;;;1085   }
000008  bd08              POP      {r3,pc}
;;;1086   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;768      */
;;;769    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;770    {
;;;771      /* Check the parameters */
;;;772      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;773      /* Return the data in the DR register */
;;;774      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;775    }
000004  4770              BX       lr
;;;776    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;693      */
;;;694    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;695    {
;;;696      /* Check the parameters */
;;;697      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;698      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;699      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;700      {
;;;701        /* Drive the SMBusAlert pin Low */
;;;702        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;703      }
;;;704      else
;;;705      {
;;;706        /* Drive the SMBusAlert pin High  */
;;;707        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L29.16|
000008  f4215100          BIC      r1,r1,#0x2000
                  |L29.12|
00000c  8001              STRH     r1,[r0,#0]            ;702
;;;708      }
;;;709    }
00000e  4770              BX       lr
                  |L29.16|
000010  f4415100          ORR      r1,r1,#0x2000         ;702
000014  e7fa              B        |L29.12|
;;;710    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;450      */
;;;451    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L30.8|
;;;452    {
;;;453      /* Check the parameters */
;;;454      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;455      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;456      /* Test on the direction to set/reset the read/write bit */
;;;457      if (I2C_Direction != I2C_Direction_Transmitter)
;;;458      {
;;;459        /* Set the address bit0 for read */
;;;460        Address |= I2C_OAR1_ADD0;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L30.12|
                  |L30.8|
;;;461      }
;;;462      else
;;;463      {
;;;464        /* Reset the address bit0 for write */
;;;465        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          AND      r1,r1,#0xfe
                  |L30.12|
;;;466      }
;;;467      /* Send the address */
;;;468      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;469    }
00000e  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;755      */
;;;756    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;757    {
;;;758      /* Check the parameters */
;;;759      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;760      /* Write in the DR register the data to be sent */
;;;761      I2Cx->DR = Data;
;;;762    }
000002  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;577      */
;;;578    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;582      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;583      if (NewState != DISABLE)
;;;584      {
;;;585        /* Peripheral under reset */
;;;586        I2Cx->CR1 |= I2C_CR1_SWRST;
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Peripheral not under reset */
;;;591        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L32.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;586
00000a  e001              B        |L32.16|
                  |L32.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L32.16|
000010  8001              STRH     r1,[r0,#0]            ;586
;;;592      }
;;;593    }
000012  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;601      */
;;;602    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;606      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;607      if (NewState == DISABLE)
;;;608      {
;;;609        /* Enable the selected I2C Clock stretching */
;;;610        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Disable the selected I2C Clock stretching */
;;;615        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000002  8801              LDRH     r1,[r0,#0]
000004  d003              BEQ      |L33.14|
000006  f0210180          BIC      r1,r1,#0x80
                  |L33.10|
00000a  8001              STRH     r1,[r0,#0]            ;610
;;;616      }
;;;617    }
00000c  4770              BX       lr
                  |L33.14|
00000e  f0410180          ORR      r1,r1,#0x80           ;610
000012  e7fa              B        |L33.10|
;;;618    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;288      */
;;;289    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;290    {
;;;291    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;292      /* initialize the I2C_ClockSpeed member */
;;;293      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;294      /* Initialize the I2C_Mode member */
;;;295      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;296      /* Initialize the I2C_DutyCycle member */
;;;297      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;298      /* Initialize the I2C_OwnAddress1 member */
;;;299      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;300      /* Initialize the I2C_Ack member */
;;;301      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;302      /* Initialize the I2C_AcknowledgedAddress member */
;;;303      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;304    }
00001a  4770              BX       lr
;;;305    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;799      */
;;;800    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;804      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        /* Enable the selected I2C PEC transmission */
;;;808        I2Cx->CR1 |= I2C_CR1_PEC;
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable the selected I2C PEC transmission */
;;;813        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L35.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;808
00000a  e001              B        |L35.16|
                  |L35.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L35.16|
000010  8001              STRH     r1,[r0,#0]            ;808
;;;814      }
;;;815    }
000012  4770              BX       lr
;;;816    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_i2c_c_7174d409____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REVSH|
#line 144
|__asm___15_stm32f4xx_i2c_c_7174d409____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
