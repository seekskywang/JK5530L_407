; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_it.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_it.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_it.crf --no_multibyte_chars ..\User\stm32f4xx_it.c]
                          THUMB

                          AREA ||i.BEBufToUint16||, CODE, READONLY, ALIGN=1

                  BEBufToUint16 PROC
;;;249    */
;;;250    uint16_t BEBufToUint16(uint8_t *_pBuf)
000000  8800              LDRH     r0,[r0,#0]
;;;251    {
;;;252        return (((uint16_t)_pBuf[0] << 8) | _pBuf[1]);
000002  ba40              REV16    r0,r0
;;;253    }
000004  4770              BX       lr
;;;254    
                          ENDP


                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
                  |L2.0|
;;;117      */
;;;118    void BusFault_Handler(void)
000000  e7fe              B        |L2.0|
;;;119    {
;;;120      /* Go to infinite loop when Bus Fault exception occurs */
;;;121      while (1)
;;;122      {
;;;123      }
;;;124    }
;;;125    
                          ENDP


                          AREA ||i.CRC16||, CODE, READONLY, ALIGN=2

                  CRC16 PROC
;;;1085   
;;;1086   uint16_t CRC16(uint8_t *_pBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;1087   {    
;;;1088       uint8_t ucCRCHi = 0xFF; /* 高CRC字节初始化 */
;;;1089   	uint8_t ucCRCLo = 0xFF; /* 低CRC 字节初始化 */
;;;1090   	uint16_t usIndex;  /* CRC循环中的索引 */
;;;1091   
;;;1092       while (_usLen--)
;;;1093       {
;;;1094   		usIndex = ucCRCHi ^ *_pBuf++; /* 计算CRC */
;;;1095   		ucCRCHi = ucCRCLo ^ s_CRCHi[usIndex];
000002  4d09              LDR      r5,|L3.40|
000004  22ff              MOVS     r2,#0xff              ;1088
000006  4613              MOV      r3,r2                 ;1089
;;;1096   		ucCRCLo = s_CRCLo[usIndex];
000008  f5057680          ADD      r6,r5,#0x100
00000c  e005              B        |L3.26|
                  |L3.14|
00000e  f8104b01          LDRB     r4,[r0],#1            ;1094
000012  4054              EORS     r4,r4,r2              ;1094
000014  5d2a              LDRB     r2,[r5,r4]            ;1095
000016  405a              EORS     r2,r2,r3              ;1095
000018  5d33              LDRB     r3,[r6,r4]
                  |L3.26|
00001a  1e49              SUBS     r1,r1,#1              ;1092
00001c  b289              UXTH     r1,r1                 ;1092
00001e  d2f6              BCS      |L3.14|
;;;1097       }
;;;1098       return ((uint16_t)ucCRCHi << 8 | ucCRCLo);
000020  ea432002          ORR      r0,r3,r2,LSL #8
;;;1099   }
000024  bd70              POP      {r4-r6,pc}
;;;1100   /******************************************************************************/
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      ||.constdata||

                          AREA ||i.DMA2_Stream0_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Stream0_IRQHandler PROC
;;;337    
;;;338    void  DMA2_Stream0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;339    {
;;;340    	DMA_ClearITPendingBit(DMA2_Stream0,DMA_IT_TCIF0);
000002  4905              LDR      r1,|L4.24|
000004  4805              LDR      r0,|L4.28|
000006  f7fffffe          BL       DMA_ClearITPendingBit
;;;341    	Flag_ADC_Full=1;
00000a  4805              LDR      r0,|L4.32|
00000c  6801              LDR      r1,[r0,#0]  ; flagA
00000e  f0410102          ORR      r1,r1,#2
000012  6001              STR      r1,[r0,#0]  ; flagA
;;;342    }
000014  bd10              POP      {r4,pc}
;;;343    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x10008020
                  |L4.28|
                          DCD      0x40026410
                  |L4.32|
                          DCD      flagA

                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;152      */
;;;153    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;154    {
;;;155    }
;;;156    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L6.0|
;;;91       */
;;;92     void HardFault_Handler(void)
000000  e7fe              B        |L6.0|
;;;93     {
;;;94       /* Go to infinite loop when Hard Fault exception occurs */
;;;95       while (1)
;;;96       {
;;;97       }
;;;98     }
;;;99     
                          ENDP


                          AREA ||i.MODS_03H||, CODE, READONLY, ALIGN=2

                  MODS_03H PROC
;;;844    
;;;845    static void MODS_03H(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;846    {
;;;847        uint16_t reg;
;;;848    	uint16_t num;
;;;849    	uint16_t i;
;;;850    	uint8_t reg_value[64];
;;;851    
;;;852        
;;;853        g_tModS.RspCode = RSP_OK;
000004  4e2d              LDR      r6,|L7.188|
000006  b091              SUB      sp,sp,#0x44           ;846
000008  f04f0a00          MOV      r10,#0
00000c  f886a0a1          STRB     r10,[r6,#0xa1]
;;;854    
;;;855    	if (g_tModS.RxCount != 8)								/* 03H命令必须是8个字节 */
000010  f896009e          LDRB     r0,[r6,#0x9e]  ; g_tModS
;;;856    	{
;;;857    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000014  f04f0903          MOV      r9,#3
000018  2808              CMP      r0,#8                 ;855
00001a  d109              BNE      |L7.48|
;;;858    		goto err_ret;
;;;859    	}
;;;860    
;;;861    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 				/* 寄存器号 */
00001c  1cb0              ADDS     r0,r6,#2
00001e  f7fffffe          BL       BEBufToUint16
000022  4607              MOV      r7,r0
;;;862    	num = BEBufToUint16(&g_tModS.RxBuf[4]);					/* 寄存器个数 */
000024  1d30              ADDS     r0,r6,#4
000026  f7fffffe          BL       BEBufToUint16
00002a  4605              MOV      r5,r0
;;;863    	if (num > sizeof(reg_value) / 2)
00002c  2820              CMP      r0,#0x20
00002e  d904              BLS      |L7.58|
                  |L7.48|
;;;864    	{
;;;865    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000030  f88690a1          STRB     r9,[r6,#0xa1]
                  |L7.52|
;;;866    		goto err_ret;
;;;867    	}
;;;868    
;;;869    	for (i = 0; i < num; i++)
;;;870    	{
;;;871    		if (MODS_ReadRegValue(reg, &reg_value[2 * i]) == 0)	/* 读出寄存器值放入reg_value */
;;;872    		{
;;;873    			g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
;;;874    			break;
;;;875    		}
;;;876    		reg++;
;;;877    	}
;;;878    
;;;879    err_ret:
;;;880    	if (g_tModS.RspCode == RSP_OK)							/* 正确应答 */
;;;881    	{
;;;882    		g_tModS.TxCount = 0;
;;;883    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
;;;884    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
;;;885    		g_tModS.TxBuf[g_tModS.TxCount++] = num * 2;			/* 返回字节数 */
;;;886    
;;;887    		for (i = 0; i < num; i++)
;;;888    		{
;;;889    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i];
;;;890    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i+1];
;;;891    		}
;;;892    //         if(usartocflag == 0)
;;;893    //         {
;;;894    //             MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);	/* 发送正确应答 */
;;;895    //         }
;;;896    	}
;;;897    	else
;;;898    	{
;;;899    //		MODS_SendAckErr(g_tModS.RspCode);					/* 发送错误应答 */
;;;900    	}
;;;901        
;;;902    }
000034  b011              ADD      sp,sp,#0x44
000036  e8bd8ff0          POP      {r4-r11,pc}
                  |L7.58|
00003a  2400              MOVS     r4,#0                 ;869
00003c  f04f0b02          MOV      r11,#2                ;873
000040  46e8              MOV      r8,sp                 ;850
000042  e009              B        |L7.88|
                  |L7.68|
000044  eb080144          ADD      r1,r8,r4,LSL #1       ;871
000048  4638              MOV      r0,r7                 ;871
00004a  f7fffffe          BL       MODS_ReadRegValue
00004e  b1c8              CBZ      r0,|L7.132|
000050  1c7f              ADDS     r7,r7,#1              ;871
000052  1c64              ADDS     r4,r4,#1              ;876
000054  b2bf              UXTH     r7,r7                 ;876
000056  b2a4              UXTH     r4,r4                 ;869
                  |L7.88|
000058  42ac              CMP      r4,r5                 ;869
00005a  d3f3              BCC      |L7.68|
00005c  f89600a1          LDRB     r0,[r6,#0xa1]         ;880  ; g_tModS
000060  2800              CMP      r0,#0                 ;880
000062  d1e7              BNE      |L7.52|
000064  4815              LDR      r0,|L7.188|
000066  7832              LDRB     r2,[r6,#0]            ;883  ; g_tModS
000068  301e              ADDS     r0,r0,#0x1e           ;883
00006a  2101              MOVS     r1,#1                 ;883
00006c  f80a2000          STRB     r2,[r10,r0]           ;883
000070  7872              LDRB     r2,[r6,#1]            ;884  ; g_tModS
000072  540a              STRB     r2,[r1,r0]            ;884
000074  006a              LSLS     r2,r5,#1              ;885
000076  f80b2000          STRB     r2,[r11,r0]           ;885
00007a  f88690a2          STRB     r9,[r6,#0xa2]         ;885
00007e  2100              MOVS     r1,#0                 ;887
000080  4643              MOV      r3,r8                 ;850
000082  e018              B        |L7.182|
                  |L7.132|
000084  f886b0a1          STRB     r11,[r6,#0xa1]        ;873
000088  e7d4              B        |L7.52|
                  |L7.138|
00008a  f89640a2          LDRB     r4,[r6,#0xa2]         ;889  ; g_tModS
00008e  f8132011          LDRB     r2,[r3,r1,LSL #1]     ;889
000092  5422              STRB     r2,[r4,r0]            ;889
000094  f89620a2          LDRB     r2,[r6,#0xa2]         ;889  ; g_tModS
000098  eb030441          ADD      r4,r3,r1,LSL #1       ;890
00009c  1c52              ADDS     r2,r2,#1              ;889
00009e  b2d2              UXTB     r2,r2                 ;889
0000a0  f88620a2          STRB     r2,[r6,#0xa2]         ;889
0000a4  7864              LDRB     r4,[r4,#1]            ;890
0000a6  5414              STRB     r4,[r2,r0]            ;890
0000a8  f89620a2          LDRB     r2,[r6,#0xa2]         ;890  ; g_tModS
0000ac  1c52              ADDS     r2,r2,#1              ;890
0000ae  1c49              ADDS     r1,r1,#1              ;890
0000b0  f88620a2          STRB     r2,[r6,#0xa2]         ;890
0000b4  b289              UXTH     r1,r1                 ;887
                  |L7.182|
0000b6  42a9              CMP      r1,r5                 ;887
0000b8  d3e7              BCC      |L7.138|
0000ba  e7bb              B        |L7.52|
;;;903    
                          ENDP

                  |L7.188|
                          DCD      ||.bss||

                          AREA ||i.MODS_06H||, CODE, READONLY, ALIGN=2

                  MODS_06H PROC
;;;927    
;;;928    static void MODS_06H(void)
000000  b510              PUSH     {r4,lr}
;;;929    {
;;;930        uint16_t reg;
;;;931    	uint16_t value;
;;;932    
;;;933    	g_tModS.RspCode = RSP_OK;
000002  4c12              LDR      r4,|L8.76|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;934    
;;;935    	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L8.22|
;;;936    	{
;;;937    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000012  2003              MOVS     r0,#3
;;;938    		goto err_ret;
000014  e00d              B        |L8.50|
                  |L8.22|
;;;939    	}
;;;940    
;;;941    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
000016  1ca0              ADDS     r0,r4,#2
000018  f7fffffe          BL       BEBufToUint16
00001c  4602              MOV      r2,r0
;;;942    	value = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 寄存器值 */
00001e  1d20              ADDS     r0,r4,#4
000020  f7fffffe          BL       BEBufToUint16
000024  4601              MOV      r1,r0
;;;943        
;;;944    //    if(reg == 0x0E)
;;;945    //    {
;;;946    //        if(value == 00)
;;;947    //        {
;;;948    //            GPIO_SetBits(GPIOC,GPIO_Pin_10);//CC
;;;949    //            flag_Load_CC = 1;
;;;950    //        }else if(value == 01){
;;;951    //            GPIO_ResetBits(GPIOC,GPIO_Pin_10);//CV
;;;952    //            flag_Load_CC = 0;
;;;953    //        }
;;;954    //    }
;;;955     	if (MODS_WriteRegValue(reg, value) == 1)	/* 该函数会把写入的值存入寄存器 */
000026  4610              MOV      r0,r2
000028  f7fffffe          BL       MODS_WriteRegValue
00002c  2801              CMP      r0,#1
00002e  d003              BEQ      |L8.56|
;;;956     	{
;;;957     		;
;;;958     	}
;;;959     	else
;;;960     	{
;;;961     		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
000030  2002              MOVS     r0,#2
                  |L8.50|
000032  f88400a1          STRB     r0,[r4,#0xa1]         ;937
000036  e003              B        |L8.64|
                  |L8.56|
;;;962     	}
;;;963    
;;;964    err_ret:
;;;965    	if (g_tModS.RspCode == RSP_OK)				/* 正确应答 */
000038  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
00003c  2800              CMP      r0,#0
00003e  d004              BEQ      |L8.74|
                  |L8.64|
;;;966    	{
;;;967    		
;;;968    	}
;;;969    	else
;;;970    	{
;;;971    		MODS_SendAckErr(g_tModS.RspCode);		/* 告诉主机命令错误 */
000040  e8bd4010          POP      {r4,lr}
000044  b2c0              UXTB     r0,r0
000046  f7ffbffe          B.W      MODS_SendAckErr
                  |L8.74|
;;;972    	}
;;;973    }
00004a  bd10              POP      {r4,pc}
;;;974    
                          ENDP

                  |L8.76|
                          DCD      ||.bss||

                          AREA ||i.MODS_50H||, CODE, READONLY, ALIGN=2

                  MODS_50H PROC
;;;974    
;;;975    static void MODS_50H(void)
000000  b510              PUSH     {r4,lr}
;;;976    {
;;;977        uint16_t reg;
;;;978    	uint16_t value;
;;;979    
;;;980    	g_tModS.RspCode = RSP_OK;
000002  4c13              LDR      r4,|L9.80|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;981    
;;;982    	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L9.22|
;;;983    	{
;;;984    		g_tModS.RspCode = RSP_ERR_VALUE;		
000012  2003              MOVS     r0,#3
;;;985    		goto err_ret;
000014  e00d              B        |L9.50|
                  |L9.22|
;;;986    	}
;;;987    
;;;988    	reg = BEBufToUint16(&g_tModS.RxBuf[2]);
000016  1ca0              ADDS     r0,r4,#2
000018  f7fffffe          BL       BEBufToUint16
00001c  4602              MOV      r2,r0
;;;989    	value = BEBufToUint16(&g_tModS.RxBuf[4]);
00001e  1d20              ADDS     r0,r4,#4
000020  f7fffffe          BL       BEBufToUint16
000024  4601              MOV      r1,r0
;;;990        
;;;991    
;;;992     	if (MODS_Load(reg, value) == 1)
000026  4610              MOV      r0,r2
000028  f7fffffe          BL       MODS_Load
00002c  2801              CMP      r0,#1
00002e  d003              BEQ      |L9.56|
;;;993     	{
;;;994     		;
;;;995     	}
;;;996     	else
;;;997     	{
;;;998     		g_tModS.RspCode = RSP_ERR_REG_ADDR;
000030  2002              MOVS     r0,#2
                  |L9.50|
000032  f88400a1          STRB     r0,[r4,#0xa1]         ;984
000036  e002              B        |L9.62|
                  |L9.56|
;;;999     	}
;;;1000   
;;;1001   err_ret:
;;;1002   	if (g_tModS.RspCode == RSP_OK)
000038  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
00003c  b120              CBZ      r0,|L9.72|
                  |L9.62|
;;;1003   	{
;;;1004   		MODS_SendAckOk();
;;;1005   	}
;;;1006   	else
;;;1007   	{
;;;1008   		MODS_SendAckErr(g_tModS.RspCode);
00003e  e8bd4010          POP      {r4,lr}
000042  b2c0              UXTB     r0,r0
000044  f7ffbffe          B.W      MODS_SendAckErr
                  |L9.72|
000048  e8bd4010          POP      {r4,lr}               ;1004
00004c  f7ffbffe          B.W      MODS_SendAckOk
;;;1009   	}
;;;1010   }
;;;1011   
                          ENDP

                  |L9.80|
                          DCD      ||.bss||

                          AREA ||i.MODS_51H||, CODE, READONLY, ALIGN=2

                  MODS_51H PROC
;;;1011   
;;;1012   static void MODS_51H(void)
000000  b510              PUSH     {r4,lr}
;;;1013   {
;;;1014       uint16_t reg;
;;;1015   	uint16_t value;
;;;1016   
;;;1017   	g_tModS.RspCode = RSP_OK;
000002  4c13              LDR      r4,|L10.80|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;1018   
;;;1019   	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L10.22|
;;;1020   	{
;;;1021   		g_tModS.RspCode = RSP_ERR_VALUE;		
000012  2003              MOVS     r0,#3
;;;1022   		goto err_ret;
000014  e00d              B        |L10.50|
                  |L10.22|
;;;1023   	}
;;;1024   
;;;1025   	reg = BEBufToUint16(&g_tModS.RxBuf[2]);
000016  1ca0              ADDS     r0,r4,#2
000018  f7fffffe          BL       BEBufToUint16
00001c  4602              MOV      r2,r0
;;;1026   	value = BEBufToUint16(&g_tModS.RxBuf[4]);
00001e  1d20              ADDS     r0,r4,#4
000020  f7fffffe          BL       BEBufToUint16
000024  4601              MOV      r1,r0
;;;1027       
;;;1028   
;;;1029    	if (MODS_Pow(reg, value) == 1)
000026  4610              MOV      r0,r2
000028  f7fffffe          BL       MODS_Pow
00002c  2801              CMP      r0,#1
00002e  d003              BEQ      |L10.56|
;;;1030    	{
;;;1031    		;
;;;1032    	}
;;;1033    	else
;;;1034    	{
;;;1035    		g_tModS.RspCode = RSP_ERR_REG_ADDR;
000030  2002              MOVS     r0,#2
                  |L10.50|
000032  f88400a1          STRB     r0,[r4,#0xa1]         ;1021
000036  e002              B        |L10.62|
                  |L10.56|
;;;1036    	}
;;;1037   
;;;1038   err_ret:
;;;1039   	if (g_tModS.RspCode == RSP_OK)
000038  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
00003c  b120              CBZ      r0,|L10.72|
                  |L10.62|
;;;1040   	{
;;;1041   		MODS_SendAckOk();
;;;1042   	}
;;;1043   	else
;;;1044   	{
;;;1045   		MODS_SendAckErr(g_tModS.RspCode);
00003e  e8bd4010          POP      {r4,lr}
000042  b2c0              UXTB     r0,r0
000044  f7ffbffe          B.W      MODS_SendAckErr
                  |L10.72|
000048  e8bd4010          POP      {r4,lr}               ;1041
00004c  f7ffbffe          B.W      MODS_SendAckOk
;;;1046   	}
;;;1047   }
;;;1048   
                          ENDP

                  |L10.80|
                          DCD      ||.bss||

                          AREA ||i.MODS_52H||, CODE, READONLY, ALIGN=2

                  MODS_52H PROC
;;;1048   
;;;1049   static void MODS_52H(void)
000000  b510              PUSH     {r4,lr}
;;;1050   {
;;;1051       uint16_t reg;
;;;1052   	uint16_t value;
;;;1053   
;;;1054   	g_tModS.RspCode = RSP_OK;
000002  4c13              LDR      r4,|L11.80|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;1055   
;;;1056   	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L11.22|
;;;1057   	{
;;;1058   		g_tModS.RspCode = RSP_ERR_VALUE;		
000012  2003              MOVS     r0,#3
;;;1059   		goto err_ret;
000014  e00d              B        |L11.50|
                  |L11.22|
;;;1060   	}
;;;1061   
;;;1062   	reg = BEBufToUint16(&g_tModS.RxBuf[2]);
000016  1ca0              ADDS     r0,r4,#2
000018  f7fffffe          BL       BEBufToUint16
00001c  4602              MOV      r2,r0
;;;1063   	value = BEBufToUint16(&g_tModS.RxBuf[4]);
00001e  1d20              ADDS     r0,r4,#4
000020  f7fffffe          BL       BEBufToUint16
000024  4601              MOV      r1,r0
;;;1064       
;;;1065   
;;;1066    	if (MODS_CDC(reg, value) == 1)
000026  4610              MOV      r0,r2
000028  f7fffffe          BL       MODS_CDC
00002c  2801              CMP      r0,#1
00002e  d003              BEQ      |L11.56|
;;;1067    	{
;;;1068   		
;;;1069    	}
;;;1070    	else
;;;1071    	{
;;;1072    		g_tModS.RspCode = RSP_ERR_REG_ADDR;
000030  2002              MOVS     r0,#2
                  |L11.50|
000032  f88400a1          STRB     r0,[r4,#0xa1]         ;1058
000036  e002              B        |L11.62|
                  |L11.56|
;;;1073    	}
;;;1074   
;;;1075   err_ret:
;;;1076   	if (g_tModS.RspCode == RSP_OK)
000038  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
00003c  b120              CBZ      r0,|L11.72|
                  |L11.62|
;;;1077   	{
;;;1078   		MODS_SendAckOk();
;;;1079   	}
;;;1080   	else
;;;1081   	{
;;;1082   		MODS_SendAckErr(g_tModS.RspCode);
00003e  e8bd4010          POP      {r4,lr}
000042  b2c0              UXTB     r0,r0
000044  f7ffbffe          B.W      MODS_SendAckErr
                  |L11.72|
000048  e8bd4010          POP      {r4,lr}               ;1078
00004c  f7ffbffe          B.W      MODS_SendAckOk
;;;1083   	}
;;;1084   }
;;;1085   
                          ENDP

                  |L11.80|
                          DCD      ||.bss||

                          AREA ||i.MODS_CDC||, CODE, READONLY, ALIGN=2

                  MODS_CDC PROC
;;;754    
;;;755    static uint8_t MODS_CDC(uint16_t reg_addr, uint16_t reg_value)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;756    {
;;;757    
;;;758    	switch (reg_addr)							
000004  2812              CMP      r0,#0x12
000006  d243              BCS      |L12.144|
000008  e8dff000          TBB      [pc,r0]
00000c  093f3f3f          DCB      0x09,0x3f,0x3f,0x3f
000010  3f3f3f3f          DCB      0x3f,0x3f,0x3f,0x3f
000014  3f3f3f3f          DCB      0x3f,0x3f,0x3f,0x3f
000018  3f3f3f3f          DCB      0x3f,0x3f,0x3f,0x3f
00001c  3f3f              DCB      0x3f,0x3f
00001e  2500              MOVS     r5,#0
000020  2401              MOVS     r4,#1                 ;756
;;;759    	{	
;;;760    		case SLAVE_REG_P00://寮濮姝㈢垫?
;;;761    			if(reg_value == 1)//寮濮垫?
;;;762    			{
;;;763    				MODE = 5;
;;;764    //				GPIO_SetBits(GPIOE,GPIO_Pin_2);
;;;765    				Para.CSET_Voltage = Para.CDC_OutPut_V;
;;;766    				Para.CSET_Current = Para.CDC_Limit_C;
;;;767    				Para.CSET_Current_Laod = Para.CDC_Load_C;
;;;768    				mainswitch = 1;
000022  4e1c              LDR      r6,|L12.148|
;;;769    				listsend = 1;
000024  4f1c              LDR      r7,|L12.152|
;;;770    //			    GPIO_SetBits(GPIOC,GPIO_Pin_1);
;;;771    				rmtrig[2] = 1;
000026  f8df8074          LDR      r8,|L12.156|
00002a  2901              CMP      r1,#1                 ;761
00002c  d002              BEQ      |L12.52|
;;;772    				mode_sw = 0;
;;;773    				sendmodeflag = 1;
;;;774    				charge_step = 1;
;;;775    				loop = 1;
;;;776    				cdcswdelay = 5000;
;;;777    			}else if(reg_value == 4){//姝㈢垫
00002e  2904              CMP      r1,#4
000030  d01d              BEQ      |L12.110|
000032  e02a              B        |L12.138|
                  |L12.52|
000034  491a              LDR      r1,|L12.160|
000036  2005              MOVS     r0,#5                 ;763
000038  7008              STRB     r0,[r1,#0]            ;763
00003a  481a              LDR      r0,|L12.164|
00003c  f8b0106a          LDRH     r1,[r0,#0x6a]         ;765  ; Para
000040  6081              STR      r1,[r0,#8]            ;765  ; Para
000042  f8b0106c          LDRH     r1,[r0,#0x6c]         ;766  ; Para
000046  60c1              STR      r1,[r0,#0xc]          ;766  ; Para
000048  6f81              LDR      r1,[r0,#0x78]         ;767  ; Para
00004a  6141              STR      r1,[r0,#0x14]         ;767  ; Para
00004c  7034              STRB     r4,[r6,#0]            ;768
00004e  703c              STRB     r4,[r7,#0]            ;769
000050  4812              LDR      r0,|L12.156|
000052  f8884002          STRB     r4,[r8,#2]            ;771
000056  1ec0              SUBS     r0,r0,#3              ;772
000058  7085              STRB     r5,[r0,#2]            ;772
00005a  7044              STRB     r4,[r0,#1]            ;773
00005c  4812              LDR      r0,|L12.168|
00005e  7004              STRB     r4,[r0,#0]            ;774
000060  4812              LDR      r0,|L12.172|
000062  7004              STRB     r4,[r0,#0]            ;775
000064  4912              LDR      r1,|L12.176|
000066  f2413088          MOV      r0,#0x1388            ;776
00006a  8008              STRH     r0,[r1,#0]            ;776
00006c  e00d              B        |L12.138|
                  |L12.110|
;;;778    				Off_GPOI_ResetSet();
00006e  f7fffffe          BL       Off_GPOI_ResetSet
;;;779    				mainswitch = 0;
000072  7035              STRB     r5,[r6,#0]
;;;780    				listsend = 1;
000074  703c              STRB     r4,[r7,#0]
;;;781    			    rmtrig[2] = 0;
;;;782    				CDC_CsumMah = 0;
000076  4810              LDR      r0,|L12.184|
000078  ed9f0a0e          VLDR     s0,|L12.180|
00007c  f8885002          STRB     r5,[r8,#2]            ;781
000080  ed800a00          VSTR     s0,[r0,#0]
;;;783    				CDC_DCsumMah = 0;
000084  480d              LDR      r0,|L12.188|
000086  ed800a00          VSTR     s0,[r0,#0]
                  |L12.138|
;;;784    			}
;;;785    			break;
;;;786    		case SLAVE_REG_P01://
;;;787    
;;;788    			break;
;;;789    		
;;;790    		case SLAVE_REG_P02://
;;;791    
;;;792    			break;
;;;793    		case SLAVE_REG_P03://
;;;794    
;;;795    			break;
;;;796    
;;;797    		case SLAVE_REG_P04://
;;;798    
;;;799    			break;
;;;800    		case SLAVE_REG_P05://
;;;801    
;;;802    			break;
;;;803    
;;;804    		case SLAVE_REG_P06://
;;;805    
;;;806    			break;
;;;807    		case SLAVE_REG_P07://
;;;808    
;;;809    			break;
;;;810    		case SLAVE_REG_P08://
;;;811    
;;;812    			break;
;;;813    		case SLAVE_REG_P09:	//
;;;814    
;;;815    			break;
;;;816    		case SLAVE_REG_P10:	//
;;;817    
;;;818    			break;
;;;819    
;;;820    		case SLAVE_REG_P11://
;;;821    
;;;822    			break;
;;;823    		case SLAVE_REG_P12:
;;;824    			break;
;;;825    
;;;826    		case SLAVE_REG_P13:
;;;827    			break;
;;;828    		case SLAVE_REG_P14:
;;;829    			break;
;;;830    
;;;831    		case SLAVE_REG_P15:
;;;832    			break;
;;;833    		case SLAVE_REG_P16:
;;;834    			break;
;;;835    
;;;836    		case SLAVE_REG_P17:
;;;837    			break;
;;;838    		default:
;;;839    			return 0;
;;;840    	}
;;;841    
;;;842    	return 1;
00008a  2001              MOVS     r0,#1
                  |L12.140|
;;;843    }
00008c  e8bd81f0          POP      {r4-r8,pc}
                  |L12.144|
000090  2000              MOVS     r0,#0                 ;839
000092  e7fb              B        |L12.140|
;;;844    
                          ENDP

                  |L12.148|
                          DCD      mainswitch
                  |L12.152|
                          DCD      listsend
                  |L12.156|
                          DCD      ||.data||+0x3
                  |L12.160|
                          DCD      MODE
                  |L12.164|
                          DCD      Para
                  |L12.168|
                          DCD      charge_step
                  |L12.172|
                          DCD      loop
                  |L12.176|
                          DCD      cdcswdelay
                  |L12.180|
0000b4  00000000          DCFS     0x00000000 ; 0
                  |L12.184|
                          DCD      CDC_CsumMah
                  |L12.188|
                          DCD      CDC_DCsumMah

                          AREA ||i.MODS_Load||, CODE, READONLY, ALIGN=2

                  MODS_Load PROC
;;;597    
;;;598    static uint8_t MODS_Load(uint16_t reg_addr, uint16_t reg_value)
000000  b570              PUSH     {r4-r6,lr}
;;;599    {
;;;600    	switch (reg_addr)							
000002  2812              CMP      r0,#0x12
000004  d223              BCS      |L13.78|
000006  e8dff000          TBB      [pc,r0]
00000a  0920              DCB      0x09,0x20
00000c  20202020          DCB      0x20,0x20,0x20,0x20
000010  20202020          DCB      0x20,0x20,0x20,0x20
000014  20202020          DCB      0x20,0x20,0x20,0x20
000018  20202020          DCB      0x20,0x20,0x20,0x20
00001c  2400              MOVS     r4,#0
;;;601    	{	
;;;602    		case SLAVE_REG_P00://寮濮姝㈣杞?
;;;603    			if(reg_value == 1)//寮濮璐杞?
;;;604    			{
;;;605    				MODE = 0;
00001e  480d              LDR      r0,|L13.84|
;;;606    				MODE_PARASET(MODE);
;;;607    				MODE_ONOFF(1);
;;;608    				rmtrig[0] = 1;
000020  4d0d              LDR      r5,|L13.88|
000022  2901              CMP      r1,#1                 ;603
000024  d002              BEQ      |L13.44|
;;;609    			}else if(reg_value == 4){//姝㈣杞
000026  2904              CMP      r1,#4
000028  d00a              BEQ      |L13.64|
00002a  e00e              B        |L13.74|
                  |L13.44|
00002c  7004              STRB     r4,[r0,#0]            ;605
00002e  7800              LDRB     r0,[r0,#0]            ;606  ; MODE
000030  f7fffffe          BL       MODE_PARASET
000034  2001              MOVS     r0,#1                 ;607
000036  f7fffffe          BL       MODE_ONOFF
00003a  2001              MOVS     r0,#1                 ;608
00003c  7028              STRB     r0,[r5,#0]            ;608
00003e  e004              B        |L13.74|
                  |L13.64|
;;;610    				MODE = 0;
000040  7004              STRB     r4,[r0,#0]
;;;611    				MODE_ONOFF(0);
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       MODE_ONOFF
;;;612    				rmtrig[0] = 0;
000048  702c              STRB     r4,[r5,#0]
                  |L13.74|
;;;613    			}
;;;614    			break;
;;;615    		case SLAVE_REG_P01://
;;;616    
;;;617    			break;
;;;618    		
;;;619    		case SLAVE_REG_P02://
;;;620    
;;;621    			break;
;;;622    		case SLAVE_REG_P03://
;;;623    
;;;624    			break;
;;;625    
;;;626    		case SLAVE_REG_P04://
;;;627    
;;;628    			break;
;;;629    		case SLAVE_REG_P05://
;;;630    
;;;631    			break;
;;;632    
;;;633    		case SLAVE_REG_P06://
;;;634    
;;;635    			break;
;;;636    		case SLAVE_REG_P07://
;;;637    
;;;638    			break;
;;;639    		case SLAVE_REG_P08://
;;;640    
;;;641    			break;
;;;642    		case SLAVE_REG_P09:	//
;;;643    
;;;644    			break;
;;;645    		case SLAVE_REG_P10:	//
;;;646    
;;;647    			break;
;;;648    
;;;649    		case SLAVE_REG_P11://
;;;650    
;;;651    			break;
;;;652    		case SLAVE_REG_P12:
;;;653    			break;
;;;654    
;;;655    		case SLAVE_REG_P13:
;;;656    			break;
;;;657    		case SLAVE_REG_P14:
;;;658    			break;
;;;659    
;;;660    		case SLAVE_REG_P15:
;;;661    			break;
;;;662    		case SLAVE_REG_P16:
;;;663    			break;
;;;664    
;;;665    		case SLAVE_REG_P17:
;;;666    			break;
;;;667    		default:
;;;668    			return 0;
;;;669    	}
;;;670    
;;;671    	return 1;
00004a  2001              MOVS     r0,#1
;;;672    }
00004c  bd70              POP      {r4-r6,pc}
                  |L13.78|
00004e  2000              MOVS     r0,#0                 ;668
000050  bd70              POP      {r4-r6,pc}
;;;673    
                          ENDP

000052  0000              DCW      0x0000
                  |L13.84|
                          DCD      MODE
                  |L13.88|
                          DCD      ||.data||+0x3

                          AREA ||i.MODS_Pow||, CODE, READONLY, ALIGN=2

                  MODS_Pow PROC
;;;673    
;;;674    static uint8_t MODS_Pow(uint16_t reg_addr, uint16_t reg_value)
000000  b570              PUSH     {r4-r6,lr}
;;;675    {
;;;676    
;;;677    	switch (reg_addr)							
000002  2812              CMP      r0,#0x12
000004  d225              BCS      |L14.82|
000006  e8dff000          TBB      [pc,r0]
00000a  0922              DCB      0x09,0x22
00000c  22222222          DCB      0x22,0x22,0x22,0x22
000010  22222222          DCB      0x22,0x22,0x22,0x22
000014  22222222          DCB      0x22,0x22,0x22,0x22
000018  22222222          DCB      0x22,0x22,0x22,0x22
00001c  2401              MOVS     r4,#1                 ;675
;;;678    	{	
;;;679    		case SLAVE_REG_P00://寮濮姝㈢垫?
;;;680    			if(reg_value == 1)//寮濮垫?
;;;681    			{
;;;682    				MODE = 1;
00001e  480e              LDR      r0,|L14.88|
;;;683    				Para.CSET_Voltage = Para.POWER_OutPut_V;
;;;684    				Para.CSET_Current = Para.POWER_Limit_C;
;;;685    				mainswitch = 1;
000020  4a0e              LDR      r2,|L14.92|
;;;686    				MODE_ONOFF(1);
;;;687    				rmtrig[1] = 1;
000022  4d0f              LDR      r5,|L14.96|
000024  2901              CMP      r1,#1                 ;680
000026  d002              BEQ      |L14.46|
;;;688    					
;;;689    			}else if(reg_value == 4){//姝㈢垫
000028  2904              CMP      r1,#4
00002a  d009              BEQ      |L14.64|
00002c  e00f              B        |L14.78|
                  |L14.46|
00002e  7004              STRB     r4,[r0,#0]            ;682
000030  480c              LDR      r0,|L14.100|
000032  f8b01054          LDRH     r1,[r0,#0x54]         ;683  ; Para
000036  6081              STR      r1,[r0,#8]            ;683  ; Para
000038  f8b01056          LDRH     r1,[r0,#0x56]         ;684  ; Para
00003c  60c1              STR      r1,[r0,#0xc]          ;684  ; Para
00003e  e001              B        |L14.68|
                  |L14.64|
;;;690    				MODE = 1;
000040  7004              STRB     r4,[r0,#0]
;;;691    				mainswitch = 0;
000042  2400              MOVS     r4,#0
                  |L14.68|
000044  7014              STRB     r4,[r2,#0]
;;;692    				MODE_ONOFF(1);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       MODE_ONOFF
;;;693    				rmtrig[1] = 0;
00004c  706c              STRB     r4,[r5,#1]
                  |L14.78|
;;;694    			}
;;;695    			break;
;;;696    		case SLAVE_REG_P01://
;;;697    
;;;698    			break;
;;;699    		
;;;700    		case SLAVE_REG_P02://
;;;701    
;;;702    			break;
;;;703    		case SLAVE_REG_P03://
;;;704    
;;;705    			break;
;;;706    
;;;707    		case SLAVE_REG_P04://
;;;708    
;;;709    			break;
;;;710    		case SLAVE_REG_P05://
;;;711    
;;;712    			break;
;;;713    
;;;714    		case SLAVE_REG_P06://
;;;715    
;;;716    			break;
;;;717    		case SLAVE_REG_P07://
;;;718    
;;;719    			break;
;;;720    		case SLAVE_REG_P08://
;;;721    
;;;722    			break;
;;;723    		case SLAVE_REG_P09:	//
;;;724    
;;;725    			break;
;;;726    		case SLAVE_REG_P10:	//
;;;727    
;;;728    			break;
;;;729    
;;;730    		case SLAVE_REG_P11://
;;;731    
;;;732    			break;
;;;733    		case SLAVE_REG_P12:
;;;734    			break;
;;;735    
;;;736    		case SLAVE_REG_P13:
;;;737    			break;
;;;738    		case SLAVE_REG_P14:
;;;739    			break;
;;;740    
;;;741    		case SLAVE_REG_P15:
;;;742    			break;
;;;743    		case SLAVE_REG_P16:
;;;744    			break;
;;;745    
;;;746    		case SLAVE_REG_P17:
;;;747    			break;
;;;748    		default:
;;;749    			return 0;
;;;750    	}
;;;751    
;;;752    	return 1;
00004e  2001              MOVS     r0,#1
;;;753    }
000050  bd70              POP      {r4-r6,pc}
                  |L14.82|
000052  2000              MOVS     r0,#0                 ;749
000054  bd70              POP      {r4-r6,pc}
;;;754    
                          ENDP

000056  0000              DCW      0x0000
                  |L14.88|
                          DCD      MODE
                  |L14.92|
                          DCD      mainswitch
                  |L14.96|
                          DCD      ||.data||+0x3
                  |L14.100|
                          DCD      Para

                          AREA ||i.MODS_ReadRegValue||, CODE, READONLY, ALIGN=2

                  MODS_ReadRegValue PROC
;;;414    */
;;;415    static uint8_t MODS_ReadRegValue(uint16_t reg_addr, uint8_t *reg_value)
000000  b570              PUSH     {r4-r6,lr}
;;;416    {
;;;417        uint16_t value;
;;;418    	switch (reg_addr)									/* 判断寄存器地址 */
;;;419    	{
;;;420            case SLAVE_REG_P00:
;;;421    //			C_SW(1);
;;;422    			v= DISS_Voltage;
000002  4a32              LDR      r2,|L15.204|
000004  460d              MOV      r5,r1                 ;416
000006  ed2d8b02          VPUSH    {d8}                  ;416
00000a  2813              CMP      r0,#0x13              ;418
00000c  4930              LDR      r1,|L15.208|
;;;423    			value =	Para.CR_VLUE;	
00000e  4c31              LDR      r4,|L15.212|
;;;424    			break;
;;;425    		case SLAVE_REG_P01:
;;;426                shortv = DISS_Voltage;
;;;427    			value =	Para.CVoltage;	
;;;428    			break;
;;;429    
;;;430    		case SLAVE_REG_P02:
;;;431    			value =	(int)(DISS_Current*1000);       /* 将寄存器值读出 */
000010  ed9f8a31          VLDR     s16,|L15.216|
000014  ed920a00          VLDR     s0,[r2,#0]            ;422
000018  d256              BCS      |L15.200|
00001a  e8dff000          TBB      [pc,r0]               ;418
00001e  0a0e              DCB      0x0a,0x0e
000020  13151d1f          DCB      0x13,0x15,0x1d,0x1f
000024  36383a3c          DCB      0x36,0x38,0x3a,0x3c
000028  3a363636          DCB      0x3a,0x36,0x36,0x36
00002c  3e444749          DCB      0x3e,0x44,0x47,0x49
000030  4c00              DCB      0x4c,0x00
000032  ed810a02          VSTR     s0,[r1,#8]            ;422
000036  6ba0              LDR      r0,[r4,#0x38]         ;423  ; Para
000038  e002              B        |L15.64|
00003a  ed810a03          VSTR     s0,[r1,#0xc]          ;426
00003e  6ae0              LDR      r0,[r4,#0x2c]         ;427  ; Para
                  |L15.64|
000040  b280              UXTH     r0,r0                 ;423
000042  e03a              B        |L15.186|
000044  4825              LDR      r0,|L15.220|
;;;432    			break;
000046  e017              B        |L15.120|
;;;433    		case SLAVE_REG_P03: 
;;;434    			value =	(int)(DISS_POW_Voltage*100);
000048  4825              LDR      r0,|L15.224|
00004a  eddf0a26          VLDR     s1,|L15.228|
00004e  ed900a00          VLDR     s0,[r0,#0]
000052  ee200a20          VMUL.F32 s0,s0,s1
;;;435    			break;
000056  e013              B        |L15.128|
;;;436    
;;;437    		case SLAVE_REG_P04:
;;;438    			value =	(int)(DISS_POW_Current*1000);		/* 将寄存器值读出 */
000058  4823              LDR      r0,|L15.232|
;;;439    			break;
00005a  e00d              B        |L15.120|
;;;440    		case SLAVE_REG_P05:
;;;441    			Off_GPOI_ResetSet();
00005c  f7fffffe          BL       Off_GPOI_ResetSet
;;;442                Para.CSET_Current_Laod = 0;
000060  2000              MOVS     r0,#0
000062  6160              STR      r0,[r4,#0x14]  ; Para
;;;443    			Para.IR_Step_C = 10;
000064  200a              MOVS     r0,#0xa
000066  f8a40048          STRH     r0,[r4,#0x48]
;;;444    			MODE = 2;
00006a  4920              LDR      r1,|L15.236|
00006c  2002              MOVS     r0,#2
00006e  7008              STRB     r0,[r1,#0]
;;;445    			MODE_ONOFF(1);
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       MODE_ONOFF
;;;446    //            while(usartocflag == 1);
;;;447                value = (int)(max_discahrgeNum*1000);
000076  481e              LDR      r0,|L15.240|
                  |L15.120|
000078  ed900a00          VLDR     s0,[r0,#0]
00007c  ee200a08          VMUL.F32 s0,s0,s16
                  |L15.128|
000080  eebd0ac0          VCVT.S32.F32 s0,s0
000084  ee100a10          VMOV     r0,s0
000088  e7da              B        |L15.64|
;;;448    			break;
;;;449    		case SLAVE_REG_P06:
;;;450    			value = 0;							/* 将寄存器值读出 */
00008a  2000              MOVS     r0,#0
;;;451    			break;
00008c  e015              B        |L15.186|
;;;452    		case SLAVE_REG_P07:
;;;453    			value =	Para.CR1_VLUE;							/* 将寄存器值读出 */
00008e  6be0              LDR      r0,[r4,#0x3c]  ; Para
;;;454    			break;
000090  e7d6              B        |L15.64|
;;;455    		case SLAVE_REG_P08:
;;;456    			value =	8;	
000092  2008              MOVS     r0,#8
;;;457    			break;
000094  e011              B        |L15.186|
;;;458    
;;;459    		case SLAVE_REG_P09:
;;;460    			value =	Para.CR2_VLUE;							/* 将寄存器值读出 */
000096  6c20              LDR      r0,[r4,#0x40]  ; Para
;;;461    			break;
000098  e7d2              B        |L15.64|
;;;462    		case SLAVE_REG_P10:
;;;463    			value =	8;	
;;;464    			break;
;;;465    
;;;466    		case SLAVE_REG_P11:
;;;467    			value =	0;							/* 将寄存器值读出 */
;;;468    			break;
;;;469    		case SLAVE_REG_P12:
;;;470    			value =	0;	
;;;471    			break;
;;;472    
;;;473    		case SLAVE_REG_P13:
;;;474    			value =	0;							/* 将寄存器值读出 */
;;;475    			break;
;;;476    		case SLAVE_REG_P14:
;;;477    			value =	!flag_Load_CC;	
00009a  4816              LDR      r0,|L15.244|
00009c  7800              LDRB     r0,[r0,#0]  ; flagD
00009e  f34010c0          SBFX     r0,r0,#7,#1
0000a2  1c40              ADDS     r0,r0,#1
;;;478    			break;
0000a4  e009              B        |L15.186|
;;;479    
;;;480    		case SLAVE_REG_P15:
;;;481    			value =	Para.LOAD_V;							/* 将寄存器值读出 */
0000a6  f8b40060          LDRH     r0,[r4,#0x60]  ; Para
;;;482    			break;
0000aa  e006              B        |L15.186|
;;;483    		case SLAVE_REG_P16:
;;;484    			value =	Para.LOAD_C;
0000ac  6de0              LDR      r0,[r4,#0x5c]  ; Para
;;;485    			break;
0000ae  e7c7              B        |L15.64|
;;;486    
;;;487    		case SLAVE_REG_P17:
;;;488    			value =	Para.POWER_OutPut_V;							/* 将寄存器值读出 */
0000b0  f8b40054          LDRH     r0,[r4,#0x54]  ; Para
;;;489    			break;
0000b4  e001              B        |L15.186|
;;;490    		case SLAVE_REG_P18:
;;;491    			value =	Para.POWER_Limit_C;							/* 将寄存器值读出 */
0000b6  f8b40056          LDRH     r0,[r4,#0x56]  ; Para
                  |L15.186|
;;;492    			break;	
;;;493    		default:
;;;494    			return 0;
;;;495        }
;;;496    	reg_value[0] = value >> 8;
0000ba  0a01              LSRS     r1,r0,#8
0000bc  7029              STRB     r1,[r5,#0]
;;;497    	reg_value[1] = value;
0000be  7068              STRB     r0,[r5,#1]
;;;498    
;;;499    	return 1;											/* 读取成功 */
0000c0  2001              MOVS     r0,#1
                  |L15.194|
;;;500    }
0000c2  ecbd8b02          VPOP     {d8}
0000c6  bd70              POP      {r4-r6,pc}
                  |L15.200|
0000c8  2000              MOVS     r0,#0                 ;494
0000ca  e7fa              B        |L15.194|
;;;501    
                          ENDP

                  |L15.204|
                          DCD      DISS_Voltage
                  |L15.208|
                          DCD      ||.data||
                  |L15.212|
                          DCD      Para
                  |L15.216|
0000d8  447a0000          DCFS     0x447a0000 ; 1000
                  |L15.220|
                          DCD      DISS_Current
                  |L15.224|
                          DCD      DISS_POW_Voltage
                  |L15.228|
0000e4  42c80000          DCFS     0x42c80000 ; 100
                  |L15.232|
                          DCD      DISS_POW_Current
                  |L15.236|
                          DCD      MODE
                  |L15.240|
                          DCD      max_discahrgeNum
                  |L15.244|
                          DCD      flagD

                          AREA ||i.MODS_SendAckErr||, CODE, READONLY, ALIGN=2

                  MODS_SendAckErr PROC
;;;207    */
;;;208    static void MODS_SendAckErr(uint8_t _ucErrCode)
000000  4908              LDR      r1,|L16.36|
;;;209    {
000002  b508              PUSH     {r3,lr}
;;;210    	uint8_t txbuf[3];
;;;211    
;;;212    	txbuf[0] = g_tModS.RxBuf[0];					/* 485地址 */
000004  780a              LDRB     r2,[r1,#0]  ; g_tModS
000006  f88d2000          STRB     r2,[sp,#0]
;;;213    	txbuf[1] = g_tModS.RxBuf[1] | 0x80;				/* 异常的功能码 */
00000a  7849              LDRB     r1,[r1,#1]  ; g_tModS
00000c  f0410180          ORR      r1,r1,#0x80
000010  f88d1001          STRB     r1,[sp,#1]
;;;214    	txbuf[2] = _ucErrCode;							/* 错误代码(01,02,03,04) */
000014  f88d0002          STRB     r0,[sp,#2]
;;;215    
;;;216    	MODS_SendWithCRC(txbuf, 3);
000018  2103              MOVS     r1,#3
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       MODS_SendWithCRC
;;;217    }
000020  bd08              POP      {r3,pc}
;;;218    
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      ||.bss||

                          AREA ||i.MODS_SendAckOk||, CODE, READONLY, ALIGN=2

                  MODS_SendAckOk PROC
;;;227    */
;;;228    static void MODS_SendAckOk(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;229    {
;;;230    	uint8_t txbuf[6];
;;;231    	uint8_t i;
;;;232    
;;;233    	for (i = 0; i < 6; i++)
;;;234    	{
;;;235    		txbuf[i] = g_tModS.RxBuf[i];
000002  4907              LDR      r1,|L17.32|
000004  2000              MOVS     r0,#0                 ;233
000006  466a              MOV      r2,sp                 ;230
                  |L17.8|
000008  5c0b              LDRB     r3,[r1,r0]
00000a  5413              STRB     r3,[r2,r0]
00000c  1c40              ADDS     r0,r0,#1
00000e  b2c0              UXTB     r0,r0                 ;233
000010  2806              CMP      r0,#6                 ;233
000012  d3f9              BCC      |L17.8|
;;;236    	}
;;;237    	MODS_SendWithCRC(txbuf, 6);
000014  2106              MOVS     r1,#6
000016  4610              MOV      r0,r2
000018  f7fffffe          BL       MODS_SendWithCRC
;;;238    }
00001c  bd1c              POP      {r2-r4,pc}
;;;239    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      ||.bss||

                          AREA ||i.MODS_SendWithCRC||, CODE, READONLY, ALIGN=2

                  MODS_SendWithCRC PROC
;;;904    
;;;905    void MODS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;906    {
000002  460c              MOV      r4,r1
;;;907    	uint16_t crc;
;;;908    	uint8_t i;
;;;909    	uint8_t buf[S_TX_BUF_SIZE];
;;;910    	memcpy(buf, _pBuf, _ucLen);
000004  460a              MOV      r2,r1
000006  b0a1              SUB      sp,sp,#0x84           ;906
000008  4605              MOV      r5,r0                 ;906
00000a  4601              MOV      r1,r0
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy
;;;911    	crc = CRC16(_pBuf, _ucLen);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       CRC16
;;;912    	buf[_ucLen++] = crc >> 8;
00001a  0a01              LSRS     r1,r0,#8
00001c  f80d1004          STRB     r1,[sp,r4]
000020  1c64              ADDS     r4,r4,#1
000022  b2e1              UXTB     r1,r4
000024  466e              MOV      r6,sp
;;;913    	buf[_ucLen++] = crc;
000026  f80d0001          STRB     r0,[sp,r1]
00002a  1c49              ADDS     r1,r1,#1
00002c  b2cd              UXTB     r5,r1
;;;914    //通过485发数据
;;;915    //	RS485_SendBuf(buf, _ucLen);
;;;916    	for(i=0;i<_ucLen;i++)
00002e  2400              MOVS     r4,#0
;;;917    	{
;;;918    		Usart_SendByte(USART1,buf[i]);
000030  4f05              LDR      r7,|L18.72|
000032  e005              B        |L18.64|
                  |L18.52|
000034  5d31              LDRB     r1,[r6,r4]
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       Usart_SendByte
00003c  1c64              ADDS     r4,r4,#1
00003e  b2e4              UXTB     r4,r4                 ;916
                  |L18.64|
000040  42ac              CMP      r4,r5                 ;916
000042  d3f7              BCC      |L18.52|
;;;919    	}
;;;920    //	uart1SendChars(buf, _ucLen);
;;;921    	
;;;922    // #if 1									/* 此部分为了串口打印结果,实际运用中可不要 */
;;;923    // 	g_tPrint.Txlen = _ucLen;
;;;924    // 	memcpy(g_tPrint.TxBuf, buf, _ucLen);
;;;925    // #endif
;;;926    }
000044  b021              ADD      sp,sp,#0x84
000046  bdf0              POP      {r4-r7,pc}
;;;927    
                          ENDP

                  |L18.72|
                          DCD      0x40011000

                          AREA ||i.MODS_WriteRegValue||, CODE, READONLY, ALIGN=2

                  MODS_WriteRegValue PROC
;;;510    */
;;;511    static uint8_t MODS_WriteRegValue(uint16_t reg_addr, uint16_t reg_value)
000000  b530              PUSH     {r4,r5,lr}
;;;512    {
;;;513    
;;;514    	switch (reg_addr)							/* 判断寄存器地址 */
;;;515    	{	
;;;516    		case SLAVE_REG_P00://璐杞芥ā寮
;;;517    //			if(reg_value == 0)
;;;518    //			{
;;;519    //				LOAD_MODE = 0;
;;;520    //			}else if(reg_value == 1){
;;;521    //				LOAD_MODE = 1;
;;;522    //			}else if(reg_value == 2){
;;;523    //				LOAD_MODE = 2;
;;;524    //			}
;;;525    			Para.CLOAD_MODE=reg_value;
;;;526    			break;
;;;527    		case SLAVE_REG_P01://璐杞界靛
;;;528    			Para.LOAD_V = reg_value;
;;;529    
;;;530    			break;
;;;531    		
;;;532    		case SLAVE_REG_P02://璐杞界垫
;;;533    			Para.LOAD_C = reg_value;
;;;534    			break;
;;;535    		case SLAVE_REG_P03://杈虹靛
;;;536    			Para.POWER_OutPut_V = reg_value*10;
000002  eb010381          ADD      r3,r1,r1,LSL #2
000006  f64f74ff          MOV      r4,#0xffff
00000a  ea040343          AND      r3,r4,r3,LSL #1
;;;537    			break;
;;;538    
;;;539    		case SLAVE_REG_P04://剁垫
;;;540    			Para.POWER_Limit_C = reg_value;
;;;541    
;;;542    			break;
;;;543    		case SLAVE_REG_P05://剧佃虹靛?
;;;544    			Para.CDC_OutPut_V = reg_value*10;
;;;545    
;;;546    			break;
;;;547    
;;;548    		case SLAVE_REG_P06://鹃剁垫
;;;549    			Para.CDC_Limit_C = reg_value;
;;;550    
;;;551    			break;
;;;552    		case SLAVE_REG_P07://垫姝㈢靛
;;;553    			Para.CDC_Ccutoff_V = reg_value*10;
00000e  eb010481          ADD      r4,r1,r1,LSL #2
000012  4a1a              LDR      r2,|L19.124|
000014  0064              LSLS     r4,r4,#1
000016  2813              CMP      r0,#0x13              ;514
000018  d22d              BCS      |L19.118|
00001a  e8dff000          TBB      [pc,r0]               ;514
00001e  0a0c              DCB      0x0a,0x0c
000020  0f111417          DCB      0x0f,0x11,0x14,0x17
000024  1a1d1f22          DCB      0x1a,0x1d,0x1f,0x22
000028  24262a2a          DCB      0x24,0x26,0x2a,0x2a
00002c  2a2a2a2a          DCB      0x2a,0x2a,0x2a,0x2a
000030  2900              DCB      0x29,0x00
000032  6191              STR      r1,[r2,#0x18]         ;525  ; Para
000034  e01d              B        |L19.114|
000036  f8a21060          STRH     r1,[r2,#0x60]         ;528
00003a  e01a              B        |L19.114|
00003c  65d1              STR      r1,[r2,#0x5c]         ;533  ; Para
00003e  e018              B        |L19.114|
000040  f8a23054          STRH     r3,[r2,#0x54]         ;536
000044  e015              B        |L19.114|
000046  f8a21056          STRH     r1,[r2,#0x56]         ;540
00004a  e012              B        |L19.114|
00004c  f8a2306a          STRH     r3,[r2,#0x6a]         ;544
000050  e00f              B        |L19.114|
000052  f8a2106c          STRH     r1,[r2,#0x6c]         ;549
000056  e00c              B        |L19.114|
000058  6714              STR      r4,[r2,#0x70]  ; Para
;;;554    			break;
00005a  e00a              B        |L19.114|
;;;555    		case SLAVE_REG_P08://垫姝㈢垫
;;;556    			Para.CDC_Ccutoff_C = reg_value;
00005c  f8a21074          STRH     r1,[r2,#0x74]
;;;557    
;;;558    			break;
000060  e007              B        |L19.114|
;;;559    		case SLAVE_REG_P09:	//剧佃杞界垫?
;;;560    			Para.CDC_Load_C = reg_value;
000062  6791              STR      r1,[r2,#0x78]  ; Para
;;;561    
;;;562    			break;
000064  e005              B        |L19.114|
;;;563    		case SLAVE_REG_P10:	//剧垫姝㈢靛
;;;564    			Para.CDC_Dcutoff_V = reg_value;
000066  67d1              STR      r1,[r2,#0x7c]  ; Para
;;;565    
;;;566    			break;
000068  e003              B        |L19.114|
;;;567    
;;;568    		case SLAVE_REG_P11://寰娆℃
;;;569    			Para.CDC_Cycle_Time = reg_value;
00006a  f8821080          STRB     r1,[r2,#0x80]
;;;570    
;;;571    			break;
00006e  e000              B        |L19.114|
;;;572    		case SLAVE_REG_P12:
;;;573    //			Para.LOAD_P = reg_value * 10;
;;;574    			break;
;;;575    
;;;576    		case SLAVE_REG_P13:
;;;577    			break;
;;;578    		case SLAVE_REG_P14:
;;;579    			break;
;;;580    
;;;581    		case SLAVE_REG_P15:
;;;582    			break;
;;;583    		case SLAVE_REG_P16:
;;;584    			break;
;;;585    
;;;586    		case SLAVE_REG_P17:
;;;587    			break;
;;;588    		case SLAVE_REG_P18:
;;;589    			Para.LOAD_P = reg_value * 10;
000070  6654              STR      r4,[r2,#0x64]  ; Para
                  |L19.114|
;;;590    			break;
;;;591    		default:
;;;592    			return 0;
;;;593    	}
;;;594    
;;;595    	return 1;
000072  2001              MOVS     r0,#1
;;;596    }
000074  bd30              POP      {r4,r5,pc}
                  |L19.118|
000076  2000              MOVS     r0,#0                 ;592
000078  bd30              POP      {r4,r5,pc}
;;;597    
                          ENDP

00007a  0000              DCW      0x0000
                  |L19.124|
                          DCD      Para

                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
                  |L20.0|
;;;104      */
;;;105    void MemManage_Handler(void)
000000  e7fe              B        |L20.0|
;;;106    {
;;;107      /* Go to infinite loop when Memory Manage exception occurs */
;;;108      while (1)
;;;109      {
;;;110      }
;;;111    }
;;;112    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;82       */
;;;83     void NMI_Handler(void)
000000  4770              BX       lr
;;;84     {
;;;85     }
;;;86     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;161      */
;;;162    void PendSV_Handler(void)
000000  4770              BX       lr
;;;163    {
;;;164    }
;;;165    
                          ENDP


                          AREA ||i.RecHandle||, CODE, READONLY, ALIGN=2

                  RecHandle PROC
;;;369    
;;;370    void RecHandle(void)
000000  490d              LDR      r1,|L23.56|
;;;371    {
;;;372        u8 crec[6];
;;;373        u8 *csend;
;;;374        static u8 *sendbuf;
;;;375        u8 sendlen;
;;;376        static u16 recrc;
;;;377        static u16 scrc;
;;;378        u8 i;
;;;379        lockflag = 1;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;380        switch(g_tModS.RxBuf[1])
000006  480d              LDR      r0,|L23.60|
000008  7840              LDRB     r0,[r0,#1]  ; g_tModS
00000a  2850              CMP      r0,#0x50
00000c  d00e              BEQ      |L23.44|
00000e  dc05              BGT      |L23.28|
000010  2803              CMP      r0,#3
000012  d009              BEQ      |L23.40|
000014  2806              CMP      r0,#6
000016  d10d              BNE      |L23.52|
;;;381        {
;;;382            case 0x03:
;;;383            {
;;;384                MODS_03H();
;;;385            }break;
;;;386            case 0x06:
;;;387            {
;;;388                MODS_06H();
000018  f7ffbffe          B.W      MODS_06H
                  |L23.28|
00001c  2851              CMP      r0,#0x51              ;380
00001e  d007              BEQ      |L23.48|
000020  2852              CMP      r0,#0x52              ;380
000022  d107              BNE      |L23.52|
;;;389            }break;
;;;390    		case 0x50:
;;;391            {
;;;392                MODS_50H();
;;;393            }break;
;;;394    		case 0x51:
;;;395            {
;;;396                MODS_51H();
;;;397            }break;
;;;398    		case 0x52:
;;;399            {
;;;400                MODS_52H();
000024  f7ffbffe          B.W      MODS_52H
                  |L23.40|
000028  f7ffbffe          B.W      MODS_03H
                  |L23.44|
00002c  f7ffbffe          B.W      MODS_50H
                  |L23.48|
000030  f7ffbffe          B.W      MODS_51H
                  |L23.52|
;;;401            }break;
;;;402            default:break;
;;;403        }
;;;404    }
000034  4770              BX       lr
;;;405    
                          ENDP

000036  0000              DCW      0x0000
                  |L23.56|
                          DCD      lockflag
                  |L23.60|
                          DCD      ||.bss||

                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;143      */
;;;144    void SVC_Handler(void)
000000  4770              BX       lr
;;;145    {
;;;146    }
;;;147    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;170      */
;;;171    void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173    	TimingDelay_Decrement();
000002  f7fffffe          BL       TimingDelay_Decrement
;;;174    	OS_TimeMS++;
000006  4812              LDR      r0,|L25.80|
000008  6801              LDR      r1,[r0,#0]  ; OS_TimeMS
00000a  1c49              ADDS     r1,r1,#1
00000c  6001              STR      r1,[r0,#0]  ; OS_TimeMS
;;;175    //	t_KeyScan++;
;;;176    //	if(t_KeyScan>10)
;;;177    //	{
;;;178    //		t_KeyScan=0;
;;;179    //		Flag_Key_Scan=1;//按键消抖标志
;;;180    //	}
;;;181    	t_0_5S++;
00000e  4811              LDR      r0,|L25.84|
000010  8801              LDRH     r1,[r0,#0]  ; t_0_5S
000012  1c49              ADDS     r1,r1,#1
000014  8001              STRH     r1,[r0,#0]
;;;182    	if(t_0_5S>20)
000016  8801              LDRH     r1,[r0,#0]  ; t_0_5S
000018  2200              MOVS     r2,#0
00001a  2914              CMP      r1,#0x14
00001c  d905              BLS      |L25.42|
;;;183    	{
;;;184    		t_0_5S=0;
00001e  8002              STRH     r2,[r0,#0]
;;;185    		Flag_0_5S =1;//蜂鸣器响一声标志
000020  480d              LDR      r0,|L25.88|
000022  6801              LDR      r1,[r0,#0]  ; flagA
000024  f0410180          ORR      r1,r1,#0x80
000028  6001              STR      r1,[r0,#0]  ; flagA
                  |L25.42|
;;;186    	}
;;;187    //--------------------------------------------
;;;188    	if(flag_Tim_USART==1)//串口清零计数
00002a  4c0c              LDR      r4,|L25.92|
;;;189    	{
;;;190    		t_USART++;
00002c  490c              LDR      r1,|L25.96|
00002e  6820              LDR      r0,[r4,#0]            ;188  ; flagD
000030  07c3              LSLS     r3,r0,#31             ;188
000032  d002              BEQ      |L25.58|
000034  780b              LDRB     r3,[r1,#0]  ; t_USART
000036  1c5b              ADDS     r3,r3,#1
000038  700b              STRB     r3,[r1,#0]
                  |L25.58|
;;;191    	}
;;;192    	if(t_USART>40)//大约2.6ms
00003a  780b              LDRB     r3,[r1,#0]  ; t_USART
00003c  2b28              CMP      r3,#0x28
00003e  d905              BLS      |L25.76|
;;;193    	{
;;;194    		t_USART=0;
000040  700a              STRB     r2,[r1,#0]
;;;195    		flag_Tim_USART=0;
000042  f0200001          BIC      r0,r0,#1
;;;196    		UART_Buffer_Size=0;	
000046  6020              STR      r0,[r4,#0]  ; flagD
000048  4806              LDR      r0,|L25.100|
00004a  7002              STRB     r2,[r0,#0]
                  |L25.76|
;;;197    	}
;;;198    }
00004c  bd10              POP      {r4,pc}
;;;199    
                          ENDP

00004e  0000              DCW      0x0000
                  |L25.80|
                          DCD      OS_TimeMS
                  |L25.84|
                          DCD      t_0_5S
                  |L25.88|
                          DCD      flagA
                  |L25.92|
                          DCD      flagD
                  |L25.96|
                          DCD      t_USART
                  |L25.100|
                          DCD      UART_Buffer_Size

                          AREA ||i.TIM6_DAC_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM6_DAC_IRQHandler PROC
;;;343    
;;;344    void  TIM6_DAC_IRQHandler (void)
000000  2101              MOVS     r1,#1
;;;345    {
;;;346    	TIM_ClearITPendingBit(TIM6,TIM_IT_Update);//?????λ
000002  4801              LDR      r0,|L26.8|
000004  f7ffbffe          B.W      TIM_ClearITPendingBit
;;;347    }
;;;348    
                          ENDP

                  |L26.8|
                          DCD      0x40001000

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;348    
;;;349    void USART1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;350    {
;;;351    //	flag_Tim_USART=1;
;;;352        
;;;353     	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000002  4d13              LDR      r5,|L27.80|
000004  f2405125          MOV      r1,#0x525
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d01c              BEQ      |L27.76|
;;;354    	{
;;;355    		
;;;356            g_mods_timeout = 2;
000012  4810              LDR      r0,|L27.84|
;;;357            if (g_tModS.RxCount < S_RX_BUF_SIZE)
000014  4c10              LDR      r4,|L27.88|
000016  2102              MOVS     r1,#2                 ;356
000018  7001              STRB     r1,[r0,#0]            ;356
00001a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00001e  281e              CMP      r0,#0x1e
000020  d20a              BCS      |L27.56|
;;;358            {
;;;359                g_tModS.RxBuf[g_tModS.RxCount++] = USART_ReceiveData(USART1);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USART_ReceiveData
000028  f894109e          LDRB     r1,[r4,#0x9e]  ; g_tModS
00002c  5460              STRB     r0,[r4,r1]
00002e  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
000032  1c40              ADDS     r0,r0,#1
000034  f884009e          STRB     r0,[r4,#0x9e]
                  |L27.56|
;;;360            }
;;;361    		if(g_tModS.RxCount > 7 && g_tModS.RxBuf[1] == 6)
000038  b2c0              UXTB     r0,r0
00003a  2807              CMP      r0,#7
00003c  d906              BLS      |L27.76|
00003e  7860              LDRB     r0,[r4,#1]  ; g_tModS
000040  2806              CMP      r0,#6
000042  d103              BNE      |L27.76|
;;;362    		{
;;;363    			MODS_SendAckOk();
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      MODS_SendAckOk
                  |L27.76|
;;;364    		}
;;;365    	}
;;;366    }
00004c  bd70              POP      {r4-r6,pc}
;;;367    
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
                          DCD      0x40011000
                  |L27.84|
                          DCD      ||.data||
                  |L27.88|
                          DCD      ||.bss||

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
                  |L28.0|
;;;130      */
;;;131    void UsageFault_Handler(void)
000000  e7fe              B        |L28.0|
;;;132    {
;;;133      /* Go to infinite loop when Usage Fault exception occurs */
;;;134      while (1)
;;;135      {
;;;136      }
;;;137    }
;;;138    
                          ENDP


                          AREA ||i.Usart_SendByte||, CODE, READONLY, ALIGN=1

                  Usart_SendByte PROC
;;;255    /*****************  发送一个字符 **********************/
;;;256    void Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)
000000  b510              PUSH     {r4,lr}
;;;257    {
000002  4604              MOV      r4,r0
;;;258    	/* 发送一个字节数据到USART */
;;;259    	USART_SendData(pUSARTx,ch);
000004  f7fffffe          BL       USART_SendData
                  |L29.8|
;;;260    		
;;;261    	/* 等待发送数据寄存器为空 */
;;;262    	while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);	
000008  2180              MOVS     r1,#0x80
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_GetFlagStatus
000010  2800              CMP      r0,#0
000012  d0f9              BEQ      |L29.8|
;;;263    }
000014  bd10              POP      {r4,pc}
;;;264    
                          ENDP


                          AREA ||i.uart1SendChars||, CODE, READONLY, ALIGN=2

                  uart1SendChars PROC
;;;264    
;;;265    void uart1SendChars(u8 *str, u16 strlen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;266    { 
;;;267    	  u16 k= 0 ; 
;;;268       do { 
;;;269           USART_SendData(USART1,*(str + k));
000004  4f09              LDR      r7,|L30.44|
000006  460d              MOV      r5,r1                 ;266
000008  4606              MOV      r6,r0                 ;266
00000a  2400              MOVS     r4,#0                 ;267
                  |L30.12|
00000c  4638              MOV      r0,r7
00000e  5d31              LDRB     r1,[r6,r4]
000010  f7fffffe          BL       USART_SendData
                  |L30.20|
;;;270           while (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);
000014  2180              MOVS     r1,#0x80
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L30.20|
000020  1c64              ADDS     r4,r4,#1
;;;271           k++; 
000022  b2a4              UXTH     r4,r4
;;;272           }   //循环发送,直到发送完毕   
;;;273        while (k < strlen); 
000024  42ac              CMP      r4,r5
000026  d3f1              BCC      |L30.12|
;;;274    } 
000028  e8bd81f0          POP      {r4-r8,pc}
;;;275    
                          ENDP

                  |L30.44|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_tModS
                          %        163

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  s_CRCHi
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  s_CRCLo
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  g_mods_timeout
000000  00                DCB      0x00
                  sendmodeflag
000001  00                DCB      0x00
                  mode_sw
000002  00                DCB      0x00
                  rmtrig
000003  00                DCB      0x00
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  v
                          DCD      0x00000000
                  shortv
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\User\\stm32f4xx_it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_e289a1ee____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_stm32f4xx_it_c_e289a1ee____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_e289a1ee____REVSH|
#line 144
|__asm___14_stm32f4xx_it_c_e289a1ee____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
