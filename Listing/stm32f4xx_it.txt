; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_it.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_it.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=538 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_it.crf --no_multibyte_chars ..\User\stm32f4xx_it.c]
                          THUMB

                          AREA ||i.BEBufToUint16||, CODE, READONLY, ALIGN=1

                  BEBufToUint16 PROC
;;;251    */
;;;252    uint16_t BEBufToUint16(uint8_t *_pBuf)
000000  8800              LDRH     r0,[r0,#0]
;;;253    {
;;;254        return (((uint16_t)_pBuf[0] << 8) | _pBuf[1]);
000002  ba40              REV16    r0,r0
;;;255    }
000004  4770              BX       lr
;;;256    
                          ENDP


                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
                  |L2.0|
;;;119      */
;;;120    void BusFault_Handler(void)
000000  e7fe              B        |L2.0|
;;;121    {
;;;122      /* Go to infinite loop when Bus Fault exception occurs */
;;;123      while (1)
;;;124      {
;;;125      }
;;;126    }
;;;127    
                          ENDP


                          AREA ||i.CRC16||, CODE, READONLY, ALIGN=2

                  CRC16 PROC
;;;1101   
;;;1102   uint16_t CRC16(uint8_t *_pBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;1103   {    
;;;1104       uint8_t ucCRCHi = 0xFF; /* 高CRC字节初始化 */
;;;1105   	uint8_t ucCRCLo = 0xFF; /* 低CRC 字节初始化 */
;;;1106   	uint16_t usIndex;  /* CRC循环中的索引 */
;;;1107   
;;;1108       while (_usLen--)
;;;1109       {
;;;1110   		usIndex = ucCRCHi ^ *_pBuf++; /* 计算CRC */
;;;1111   		ucCRCHi = ucCRCLo ^ s_CRCHi[usIndex];
000002  4d09              LDR      r5,|L3.40|
000004  22ff              MOVS     r2,#0xff              ;1104
000006  4613              MOV      r3,r2                 ;1105
;;;1112   		ucCRCLo = s_CRCLo[usIndex];
000008  f5057680          ADD      r6,r5,#0x100
00000c  e006              B        |L3.28|
00000e  bf00              NOP                            ;1110
                  |L3.16|
000010  f8104b01          LDRB     r4,[r0],#1            ;1110
000014  4054              EORS     r4,r4,r2              ;1110
000016  5d2a              LDRB     r2,[r5,r4]            ;1111
000018  405a              EORS     r2,r2,r3              ;1111
00001a  5d33              LDRB     r3,[r6,r4]
                  |L3.28|
00001c  1e49              SUBS     r1,r1,#1              ;1108
00001e  b289              UXTH     r1,r1                 ;1108
000020  d2f6              BCS      |L3.16|
;;;1113       }
;;;1114       return ((uint16_t)ucCRCHi << 8 | ucCRCLo);
000022  ea432002          ORR      r0,r3,r2,LSL #8
;;;1115   }
000026  bd70              POP      {r4-r6,pc}
;;;1116   /******************************************************************************/
                          ENDP

                  |L3.40|
                          DCD      ||.constdata||

                          AREA ||i.DMA2_Stream0_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Stream0_IRQHandler PROC
;;;339    
;;;340    void  DMA2_Stream0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;341    {
;;;342    	DMA_ClearITPendingBit(DMA2_Stream0,DMA_IT_TCIF0);
000002  4905              LDR      r1,|L4.24|
000004  4805              LDR      r0,|L4.28|
000006  f7fffffe          BL       DMA_ClearITPendingBit
;;;343    	Flag_ADC_Full=1;
00000a  4805              LDR      r0,|L4.32|
00000c  6801              LDR      r1,[r0,#0]  ; flagA
00000e  f0410102          ORR      r1,r1,#2
000012  6001              STR      r1,[r0,#0]  ; flagA
;;;344    }
000014  bd10              POP      {r4,pc}
;;;345    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x10008020
                  |L4.28|
                          DCD      0x40026410
                  |L4.32|
                          DCD      flagA

                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;154      */
;;;155    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;156    {
;;;157    }
;;;158    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L6.0|
;;;93       */
;;;94     void HardFault_Handler(void)
000000  e7fe              B        |L6.0|
;;;95     {
;;;96       /* Go to infinite loop when Hard Fault exception occurs */
;;;97       while (1)
;;;98       {
;;;99       }
;;;100    }
;;;101    
                          ENDP


                          AREA ||i.MODS_03H||, CODE, READONLY, ALIGN=2

                  MODS_03H PROC
;;;860    
;;;861    static void MODS_03H(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;862    {
;;;863        uint16_t reg;
;;;864    	uint16_t num;
;;;865    	uint16_t i;
;;;866    	uint8_t reg_value[64];
;;;867    
;;;868        
;;;869        g_tModS.RspCode = RSP_OK;
000004  4c2d              LDR      r4,|L7.188|
000006  b091              SUB      sp,sp,#0x44           ;862
000008  f04f0a00          MOV      r10,#0
00000c  f884a0a1          STRB     r10,[r4,#0xa1]
;;;870    
;;;871    	if (g_tModS.RxCount != 8)								/* 03H命令必须是8个字节 */
000010  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
;;;872    	{
;;;873    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000014  2603              MOVS     r6,#3
000016  2808              CMP      r0,#8                 ;871
000018  d106              BNE      |L7.40|
;;;874    		goto err_ret;
;;;875    	}
;;;876    
;;;877    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 				/* 寄存器号 */
00001a  8860              LDRH     r0,[r4,#2]  ; g_tModS
00001c  fa90f890          REV16    r8,r0
;;;878    	num = BEBufToUint16(&g_tModS.RxBuf[4]);					/* 寄存器个数 */
000020  88a0              LDRH     r0,[r4,#4]  ; g_tModS
000022  ba45              REV16    r5,r0
;;;879    	if (num > sizeof(reg_value) / 2)
000024  2d20              CMP      r5,#0x20
000026  d904              BLS      |L7.50|
                  |L7.40|
;;;880    	{
;;;881    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000028  f88460a1          STRB     r6,[r4,#0xa1]
                  |L7.44|
;;;882    		goto err_ret;
;;;883    	}
;;;884    
;;;885    	for (i = 0; i < num; i++)
;;;886    	{
;;;887    		if (MODS_ReadRegValue(reg, &reg_value[2 * i]) == 0)	/* 读出寄存器值放入reg_value */
;;;888    		{
;;;889    			g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
;;;890    			break;
;;;891    		}
;;;892    		reg++;
;;;893    	}
;;;894    
;;;895    err_ret:
;;;896    	if (g_tModS.RspCode == RSP_OK)							/* 正确应答 */
;;;897    	{
;;;898    		g_tModS.TxCount = 0;
;;;899    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
;;;900    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
;;;901    		g_tModS.TxBuf[g_tModS.TxCount++] = num * 2;			/* 返回字节数 */
;;;902    
;;;903    		for (i = 0; i < num; i++)
;;;904    		{
;;;905    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i];
;;;906    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i+1];
;;;907    		}
;;;908    //         if(usartocflag == 0)
;;;909    //         {
;;;910    //             MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);	/* 发送正确应答 */
;;;911    //         }
;;;912    	}
;;;913    	else
;;;914    	{
;;;915    //		MODS_SendAckErr(g_tModS.RspCode);					/* 发送错误应答 */
;;;916    	}
;;;917        
;;;918    }
00002c  b011              ADD      sp,sp,#0x44
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L7.50|
000032  2700              MOVS     r7,#0                 ;885
000034  f04f0b02          MOV      r11,#2                ;889
000038  46e9              MOV      r9,sp                 ;866
00003a  e00b              B        |L7.84|
                  |L7.60|
00003c  eb090147          ADD      r1,r9,r7,LSL #1       ;887
000040  4640              MOV      r0,r8                 ;887
000042  f7fffffe          BL       MODS_ReadRegValue
000046  b1d8              CBZ      r0,|L7.128|
000048  f1080001          ADD      r0,r8,#1              ;892
00004c  1c7f              ADDS     r7,r7,#1              ;892
00004e  fa1ff880          UXTH     r8,r0                 ;892
000052  b2bf              UXTH     r7,r7                 ;885
                  |L7.84|
000054  42af              CMP      r7,r5                 ;885
000056  d3f1              BCC      |L7.60|
000058  f89400a1          LDRB     r0,[r4,#0xa1]         ;896  ; g_tModS
00005c  2800              CMP      r0,#0                 ;896
00005e  d1e5              BNE      |L7.44|
000060  4916              LDR      r1,|L7.188|
000062  7822              LDRB     r2,[r4,#0]            ;899  ; g_tModS
000064  311e              ADDS     r1,r1,#0x1e           ;899
000066  2001              MOVS     r0,#1                 ;899
000068  f80a2001          STRB     r2,[r10,r1]           ;899
00006c  7862              LDRB     r2,[r4,#1]            ;900  ; g_tModS
00006e  5442              STRB     r2,[r0,r1]            ;900
000070  006a              LSLS     r2,r5,#1              ;901
000072  f80b2001          STRB     r2,[r11,r1]           ;901
000076  f88460a2          STRB     r6,[r4,#0xa2]         ;901
00007a  2000              MOVS     r0,#0                 ;903
00007c  464a              MOV      r2,r9                 ;866
00007e  e019              B        |L7.180|
                  |L7.128|
000080  f884b0a1          STRB     r11,[r4,#0xa1]        ;889
000084  e7d2              B        |L7.44|
000086  bf00              NOP                            ;905
                  |L7.136|
000088  f89460a2          LDRB     r6,[r4,#0xa2]         ;905  ; g_tModS
00008c  f8123010          LDRB     r3,[r2,r0,LSL #1]     ;905
000090  5473              STRB     r3,[r6,r1]            ;905
000092  f89430a2          LDRB     r3,[r4,#0xa2]         ;905  ; g_tModS
000096  eb020640          ADD      r6,r2,r0,LSL #1       ;906
00009a  1c5b              ADDS     r3,r3,#1              ;905
00009c  b2db              UXTB     r3,r3                 ;905
00009e  f88430a2          STRB     r3,[r4,#0xa2]         ;905
0000a2  7876              LDRB     r6,[r6,#1]            ;906
0000a4  545e              STRB     r6,[r3,r1]            ;906
0000a6  f89430a2          LDRB     r3,[r4,#0xa2]         ;906  ; g_tModS
0000aa  1c5b              ADDS     r3,r3,#1              ;906
0000ac  1c40              ADDS     r0,r0,#1              ;906
0000ae  f88430a2          STRB     r3,[r4,#0xa2]         ;906
0000b2  b280              UXTH     r0,r0                 ;903
                  |L7.180|
0000b4  42a8              CMP      r0,r5                 ;903
0000b6  d3e7              BCC      |L7.136|
0000b8  e7b8              B        |L7.44|
;;;919    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L7.188|
                          DCD      ||.bss||

                          AREA ||i.MODS_06H||, CODE, READONLY, ALIGN=2

                  MODS_06H PROC
;;;943    
;;;944    static void MODS_06H(void)
000000  b510              PUSH     {r4,lr}
;;;945    {
;;;946        uint16_t reg;
;;;947    	uint16_t value;
;;;948    
;;;949    	g_tModS.RspCode = RSP_OK;
000002  4c10              LDR      r4,|L8.68|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;950    
;;;951    	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L8.22|
;;;952    	{
;;;953    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000012  2003              MOVS     r0,#3
;;;954    		goto err_ret;
000014  e008              B        |L8.40|
                  |L8.22|
;;;955    	}
;;;956    
;;;957    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
000016  8860              LDRH     r0,[r4,#2]  ; g_tModS
;;;958    	value = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 寄存器值 */
000018  88a1              LDRH     r1,[r4,#4]  ; g_tModS
00001a  ba40              REV16    r0,r0                 ;957
00001c  ba49              REV16    r1,r1
;;;959        
;;;960    //    if(reg == 0x0E)
;;;961    //    {
;;;962    //        if(value == 00)
;;;963    //        {
;;;964    //            GPIO_SetBits(GPIOC,GPIO_Pin_10);//CC
;;;965    //            flag_Load_CC = 1;
;;;966    //        }else if(value == 01){
;;;967    //            GPIO_ResetBits(GPIOC,GPIO_Pin_10);//CV
;;;968    //            flag_Load_CC = 0;
;;;969    //        }
;;;970    //    }
;;;971     	if (MODS_WriteRegValue(reg, value) == 1)	/* 该函数会把写入的值存入寄存器 */
00001e  f7fffffe          BL       MODS_WriteRegValue
000022  2801              CMP      r0,#1
000024  d003              BEQ      |L8.46|
;;;972     	{
;;;973     		;
;;;974     	}
;;;975     	else
;;;976     	{
;;;977     		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
000026  2002              MOVS     r0,#2
                  |L8.40|
000028  f88400a1          STRB     r0,[r4,#0xa1]         ;953
00002c  e003              B        |L8.54|
                  |L8.46|
;;;978     	}
;;;979    
;;;980    err_ret:
;;;981    	if (g_tModS.RspCode == RSP_OK)				/* 正确应答 */
00002e  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
000032  2800              CMP      r0,#0
000034  d004              BEQ      |L8.64|
                  |L8.54|
;;;982    	{
;;;983    		
;;;984    	}
;;;985    	else
;;;986    	{
;;;987    		MODS_SendAckErr(g_tModS.RspCode);		/* 告诉主机命令错误 */
000036  e8bd4010          POP      {r4,lr}
00003a  b2c0              UXTB     r0,r0
00003c  f7ffbffe          B.W      MODS_SendAckErr
                  |L8.64|
;;;988    	}
;;;989    }
000040  bd10              POP      {r4,pc}
;;;990    
                          ENDP

000042  0000              DCW      0x0000
                  |L8.68|
                          DCD      ||.bss||

                          AREA ||i.MODS_50H||, CODE, READONLY, ALIGN=2

                  MODS_50H PROC
;;;990    
;;;991    static void MODS_50H(void)
000000  b510              PUSH     {r4,lr}
;;;992    {
;;;993        uint16_t reg;
;;;994    	uint16_t value;
;;;995    
;;;996    	g_tModS.RspCode = RSP_OK;
000002  4c11              LDR      r4,|L9.72|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;997    
;;;998    	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L9.22|
;;;999    	{
;;;1000   		g_tModS.RspCode = RSP_ERR_VALUE;		
000012  2003              MOVS     r0,#3
;;;1001   		goto err_ret;
000014  e008              B        |L9.40|
                  |L9.22|
;;;1002   	}
;;;1003   
;;;1004   	reg = BEBufToUint16(&g_tModS.RxBuf[2]);
000016  8860              LDRH     r0,[r4,#2]  ; g_tModS
;;;1005   	value = BEBufToUint16(&g_tModS.RxBuf[4]);
000018  88a1              LDRH     r1,[r4,#4]  ; g_tModS
00001a  ba40              REV16    r0,r0                 ;1004
00001c  ba49              REV16    r1,r1
;;;1006       
;;;1007   
;;;1008    	if (MODS_Load(reg, value) == 1)
00001e  f7fffffe          BL       MODS_Load
000022  2801              CMP      r0,#1
000024  d003              BEQ      |L9.46|
;;;1009    	{
;;;1010    		;
;;;1011    	}
;;;1012    	else
;;;1013    	{
;;;1014    		g_tModS.RspCode = RSP_ERR_REG_ADDR;
000026  2002              MOVS     r0,#2
                  |L9.40|
000028  f88400a1          STRB     r0,[r4,#0xa1]         ;1000
00002c  e002              B        |L9.52|
                  |L9.46|
;;;1015    	}
;;;1016   
;;;1017   err_ret:
;;;1018   	if (g_tModS.RspCode == RSP_OK)
00002e  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
000032  b120              CBZ      r0,|L9.62|
                  |L9.52|
;;;1019   	{
;;;1020   		MODS_SendAckOk();
;;;1021   	}
;;;1022   	else
;;;1023   	{
;;;1024   		MODS_SendAckErr(g_tModS.RspCode);
000034  e8bd4010          POP      {r4,lr}
000038  b2c0              UXTB     r0,r0
00003a  f7ffbffe          B.W      MODS_SendAckErr
                  |L9.62|
00003e  e8bd4010          POP      {r4,lr}               ;1020
000042  f7ffbffe          B.W      MODS_SendAckOk
;;;1025   	}
;;;1026   }
;;;1027   
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      ||.bss||

                          AREA ||i.MODS_51H||, CODE, READONLY, ALIGN=2

                  MODS_51H PROC
;;;1027   
;;;1028   static void MODS_51H(void)
000000  b510              PUSH     {r4,lr}
;;;1029   {
;;;1030       uint16_t reg;
;;;1031   	uint16_t value;
;;;1032   
;;;1033   	g_tModS.RspCode = RSP_OK;
000002  4c11              LDR      r4,|L10.72|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;1034   
;;;1035   	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L10.22|
;;;1036   	{
;;;1037   		g_tModS.RspCode = RSP_ERR_VALUE;		
000012  2003              MOVS     r0,#3
;;;1038   		goto err_ret;
000014  e008              B        |L10.40|
                  |L10.22|
;;;1039   	}
;;;1040   
;;;1041   	reg = BEBufToUint16(&g_tModS.RxBuf[2]);
000016  8860              LDRH     r0,[r4,#2]  ; g_tModS
;;;1042   	value = BEBufToUint16(&g_tModS.RxBuf[4]);
000018  88a1              LDRH     r1,[r4,#4]  ; g_tModS
00001a  ba40              REV16    r0,r0                 ;1041
00001c  ba49              REV16    r1,r1
;;;1043       
;;;1044   
;;;1045    	if (MODS_Pow(reg, value) == 1)
00001e  f7fffffe          BL       MODS_Pow
000022  2801              CMP      r0,#1
000024  d003              BEQ      |L10.46|
;;;1046    	{
;;;1047    		;
;;;1048    	}
;;;1049    	else
;;;1050    	{
;;;1051    		g_tModS.RspCode = RSP_ERR_REG_ADDR;
000026  2002              MOVS     r0,#2
                  |L10.40|
000028  f88400a1          STRB     r0,[r4,#0xa1]         ;1037
00002c  e002              B        |L10.52|
                  |L10.46|
;;;1052    	}
;;;1053   
;;;1054   err_ret:
;;;1055   	if (g_tModS.RspCode == RSP_OK)
00002e  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
000032  b120              CBZ      r0,|L10.62|
                  |L10.52|
;;;1056   	{
;;;1057   		MODS_SendAckOk();
;;;1058   	}
;;;1059   	else
;;;1060   	{
;;;1061   		MODS_SendAckErr(g_tModS.RspCode);
000034  e8bd4010          POP      {r4,lr}
000038  b2c0              UXTB     r0,r0
00003a  f7ffbffe          B.W      MODS_SendAckErr
                  |L10.62|
00003e  e8bd4010          POP      {r4,lr}               ;1057
000042  f7ffbffe          B.W      MODS_SendAckOk
;;;1062   	}
;;;1063   }
;;;1064   
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      ||.bss||

                          AREA ||i.MODS_52H||, CODE, READONLY, ALIGN=2

                  MODS_52H PROC
;;;1064   
;;;1065   static void MODS_52H(void)
000000  b510              PUSH     {r4,lr}
;;;1066   {
;;;1067       uint16_t reg;
;;;1068   	uint16_t value;
;;;1069   
;;;1070   	g_tModS.RspCode = RSP_OK;
000002  4c11              LDR      r4,|L11.72|
000004  2000              MOVS     r0,#0
000006  f88400a1          STRB     r0,[r4,#0xa1]
;;;1071   
;;;1072   	if (g_tModS.RxCount != 8)
00000a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d001              BEQ      |L11.22|
;;;1073   	{
;;;1074   		g_tModS.RspCode = RSP_ERR_VALUE;		
000012  2003              MOVS     r0,#3
;;;1075   		goto err_ret;
000014  e008              B        |L11.40|
                  |L11.22|
;;;1076   	}
;;;1077   
;;;1078   	reg = BEBufToUint16(&g_tModS.RxBuf[2]);
000016  8860              LDRH     r0,[r4,#2]  ; g_tModS
;;;1079   	value = BEBufToUint16(&g_tModS.RxBuf[4]);
000018  88a1              LDRH     r1,[r4,#4]  ; g_tModS
00001a  ba40              REV16    r0,r0                 ;1078
00001c  ba49              REV16    r1,r1
;;;1080       
;;;1081   
;;;1082    	if (MODS_CDC(reg, value) == 1)
00001e  f7fffffe          BL       MODS_CDC
000022  2801              CMP      r0,#1
000024  d003              BEQ      |L11.46|
;;;1083    	{
;;;1084   		
;;;1085    	}
;;;1086    	else
;;;1087    	{
;;;1088    		g_tModS.RspCode = RSP_ERR_REG_ADDR;
000026  2002              MOVS     r0,#2
                  |L11.40|
000028  f88400a1          STRB     r0,[r4,#0xa1]         ;1074
00002c  e002              B        |L11.52|
                  |L11.46|
;;;1089    	}
;;;1090   
;;;1091   err_ret:
;;;1092   	if (g_tModS.RspCode == RSP_OK)
00002e  f89400a1          LDRB     r0,[r4,#0xa1]  ; g_tModS
000032  b120              CBZ      r0,|L11.62|
                  |L11.52|
;;;1093   	{
;;;1094   		MODS_SendAckOk();
;;;1095   	}
;;;1096   	else
;;;1097   	{
;;;1098   		MODS_SendAckErr(g_tModS.RspCode);
000034  e8bd4010          POP      {r4,lr}
000038  b2c0              UXTB     r0,r0
00003a  f7ffbffe          B.W      MODS_SendAckErr
                  |L11.62|
00003e  e8bd4010          POP      {r4,lr}               ;1094
000042  f7ffbffe          B.W      MODS_SendAckOk
;;;1099   	}
;;;1100   }
;;;1101   
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
                          DCD      ||.bss||

                          AREA ||i.MODS_CDC||, CODE, READONLY, ALIGN=2

                  MODS_CDC PROC
;;;766    
;;;767    static uint8_t MODS_CDC(uint16_t reg_addr, uint16_t reg_value)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;768    {
;;;769    
;;;770    	switch (reg_addr)							
000004  2812              CMP      r0,#0x12
000006  d24e              BCS      |L12.166|
000008  e8dff000          TBB      [pc,r0]
00000c  094a4a4a          DCB      0x09,0x4a,0x4a,0x4a
000010  4a4a4a4a          DCB      0x4a,0x4a,0x4a,0x4a
000014  4a4a4a4a          DCB      0x4a,0x4a,0x4a,0x4a
000018  4a4a4a4a          DCB      0x4a,0x4a,0x4a,0x4a
00001c  4a4a              DCB      0x4a,0x4a
00001e  2400              MOVS     r4,#0
000020  2501              MOVS     r5,#1                 ;768
;;;771    	{	
;;;772    		case SLAVE_REG_P00://寮濮姝㈢垫?
;;;773    			if(reg_value == 1)//寮濮垫?
;;;774    			{
;;;775    				MODE = 5;
;;;776    //				GPIO_SetBits(GPIOE,GPIO_Pin_2);
;;;777    				Para.CSET_Voltage = Para.CDC_OutPut_V;
;;;778    				Para.CSET_Current = Para.CDC_Limit_C;
;;;779    				Para.CSET_Current_Laod = Para.CDC_Load_C;
;;;780    				mainswitch = 1;
000022  4e22              LDR      r6,|L12.172|
;;;781    				listsend = 1;
000024  4f22              LDR      r7,|L12.176|
;;;782    //			    GPIO_SetBits(GPIOC,GPIO_Pin_1);
;;;783    				rmtrig[2] = 1;
000026  f8df808c          LDR      r8,|L12.180|
;;;784    				mode_sw = 0;
;;;785    				sendmodeflag = 1;
;;;786    				charge_step = 1;
;;;787    				loop = 1;
;;;788    				ctime = 0;
00002a  f8df908c          LDR      r9,|L12.184|
;;;789    				dctime = 0;
00002e  f8dfa08c          LDR      r10,|L12.188|
000032  2901              CMP      r1,#1                 ;773
000034  d002              BEQ      |L12.60|
;;;790    				cdcswdelay = 5000;
;;;791    			}else if(reg_value == 4){//姝㈢垫
000036  2904              CMP      r1,#4
000038  d020              BEQ      |L12.124|
00003a  e031              B        |L12.160|
                  |L12.60|
00003c  4920              LDR      r1,|L12.192|
00003e  2005              MOVS     r0,#5                 ;775
000040  7008              STRB     r0,[r1,#0]            ;775
000042  4820              LDR      r0,|L12.196|
000044  6ec1              LDR      r1,[r0,#0x6c]         ;777  ; Para
000046  6081              STR      r1,[r0,#8]            ;777  ; Para
000048  f8b01070          LDRH     r1,[r0,#0x70]         ;778  ; Para
00004c  60c1              STR      r1,[r0,#0xc]          ;778  ; Para
00004e  6fc1              LDR      r1,[r0,#0x7c]         ;779  ; Para
000050  6141              STR      r1,[r0,#0x14]         ;779  ; Para
000052  7035              STRB     r5,[r6,#0]            ;780
000054  703d              STRB     r5,[r7,#0]            ;781
000056  4817              LDR      r0,|L12.180|
000058  f8885002          STRB     r5,[r8,#2]            ;783
00005c  1ec0              SUBS     r0,r0,#3              ;784
00005e  7084              STRB     r4,[r0,#2]            ;784
000060  7045              STRB     r5,[r0,#1]            ;785
000062  4819              LDR      r0,|L12.200|
000064  7005              STRB     r5,[r0,#0]            ;786
000066  4819              LDR      r0,|L12.204|
000068  7005              STRB     r5,[r0,#0]            ;787
00006a  f8c94000          STR      r4,[r9,#0]            ;788  ; ctime
00006e  f8ca4000          STR      r4,[r10,#0]           ;789  ; dctime
000072  4917              LDR      r1,|L12.208|
000074  f2413088          MOV      r0,#0x1388            ;790
000078  8008              STRH     r0,[r1,#0]            ;790
00007a  e011              B        |L12.160|
                  |L12.124|
;;;792    				Off_GPOI_ResetSet();
00007c  f7fffffe          BL       Off_GPOI_ResetSet
;;;793    				mainswitch = 0;
000080  7034              STRB     r4,[r6,#0]
;;;794    				listsend = 1;
000082  703d              STRB     r5,[r7,#0]
;;;795    			    rmtrig[2] = 0;
;;;796    				CDC_CsumMah = 0;
000084  4814              LDR      r0,|L12.216|
000086  ed9f0a13          VLDR     s0,|L12.212|
00008a  f8884002          STRB     r4,[r8,#2]            ;795
00008e  ed800a00          VSTR     s0,[r0,#0]
;;;797    				CDC_DCsumMah = 0;
000092  4812              LDR      r0,|L12.220|
000094  ed800a00          VSTR     s0,[r0,#0]
;;;798    				ctime = 0;
000098  f8c94000          STR      r4,[r9,#0]  ; ctime
;;;799    				dctime = 0;
00009c  f8ca4000          STR      r4,[r10,#0]  ; dctime
                  |L12.160|
;;;800    			}
;;;801    			break;
;;;802    		case SLAVE_REG_P01://
;;;803    
;;;804    			break;
;;;805    		
;;;806    		case SLAVE_REG_P02://
;;;807    
;;;808    			break;
;;;809    		case SLAVE_REG_P03://
;;;810    
;;;811    			break;
;;;812    
;;;813    		case SLAVE_REG_P04://
;;;814    
;;;815    			break;
;;;816    		case SLAVE_REG_P05://
;;;817    
;;;818    			break;
;;;819    
;;;820    		case SLAVE_REG_P06://
;;;821    
;;;822    			break;
;;;823    		case SLAVE_REG_P07://
;;;824    
;;;825    			break;
;;;826    		case SLAVE_REG_P08://
;;;827    
;;;828    			break;
;;;829    		case SLAVE_REG_P09:	//
;;;830    
;;;831    			break;
;;;832    		case SLAVE_REG_P10:	//
;;;833    
;;;834    			break;
;;;835    
;;;836    		case SLAVE_REG_P11://
;;;837    
;;;838    			break;
;;;839    		case SLAVE_REG_P12:
;;;840    			break;
;;;841    
;;;842    		case SLAVE_REG_P13:
;;;843    			break;
;;;844    		case SLAVE_REG_P14:
;;;845    			break;
;;;846    
;;;847    		case SLAVE_REG_P15:
;;;848    			break;
;;;849    		case SLAVE_REG_P16:
;;;850    			break;
;;;851    
;;;852    		case SLAVE_REG_P17:
;;;853    			break;
;;;854    		default:
;;;855    			return 0;
;;;856    	}
;;;857    
;;;858    	return 1;
0000a0  2001              MOVS     r0,#1
                  |L12.162|
;;;859    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
                  |L12.166|
0000a6  2000              MOVS     r0,#0                 ;855
0000a8  e7fb              B        |L12.162|
;;;860    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L12.172|
                          DCD      mainswitch
                  |L12.176|
                          DCD      listsend
                  |L12.180|
                          DCD      ||.data||+0x3
                  |L12.184|
                          DCD      ctime
                  |L12.188|
                          DCD      dctime
                  |L12.192|
                          DCD      MODE
                  |L12.196|
                          DCD      Para
                  |L12.200|
                          DCD      charge_step
                  |L12.204|
                          DCD      loop
                  |L12.208|
                          DCD      cdcswdelay
                  |L12.212|
0000d4  00000000          DCFS     0x00000000 ; 0
                  |L12.216|
                          DCD      CDC_CsumMah
                  |L12.220|
                          DCD      CDC_DCsumMah

                          AREA ||i.MODS_Load||, CODE, READONLY, ALIGN=2

                  MODS_Load PROC
;;;607    
;;;608    static uint8_t MODS_Load(uint16_t reg_addr, uint16_t reg_value)
000000  b570              PUSH     {r4-r6,lr}
;;;609    {
;;;610    	switch (reg_addr)							
000002  2812              CMP      r0,#0x12
000004  d226              BCS      |L13.84|
000006  e8dff000          TBB      [pc,r0]
00000a  0923              DCB      0x09,0x23
00000c  23232323          DCB      0x23,0x23,0x23,0x23
000010  23232323          DCB      0x23,0x23,0x23,0x23
000014  23232323          DCB      0x23,0x23,0x23,0x23
000018  23232323          DCB      0x23,0x23,0x23,0x23
00001c  2400              MOVS     r4,#0
;;;611    	{	
;;;612    		case SLAVE_REG_P00://寮濮姝㈣杞?
;;;613    			if(reg_value == 1)//寮濮璐杞?
;;;614    			{
;;;615    				MODE = 0;
00001e  480e              LDR      r0,|L13.88|
;;;616    				MODE_PARASET(MODE);
;;;617    				MODE_ONOFF(1);
;;;618    				mainswitch = 1;
000020  4d0e              LDR      r5,|L13.92|
;;;619    				rmtrig[0] = 1;
000022  4e0f              LDR      r6,|L13.96|
000024  2901              CMP      r1,#1                 ;613
000026  d002              BEQ      |L13.46|
;;;620    			}else if(reg_value == 4){//姝㈣杞
000028  2904              CMP      r1,#4
00002a  d00b              BEQ      |L13.68|
00002c  e010              B        |L13.80|
                  |L13.46|
00002e  7004              STRB     r4,[r0,#0]            ;615
000030  7800              LDRB     r0,[r0,#0]            ;616  ; MODE
000032  f7fffffe          BL       MODE_PARASET
000036  2001              MOVS     r0,#1                 ;617
000038  f7fffffe          BL       MODE_ONOFF
00003c  2001              MOVS     r0,#1                 ;618
00003e  7028              STRB     r0,[r5,#0]            ;618
000040  7030              STRB     r0,[r6,#0]            ;619
000042  e005              B        |L13.80|
                  |L13.68|
;;;621    				MODE = 0;
000044  7004              STRB     r4,[r0,#0]
;;;622    				MODE_ONOFF(0);
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       MODE_ONOFF
;;;623    				mainswitch = 0;
00004c  702c              STRB     r4,[r5,#0]
;;;624    				rmtrig[0] = 0;
00004e  7034              STRB     r4,[r6,#0]
                  |L13.80|
;;;625    			}
;;;626    			break;
;;;627    		case SLAVE_REG_P01://
;;;628    
;;;629    			break;
;;;630    		
;;;631    		case SLAVE_REG_P02://
;;;632    
;;;633    			break;
;;;634    		case SLAVE_REG_P03://
;;;635    
;;;636    			break;
;;;637    
;;;638    		case SLAVE_REG_P04://
;;;639    
;;;640    			break;
;;;641    		case SLAVE_REG_P05://
;;;642    
;;;643    			break;
;;;644    
;;;645    		case SLAVE_REG_P06://
;;;646    
;;;647    			break;
;;;648    		case SLAVE_REG_P07://
;;;649    
;;;650    			break;
;;;651    		case SLAVE_REG_P08://
;;;652    
;;;653    			break;
;;;654    		case SLAVE_REG_P09:	//
;;;655    
;;;656    			break;
;;;657    		case SLAVE_REG_P10:	//
;;;658    
;;;659    			break;
;;;660    
;;;661    		case SLAVE_REG_P11://
;;;662    
;;;663    			break;
;;;664    		case SLAVE_REG_P12:
;;;665    			break;
;;;666    
;;;667    		case SLAVE_REG_P13:
;;;668    			break;
;;;669    		case SLAVE_REG_P14:
;;;670    			break;
;;;671    
;;;672    		case SLAVE_REG_P15:
;;;673    			break;
;;;674    		case SLAVE_REG_P16:
;;;675    			break;
;;;676    
;;;677    		case SLAVE_REG_P17:
;;;678    			break;
;;;679    		default:
;;;680    			return 0;
;;;681    	}
;;;682    
;;;683    	return 1;
000050  2001              MOVS     r0,#1
;;;684    }
000052  bd70              POP      {r4-r6,pc}
                  |L13.84|
000054  2000              MOVS     r0,#0                 ;680
000056  bd70              POP      {r4-r6,pc}
;;;685    
                          ENDP

                  |L13.88|
                          DCD      MODE
                  |L13.92|
                          DCD      mainswitch
                  |L13.96|
                          DCD      ||.data||+0x3

                          AREA ||i.MODS_Pow||, CODE, READONLY, ALIGN=2

                  MODS_Pow PROC
;;;685    
;;;686    static uint8_t MODS_Pow(uint16_t reg_addr, uint16_t reg_value)
000000  b570              PUSH     {r4-r6,lr}
;;;687    {
;;;688    
;;;689    	switch (reg_addr)							
000002  2812              CMP      r0,#0x12
000004  d224              BCS      |L14.80|
000006  e8dff000          TBB      [pc,r0]
00000a  0921              DCB      0x09,0x21
00000c  21212121          DCB      0x21,0x21,0x21,0x21
000010  21212121          DCB      0x21,0x21,0x21,0x21
000014  21212121          DCB      0x21,0x21,0x21,0x21
000018  21212121          DCB      0x21,0x21,0x21,0x21
00001c  2401              MOVS     r4,#1                 ;687
;;;690    	{	
;;;691    		case SLAVE_REG_P00://寮濮姝㈢垫?
;;;692    			if(reg_value == 1)//寮濮垫?
;;;693    			{
;;;694    				MODE = 1;
00001e  480d              LDR      r0,|L14.84|
;;;695    				Para.CSET_Voltage = Para.POWER_OutPut_V;
;;;696    				Para.CSET_Current = Para.POWER_Limit_C;
;;;697    				mainswitch = 1;
000020  4a0d              LDR      r2,|L14.88|
;;;698    				MODE_ONOFF(1);
;;;699    				rmtrig[1] = 1;
000022  4d0e              LDR      r5,|L14.92|
000024  2901              CMP      r1,#1                 ;692
000026  d002              BEQ      |L14.46|
;;;700    					
;;;701    			}else if(reg_value == 4){//姝㈢垫
000028  2904              CMP      r1,#4
00002a  d008              BEQ      |L14.62|
00002c  e00e              B        |L14.76|
                  |L14.46|
00002e  7004              STRB     r4,[r0,#0]            ;694
000030  480b              LDR      r0,|L14.96|
000032  6d41              LDR      r1,[r0,#0x54]         ;695  ; Para
000034  6081              STR      r1,[r0,#8]            ;695  ; Para
000036  f8b01058          LDRH     r1,[r0,#0x58]         ;696  ; Para
00003a  60c1              STR      r1,[r0,#0xc]          ;696  ; Para
00003c  e001              B        |L14.66|
                  |L14.62|
;;;702    				MODE = 1;
00003e  7004              STRB     r4,[r0,#0]
;;;703    				mainswitch = 0;
000040  2400              MOVS     r4,#0
                  |L14.66|
000042  7014              STRB     r4,[r2,#0]
;;;704    				MODE_ONOFF(1);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       MODE_ONOFF
;;;705    				rmtrig[1] = 0;
00004a  706c              STRB     r4,[r5,#1]
                  |L14.76|
;;;706    			}
;;;707    			break;
;;;708    		case SLAVE_REG_P01://
;;;709    
;;;710    			break;
;;;711    		
;;;712    		case SLAVE_REG_P02://
;;;713    
;;;714    			break;
;;;715    		case SLAVE_REG_P03://
;;;716    
;;;717    			break;
;;;718    
;;;719    		case SLAVE_REG_P04://
;;;720    
;;;721    			break;
;;;722    		case SLAVE_REG_P05://
;;;723    
;;;724    			break;
;;;725    
;;;726    		case SLAVE_REG_P06://
;;;727    
;;;728    			break;
;;;729    		case SLAVE_REG_P07://
;;;730    
;;;731    			break;
;;;732    		case SLAVE_REG_P08://
;;;733    
;;;734    			break;
;;;735    		case SLAVE_REG_P09:	//
;;;736    
;;;737    			break;
;;;738    		case SLAVE_REG_P10:	//
;;;739    
;;;740    			break;
;;;741    
;;;742    		case SLAVE_REG_P11://
;;;743    
;;;744    			break;
;;;745    		case SLAVE_REG_P12:
;;;746    			break;
;;;747    
;;;748    		case SLAVE_REG_P13:
;;;749    			break;
;;;750    		case SLAVE_REG_P14:
;;;751    			break;
;;;752    
;;;753    		case SLAVE_REG_P15:
;;;754    			break;
;;;755    		case SLAVE_REG_P16:
;;;756    			break;
;;;757    
;;;758    		case SLAVE_REG_P17:
;;;759    			break;
;;;760    		default:
;;;761    			return 0;
;;;762    	}
;;;763    
;;;764    	return 1;
00004c  2001              MOVS     r0,#1
;;;765    }
00004e  bd70              POP      {r4-r6,pc}
                  |L14.80|
000050  2000              MOVS     r0,#0                 ;761
000052  bd70              POP      {r4-r6,pc}
;;;766    
                          ENDP

                  |L14.84|
                          DCD      MODE
                  |L14.88|
                          DCD      mainswitch
                  |L14.92|
                          DCD      ||.data||+0x3
                  |L14.96|
                          DCD      Para

                          AREA ||i.MODS_ReadRegValue||, CODE, READONLY, ALIGN=2

                  MODS_ReadRegValue PROC
;;;416    */
;;;417    static uint8_t MODS_ReadRegValue(uint16_t reg_addr, uint8_t *reg_value)
000000  b570              PUSH     {r4-r6,lr}
;;;418    {
;;;419        uint16_t value;
;;;420    	switch (reg_addr)									/* 判断寄存器地址 */
;;;421    	{
;;;422            case SLAVE_REG_P00:
;;;423    //			C_SW(1);
;;;424    			v= DISS_Voltage;
000002  4a31              LDR      r2,|L15.200|
000004  460d              MOV      r5,r1                 ;418
000006  ed2d8b02          VPUSH    {d8}                  ;418
00000a  2813              CMP      r0,#0x13              ;420
00000c  492f              LDR      r1,|L15.204|
;;;425    			value =	Para.CR_VLUE;	
00000e  4c30              LDR      r4,|L15.208|
;;;426    			break;
;;;427    		case SLAVE_REG_P01:
;;;428                shortv = DISS_Voltage;
;;;429    			value =	Para.CVoltage;	
;;;430    			break;
;;;431    
;;;432    		case SLAVE_REG_P02:
;;;433    			value =	(int)(DISS_Current*1000);       /* 将寄存器值读出 */
000010  ed9f8a30          VLDR     s16,|L15.212|
000014  ed920a00          VLDR     s0,[r2,#0]            ;424
000018  d253              BCS      |L15.194|
00001a  e8dff000          TBB      [pc,r0]               ;420
00001e  0a0e              DCB      0x0a,0x0e
000020  13151d1f          DCB      0x13,0x15,0x1d,0x1f
000024  393b3d3f          DCB      0x39,0x3b,0x3d,0x3f
000028  3d393939          DCB      0x3d,0x39,0x39,0x39
00002c  41434547          DCB      0x41,0x43,0x45,0x47
000030  4900              DCB      0x49,0x00
000032  ed810a02          VSTR     s0,[r1,#8]            ;424
000036  6ba0              LDR      r0,[r4,#0x38]         ;425  ; Para
000038  e002              B        |L15.64|
00003a  ed810a03          VSTR     s0,[r1,#0xc]          ;428
00003e  6ae0              LDR      r0,[r4,#0x2c]         ;429  ; Para
                  |L15.64|
000040  b280              UXTH     r0,r0                 ;425
000042  e037              B        |L15.180|
000044  4824              LDR      r0,|L15.216|
;;;434    			break;
000046  e01a              B        |L15.126|
;;;435    		case SLAVE_REG_P03: 
;;;436    			value =	(int)(DISS_POW_Voltage*100);
000048  4824              LDR      r0,|L15.220|
00004a  eddf0a25          VLDR     s1,|L15.224|
00004e  ed900a00          VLDR     s0,[r0,#0]
000052  ee200a20          VMUL.F32 s0,s0,s1
;;;437    			break;
000056  e016              B        |L15.134|
;;;438    
;;;439    		case SLAVE_REG_P04:
;;;440    			value =	(int)(DISS_POW_Current*1000);		/* 将寄存器值读出 */
000058  4822              LDR      r0,|L15.228|
;;;441    			break;
00005a  e010              B        |L15.126|
;;;442    		case SLAVE_REG_P05:
;;;443    			Off_GPOI_ResetSet();
00005c  f7fffffe          BL       Off_GPOI_ResetSet
;;;444                Para.CSET_Current_Laod = 0;
000060  2000              MOVS     r0,#0
000062  6160              STR      r0,[r4,#0x14]  ; Para
;;;445    			Para.IR_Step_C = 10;
000064  200a              MOVS     r0,#0xa
000066  f8a40048          STRH     r0,[r4,#0x48]
;;;446    			mainswitch=1;
00006a  491f              LDR      r1,|L15.232|
00006c  2001              MOVS     r0,#1
00006e  7008              STRB     r0,[r1,#0]
;;;447    			MODE = 2;
000070  491e              LDR      r1,|L15.236|
000072  2002              MOVS     r0,#2
000074  7008              STRB     r0,[r1,#0]
;;;448    			MODE_ONOFF(1);
000076  2001              MOVS     r0,#1
000078  f7fffffe          BL       MODE_ONOFF
;;;449    //            while(usartocflag == 1);
;;;450                value = (int)(max_discahrgeNum*1000);
00007c  481c              LDR      r0,|L15.240|
                  |L15.126|
00007e  ed900a00          VLDR     s0,[r0,#0]
000082  ee200a08          VMUL.F32 s0,s0,s16
                  |L15.134|
000086  eebd0ac0          VCVT.S32.F32 s0,s0
00008a  ee100a10          VMOV     r0,s0
00008e  e7d7              B        |L15.64|
;;;451    			break;
;;;452    		case SLAVE_REG_P06:
;;;453    			value = 0;							/* 将寄存器值读出 */
000090  2000              MOVS     r0,#0
;;;454    			break;
000092  e00f              B        |L15.180|
;;;455    		case SLAVE_REG_P07:
;;;456    			value =	Para.CR1_VLUE;							/* 将寄存器值读出 */
000094  6be0              LDR      r0,[r4,#0x3c]  ; Para
;;;457    			break;
000096  e7d3              B        |L15.64|
;;;458    		case SLAVE_REG_P08:
;;;459    			value =	8;	
000098  2008              MOVS     r0,#8
;;;460    			break;
00009a  e00b              B        |L15.180|
;;;461    
;;;462    		case SLAVE_REG_P09:
;;;463    			value =	Para.CR2_VLUE;							/* 将寄存器值读出 */
00009c  6c20              LDR      r0,[r4,#0x40]  ; Para
;;;464    			break;
00009e  e7cf              B        |L15.64|
;;;465    		case SLAVE_REG_P10:
;;;466    			value =	8;	
;;;467    			break;
;;;468    
;;;469    		case SLAVE_REG_P11:
;;;470    			value =	0;							/* 将寄存器值读出 */
;;;471    			break;
;;;472    		case SLAVE_REG_P12:
;;;473    			value =	0;	
;;;474    			break;
;;;475    
;;;476    		case SLAVE_REG_P13:
;;;477    			value =	0;							/* 将寄存器值读出 */
;;;478    			break;
;;;479    		case SLAVE_REG_P14:
;;;480    			value =	Para.CLOAD_MODE;	
0000a0  69a0              LDR      r0,[r4,#0x18]  ; Para
;;;481    			break;
0000a2  e7cd              B        |L15.64|
;;;482    
;;;483    		case SLAVE_REG_P15:
;;;484    			value =	Para.LOAD_V;							/* 将寄存器值读出 */
0000a4  6e20              LDR      r0,[r4,#0x60]  ; Para
;;;485    			break;
0000a6  e7cb              B        |L15.64|
;;;486    		case SLAVE_REG_P16:
;;;487    			value =	Para.LOAD_C;
0000a8  6de0              LDR      r0,[r4,#0x5c]  ; Para
;;;488    			break;
0000aa  e7c9              B        |L15.64|
;;;489    
;;;490    		case SLAVE_REG_P17:
;;;491    			value =	Para.POWER_OutPut_V;							/* 将寄存器值读出 */
0000ac  6d60              LDR      r0,[r4,#0x54]  ; Para
;;;492    			break;
0000ae  e7c7              B        |L15.64|
;;;493    		case SLAVE_REG_P18:
;;;494    			value =	Para.POWER_Limit_C;							/* 将寄存器值读出 */
0000b0  f8b40058          LDRH     r0,[r4,#0x58]  ; Para
                  |L15.180|
;;;495    			break;	
;;;496    		default:
;;;497    			return 0;
;;;498        }
;;;499    	reg_value[0] = value >> 8;
0000b4  0a01              LSRS     r1,r0,#8
0000b6  7029              STRB     r1,[r5,#0]
;;;500    	reg_value[1] = value;
0000b8  7068              STRB     r0,[r5,#1]
;;;501    
;;;502    	return 1;											/* 读取成功 */
0000ba  2001              MOVS     r0,#1
                  |L15.188|
;;;503    }
0000bc  ecbd8b02          VPOP     {d8}
0000c0  bd70              POP      {r4-r6,pc}
                  |L15.194|
0000c2  2000              MOVS     r0,#0                 ;497
0000c4  e7fa              B        |L15.188|
;;;504    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L15.200|
                          DCD      DISS_Voltage
                  |L15.204|
                          DCD      ||.data||
                  |L15.208|
                          DCD      Para
                  |L15.212|
0000d4  447a0000          DCFS     0x447a0000 ; 1000
                  |L15.216|
                          DCD      DISS_Current
                  |L15.220|
                          DCD      DISS_POW_Voltage
                  |L15.224|
0000e0  42c80000          DCFS     0x42c80000 ; 100
                  |L15.228|
                          DCD      DISS_POW_Current
                  |L15.232|
                          DCD      mainswitch
                  |L15.236|
                          DCD      MODE
                  |L15.240|
                          DCD      max_discahrgeNum

                          AREA ||i.MODS_SendAckErr||, CODE, READONLY, ALIGN=2

                  MODS_SendAckErr PROC
;;;209    */
;;;210    static void MODS_SendAckErr(uint8_t _ucErrCode)
000000  4908              LDR      r1,|L16.36|
;;;211    {
000002  b508              PUSH     {r3,lr}
;;;212    	uint8_t txbuf[3];
;;;213    
;;;214    	txbuf[0] = g_tModS.RxBuf[0];					/* 485地址 */
000004  780a              LDRB     r2,[r1,#0]  ; g_tModS
000006  f88d2000          STRB     r2,[sp,#0]
;;;215    	txbuf[1] = g_tModS.RxBuf[1] | 0x80;				/* 异常的功能码 */
00000a  7849              LDRB     r1,[r1,#1]  ; g_tModS
00000c  f0410180          ORR      r1,r1,#0x80
000010  f88d1001          STRB     r1,[sp,#1]
;;;216    	txbuf[2] = _ucErrCode;							/* 错误代码(01,02,03,04) */
000014  f88d0002          STRB     r0,[sp,#2]
;;;217    
;;;218    	MODS_SendWithCRC(txbuf, 3);
000018  2103              MOVS     r1,#3
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       MODS_SendWithCRC
;;;219    }
000020  bd08              POP      {r3,pc}
;;;220    
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      ||.bss||

                          AREA ||i.MODS_SendAckOk||, CODE, READONLY, ALIGN=2

                  MODS_SendAckOk PROC
;;;229    */
;;;230    static void MODS_SendAckOk(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;231    {
;;;232    	uint8_t txbuf[6];
;;;233    	uint8_t i;
;;;234    
;;;235    	for (i = 0; i < 6; i++)
;;;236    	{
;;;237    		txbuf[i] = g_tModS.RxBuf[i];
000002  4a07              LDR      r2,|L17.32|
000004  2000              MOVS     r0,#0                 ;235
000006  4669              MOV      r1,sp                 ;232
                  |L17.8|
000008  5c13              LDRB     r3,[r2,r0]
00000a  540b              STRB     r3,[r1,r0]
00000c  1c40              ADDS     r0,r0,#1
00000e  b2c0              UXTB     r0,r0                 ;235
000010  2806              CMP      r0,#6                 ;235
000012  d3f9              BCC      |L17.8|
;;;238    	}
;;;239    	MODS_SendWithCRC(txbuf, 6);
000014  2106              MOVS     r1,#6
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       MODS_SendWithCRC
;;;240    }
00001c  bd1c              POP      {r2-r4,pc}
;;;241    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      ||.bss||

                          AREA ||i.MODS_SendWithCRC||, CODE, READONLY, ALIGN=2

                  MODS_SendWithCRC PROC
;;;920    
;;;921    void MODS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;922    {
000002  460c              MOV      r4,r1
;;;923    	uint16_t crc;
;;;924    	uint8_t i;
;;;925    	uint8_t buf[S_TX_BUF_SIZE];
;;;926    	memcpy(buf, _pBuf, _ucLen);
000004  460a              MOV      r2,r1
000006  b0a1              SUB      sp,sp,#0x84           ;922
000008  4605              MOV      r5,r0                 ;922
00000a  4601              MOV      r1,r0
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy
;;;927    	crc = CRC16(_pBuf, _ucLen);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       CRC16
;;;928    	buf[_ucLen++] = crc >> 8;
00001a  0a01              LSRS     r1,r0,#8
00001c  f80d1004          STRB     r1,[sp,r4]
000020  1c64              ADDS     r4,r4,#1
000022  b2e1              UXTB     r1,r4
000024  466d              MOV      r5,sp
;;;929    	buf[_ucLen++] = crc;
000026  f80d0001          STRB     r0,[sp,r1]
00002a  1c49              ADDS     r1,r1,#1
00002c  b2ce              UXTB     r6,r1
;;;930    //通过485发数据
;;;931    //	RS485_SendBuf(buf, _ucLen);
;;;932    	for(i=0;i<_ucLen;i++)
00002e  2400              MOVS     r4,#0
;;;933    	{
;;;934    		Usart_SendByte(USART1,buf[i]);
000030  4f05              LDR      r7,|L18.72|
000032  e005              B        |L18.64|
                  |L18.52|
000034  5d29              LDRB     r1,[r5,r4]
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       Usart_SendByte
00003c  1c64              ADDS     r4,r4,#1
00003e  b2e4              UXTB     r4,r4                 ;932
                  |L18.64|
000040  42b4              CMP      r4,r6                 ;932
000042  d3f7              BCC      |L18.52|
;;;935    	}
;;;936    //	uart1SendChars(buf, _ucLen);
;;;937    	
;;;938    // #if 1									/* 此部分为了串口打印结果,实际运用中可不要 */
;;;939    // 	g_tPrint.Txlen = _ucLen;
;;;940    // 	memcpy(g_tPrint.TxBuf, buf, _ucLen);
;;;941    // #endif
;;;942    }
000044  b021              ADD      sp,sp,#0x84
000046  bdf0              POP      {r4-r7,pc}
;;;943    
                          ENDP

                  |L18.72|
                          DCD      0x40011000

                          AREA ||i.MODS_WriteRegValue||, CODE, READONLY, ALIGN=2

                  MODS_WriteRegValue PROC
;;;513    */
;;;514    static uint8_t MODS_WriteRegValue(uint16_t reg_addr, uint16_t reg_value)
000000  b530              PUSH     {r4,r5,lr}
;;;515    {
;;;516    
;;;517    	switch (reg_addr)							/* 判断寄存器地址 */
;;;518    	{	
;;;519    		case SLAVE_REG_P00://璐杞芥ā寮
;;;520    //			if(reg_value == 0)
;;;521    //			{
;;;522    //				LOAD_MODE = 0;
;;;523    //			}else if(reg_value == 1){
;;;524    //				LOAD_MODE = 1;
;;;525    //			}else if(reg_value == 2){
;;;526    //				LOAD_MODE = 2;
;;;527    //			}
;;;528    			Para.CLOAD_MODE=reg_value;
;;;529    			break;
;;;530    		case SLAVE_REG_P01://璐杞界靛
;;;531    			Para.LOAD_V = reg_value;
;;;532    
;;;533    			break;
;;;534    		
;;;535    		case SLAVE_REG_P02://璐杞界垫
;;;536    			Para.LOAD_C = reg_value*10;
000002  eb010381          ADD      r3,r1,r1,LSL #2
;;;537    			break;
;;;538    		case SLAVE_REG_P03://杈虹靛
;;;539    			Para.POWER_OutPut_V = reg_value*10;
;;;540    			break;
;;;541    
;;;542    		case SLAVE_REG_P04://剁垫
;;;543    			Para.POWER_Limit_C = reg_value;
;;;544    
;;;545    			break;
;;;546    		case SLAVE_REG_P05://剧佃虹靛?
;;;547    			Para.CDC_OutPut_V = reg_value*10;
;;;548    
;;;549    			break;
;;;550    
;;;551    		case SLAVE_REG_P06://鹃剁垫
;;;552    			Para.CDC_Limit_C = reg_value;
;;;553    
;;;554    			break;
;;;555    		case SLAVE_REG_P07://垫姝㈢靛
;;;556    			Para.CDC_Ccutoff_V = reg_value*10;
;;;557    			break;
;;;558    		case SLAVE_REG_P08://垫姝㈢垫
;;;559    			Para.CDC_Ccutoff_C = reg_value;
;;;560    
;;;561    			break;
;;;562    		case SLAVE_REG_P09:	//剧佃杞界垫?
;;;563    			Para.CDC_Load_C = reg_value*10;
;;;564    
;;;565    			break;
;;;566    		case SLAVE_REG_P10:	//剧垫姝㈢靛
;;;567    			Para.CDC_Dcutoff_V = reg_value;
;;;568    
;;;569    			break;
;;;570    
;;;571    		case SLAVE_REG_P11://寰娆℃
;;;572    			Para.CDC_Cycle_Time = reg_value;
;;;573    
;;;574    			break;
;;;575    		case SLAVE_REG_P12:
;;;576    //			Para.LOAD_P = reg_value * 10;
;;;577    			break;
;;;578    
;;;579    		case SLAVE_REG_P13:
;;;580    			break;
;;;581    		case SLAVE_REG_P14://搁置时间
;;;582    			Para.CDC_Gap_Time = reg_value;
;;;583    			break;
;;;584    
;;;585    		case SLAVE_REG_P15:
;;;586    			break;
;;;587    		case SLAVE_REG_P16:
;;;588    			break;
;;;589    
;;;590    		case SLAVE_REG_P17:
;;;591    			break;
;;;592    		case SLAVE_REG_P18:
;;;593    			Para.LOAD_P = reg_value * 10;
;;;594    			break;
;;;595    		case SLAVE_REG_P19:
;;;596    			Para.CaPCTIME = reg_value*6;//转换为s
000006  eb010441          ADD      r4,r1,r1,LSL #1
00000a  4a1e              LDR      r2,|L19.132|
00000c  005b              LSLS     r3,r3,#1              ;536
00000e  0064              LSLS     r4,r4,#1
000010  2815              CMP      r0,#0x15              ;517
000012  d235              BCS      |L19.128|
000014  e8dff000          TBB      [pc,r0]               ;517
000018  0b0d0f11          DCB      0x0b,0x0d,0x0f,0x11
00001c  1316181b          DCB      0x13,0x16,0x18,0x1b
000020  1d202225          DCB      0x1d,0x20,0x22,0x25
000024  32322832          DCB      0x32,0x32,0x28,0x32
000028  32322b2d          DCB      0x32,0x32,0x2b,0x2d
00002c  3000              DCB      0x30,0x00
00002e  6191              STR      r1,[r2,#0x18]         ;528  ; Para
000030  e024              B        |L19.124|
000032  6611              STR      r1,[r2,#0x60]         ;531  ; Para
000034  e022              B        |L19.124|
000036  65d3              STR      r3,[r2,#0x5c]         ;536  ; Para
000038  e020              B        |L19.124|
00003a  6553              STR      r3,[r2,#0x54]         ;539  ; Para
00003c  e01e              B        |L19.124|
00003e  f8a21058          STRH     r1,[r2,#0x58]         ;543
000042  e01b              B        |L19.124|
000044  66d3              STR      r3,[r2,#0x6c]         ;547  ; Para
000046  e019              B        |L19.124|
000048  f8a21070          STRH     r1,[r2,#0x70]         ;552
00004c  e016              B        |L19.124|
00004e  6753              STR      r3,[r2,#0x74]         ;556  ; Para
000050  e014              B        |L19.124|
000052  f8a21078          STRH     r1,[r2,#0x78]         ;559
000056  e011              B        |L19.124|
000058  67d3              STR      r3,[r2,#0x7c]         ;563  ; Para
00005a  e00f              B        |L19.124|
00005c  f8c21080          STR      r1,[r2,#0x80]         ;567  ; Para
000060  e00c              B        |L19.124|
000062  f8821084          STRB     r1,[r2,#0x84]         ;572
000066  e009              B        |L19.124|
000068  f8a21086          STRH     r1,[r2,#0x86]         ;582
00006c  e006              B        |L19.124|
00006e  6653              STR      r3,[r2,#0x64]         ;593  ; Para
000070  e004              B        |L19.124|
000072  f8c240a8          STR      r4,[r2,#0xa8]  ; Para
;;;597    			break;
000076  e001              B        |L19.124|
;;;598    		case SLAVE_REG_P20:
;;;599    			Para.CaPDCTIME = reg_value*6;//转换为s
000078  f8c240ac          STR      r4,[r2,#0xac]  ; Para
                  |L19.124|
;;;600    			break;
;;;601    		default:
;;;602    			return 0;
;;;603    	}
;;;604    
;;;605    	return 1;
00007c  2001              MOVS     r0,#1
;;;606    }
00007e  bd30              POP      {r4,r5,pc}
                  |L19.128|
000080  2000              MOVS     r0,#0                 ;602
000082  bd30              POP      {r4,r5,pc}
;;;607    
                          ENDP

                  |L19.132|
                          DCD      Para

                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
                  |L20.0|
;;;106      */
;;;107    void MemManage_Handler(void)
000000  e7fe              B        |L20.0|
;;;108    {
;;;109      /* Go to infinite loop when Memory Manage exception occurs */
;;;110      while (1)
;;;111      {
;;;112      }
;;;113    }
;;;114    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;84       */
;;;85     void NMI_Handler(void)
000000  4770              BX       lr
;;;86     {
;;;87     }
;;;88     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;163      */
;;;164    void PendSV_Handler(void)
000000  4770              BX       lr
;;;165    {
;;;166    }
;;;167    
                          ENDP


                          AREA ||i.RecHandle||, CODE, READONLY, ALIGN=2

                  RecHandle PROC
;;;371    
;;;372    void RecHandle(void)
000000  490d              LDR      r1,|L23.56|
;;;373    {
;;;374        u8 crec[6];
;;;375        u8 *csend;
;;;376        static u8 *sendbuf;
;;;377        u8 sendlen;
;;;378        static u16 recrc;
;;;379        static u16 scrc;
;;;380        u8 i;
;;;381        lockflag = 1;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;382        switch(g_tModS.RxBuf[1])
000006  480d              LDR      r0,|L23.60|
000008  7840              LDRB     r0,[r0,#1]  ; g_tModS
00000a  2850              CMP      r0,#0x50
00000c  d00e              BEQ      |L23.44|
00000e  dc05              BGT      |L23.28|
000010  2803              CMP      r0,#3
000012  d009              BEQ      |L23.40|
000014  2806              CMP      r0,#6
000016  d10d              BNE      |L23.52|
;;;383        {
;;;384            case 0x03:
;;;385            {
;;;386                MODS_03H();
;;;387            }break;
;;;388            case 0x06:
;;;389            {
;;;390                MODS_06H();
000018  f7ffbffe          B.W      MODS_06H
                  |L23.28|
00001c  2851              CMP      r0,#0x51              ;382
00001e  d007              BEQ      |L23.48|
000020  2852              CMP      r0,#0x52              ;382
000022  d107              BNE      |L23.52|
;;;391            }break;
;;;392    		case 0x50:
;;;393            {
;;;394                MODS_50H();
;;;395            }break;
;;;396    		case 0x51:
;;;397            {
;;;398                MODS_51H();
;;;399            }break;
;;;400    		case 0x52:
;;;401            {
;;;402                MODS_52H();
000024  f7ffbffe          B.W      MODS_52H
                  |L23.40|
000028  f7ffbffe          B.W      MODS_03H
                  |L23.44|
00002c  f7ffbffe          B.W      MODS_50H
                  |L23.48|
000030  f7ffbffe          B.W      MODS_51H
                  |L23.52|
;;;403            }break;
;;;404            default:break;
;;;405        }
;;;406    }
000034  4770              BX       lr
;;;407    
                          ENDP

000036  0000              DCW      0x0000
                  |L23.56|
                          DCD      lockflag
                  |L23.60|
                          DCD      ||.bss||

                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;145      */
;;;146    void SVC_Handler(void)
000000  4770              BX       lr
;;;147    {
;;;148    }
;;;149    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;172      */
;;;173    void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175    	TimingDelay_Decrement();
000002  f7fffffe          BL       TimingDelay_Decrement
;;;176    	OS_TimeMS++;
000006  4812              LDR      r0,|L25.80|
000008  6801              LDR      r1,[r0,#0]  ; OS_TimeMS
00000a  1c49              ADDS     r1,r1,#1
00000c  6001              STR      r1,[r0,#0]  ; OS_TimeMS
;;;177    //	t_KeyScan++;
;;;178    //	if(t_KeyScan>10)
;;;179    //	{
;;;180    //		t_KeyScan=0;
;;;181    //		Flag_Key_Scan=1;//按键消抖标志
;;;182    //	}
;;;183    	t_0_5S++;
00000e  4811              LDR      r0,|L25.84|
000010  8801              LDRH     r1,[r0,#0]  ; t_0_5S
000012  1c49              ADDS     r1,r1,#1
000014  8001              STRH     r1,[r0,#0]
;;;184    	if(t_0_5S>20)
000016  8802              LDRH     r2,[r0,#0]  ; t_0_5S
000018  2100              MOVS     r1,#0
00001a  2a14              CMP      r2,#0x14
00001c  d905              BLS      |L25.42|
;;;185    	{
;;;186    		t_0_5S=0;
00001e  8001              STRH     r1,[r0,#0]
;;;187    		Flag_0_5S =1;//蜂鸣器响一声标志
000020  480d              LDR      r0,|L25.88|
000022  6802              LDR      r2,[r0,#0]  ; flagA
000024  f0420280          ORR      r2,r2,#0x80
000028  6002              STR      r2,[r0,#0]  ; flagA
                  |L25.42|
;;;188    	}
;;;189    //--------------------------------------------
;;;190    	if(flag_Tim_USART==1)//串口清零计数
00002a  480c              LDR      r0,|L25.92|
;;;191    	{
;;;192    		t_USART++;
00002c  4a0c              LDR      r2,|L25.96|
00002e  6803              LDR      r3,[r0,#0]            ;190  ; flagD
000030  07dc              LSLS     r4,r3,#31             ;190
000032  d002              BEQ      |L25.58|
000034  7814              LDRB     r4,[r2,#0]  ; t_USART
000036  1c64              ADDS     r4,r4,#1
000038  7014              STRB     r4,[r2,#0]
                  |L25.58|
;;;193    	}
;;;194    	if(t_USART>40)//大约2.6ms
00003a  7814              LDRB     r4,[r2,#0]  ; t_USART
00003c  2c28              CMP      r4,#0x28
00003e  d905              BLS      |L25.76|
;;;195    	{
;;;196    		t_USART=0;
000040  7011              STRB     r1,[r2,#0]
;;;197    		flag_Tim_USART=0;
000042  f0230201          BIC      r2,r3,#1
;;;198    		UART_Buffer_Size=0;	
000046  6002              STR      r2,[r0,#0]  ; flagD
000048  4806              LDR      r0,|L25.100|
00004a  7001              STRB     r1,[r0,#0]
                  |L25.76|
;;;199    	}
;;;200    }
00004c  bd10              POP      {r4,pc}
;;;201    
                          ENDP

00004e  0000              DCW      0x0000
                  |L25.80|
                          DCD      OS_TimeMS
                  |L25.84|
                          DCD      t_0_5S
                  |L25.88|
                          DCD      flagA
                  |L25.92|
                          DCD      flagD
                  |L25.96|
                          DCD      t_USART
                  |L25.100|
                          DCD      UART_Buffer_Size

                          AREA ||i.TIM6_DAC_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM6_DAC_IRQHandler PROC
;;;345    
;;;346    void  TIM6_DAC_IRQHandler (void)
000000  2101              MOVS     r1,#1
;;;347    {
;;;348    	TIM_ClearITPendingBit(TIM6,TIM_IT_Update);//?????λ
000002  4801              LDR      r0,|L26.8|
000004  f7ffbffe          B.W      TIM_ClearITPendingBit
;;;349    }
;;;350    
                          ENDP

                  |L26.8|
                          DCD      0x40001000

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;350    
;;;351    void USART1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;352    {
;;;353    //	flag_Tim_USART=1;
;;;354        
;;;355     	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000002  4d13              LDR      r5,|L27.80|
000004  f2405125          MOV      r1,#0x525
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d01c              BEQ      |L27.76|
;;;356    	{
;;;357    		
;;;358            g_mods_timeout = 2;
000012  4910              LDR      r1,|L27.84|
;;;359            if (g_tModS.RxCount < S_RX_BUF_SIZE)
000014  4c10              LDR      r4,|L27.88|
000016  2002              MOVS     r0,#2                 ;358
000018  7008              STRB     r0,[r1,#0]            ;358
00001a  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
00001e  281e              CMP      r0,#0x1e
000020  d20a              BCS      |L27.56|
;;;360            {
;;;361                g_tModS.RxBuf[g_tModS.RxCount++] = USART_ReceiveData(USART1);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USART_ReceiveData
000028  f894109e          LDRB     r1,[r4,#0x9e]  ; g_tModS
00002c  5460              STRB     r0,[r4,r1]
00002e  f894009e          LDRB     r0,[r4,#0x9e]  ; g_tModS
000032  1c40              ADDS     r0,r0,#1
000034  f884009e          STRB     r0,[r4,#0x9e]
                  |L27.56|
;;;362            }
;;;363    		if(g_tModS.RxCount > 7 && g_tModS.RxBuf[1] == 6)
000038  b2c0              UXTB     r0,r0
00003a  2807              CMP      r0,#7
00003c  d906              BLS      |L27.76|
00003e  7860              LDRB     r0,[r4,#1]  ; g_tModS
000040  2806              CMP      r0,#6
000042  d103              BNE      |L27.76|
;;;364    		{
;;;365    			MODS_SendAckOk();
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      MODS_SendAckOk
                  |L27.76|
;;;366    		}
;;;367    	}
;;;368    }
00004c  bd70              POP      {r4-r6,pc}
;;;369    
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
                          DCD      0x40011000
                  |L27.84|
                          DCD      ||.data||
                  |L27.88|
                          DCD      ||.bss||

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
                  |L28.0|
;;;132      */
;;;133    void UsageFault_Handler(void)
000000  e7fe              B        |L28.0|
;;;134    {
;;;135      /* Go to infinite loop when Usage Fault exception occurs */
;;;136      while (1)
;;;137      {
;;;138      }
;;;139    }
;;;140    
                          ENDP


                          AREA ||i.Usart_SendByte||, CODE, READONLY, ALIGN=1

                  Usart_SendByte PROC
;;;257    /*****************  发送一个字符 **********************/
;;;258    void Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)
000000  b510              PUSH     {r4,lr}
;;;259    {
000002  4604              MOV      r4,r0
;;;260    	/* 发送一个字节数据到USART */
;;;261    	USART_SendData(pUSARTx,ch);
000004  f7fffffe          BL       USART_SendData
                  |L29.8|
;;;262    		
;;;263    	/* 等待发送数据寄存器为空 */
;;;264    	while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);	
000008  2180              MOVS     r1,#0x80
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_GetFlagStatus
000010  2800              CMP      r0,#0
000012  d0f9              BEQ      |L29.8|
;;;265    }
000014  bd10              POP      {r4,pc}
;;;266    
                          ENDP


                          AREA ||i.uart1SendChars||, CODE, READONLY, ALIGN=2

                  uart1SendChars PROC
;;;266    
;;;267    void uart1SendChars(u8 *str, u16 strlen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;268    { 
;;;269    	  u16 k= 0 ; 
;;;270       do { 
;;;271           USART_SendData(USART1,*(str + k));
000004  4d09              LDR      r5,|L30.44|
000006  460e              MOV      r6,r1                 ;268
000008  4607              MOV      r7,r0                 ;268
00000a  2400              MOVS     r4,#0                 ;269
                  |L30.12|
00000c  4628              MOV      r0,r5
00000e  5d39              LDRB     r1,[r7,r4]
000010  f7fffffe          BL       USART_SendData
                  |L30.20|
;;;272           while (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);
000014  2180              MOVS     r1,#0x80
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L30.20|
000020  1c64              ADDS     r4,r4,#1
;;;273           k++; 
000022  b2a4              UXTH     r4,r4
;;;274           }   //循环发送,直到发送完毕   
;;;275        while (k < strlen); 
000024  42b4              CMP      r4,r6
000026  d3f1              BCC      |L30.12|
;;;276    } 
000028  e8bd81f0          POP      {r4-r8,pc}
;;;277    
                          ENDP

                  |L30.44|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_tModS
                          %        163

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  s_CRCHi
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  s_CRCLo
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  g_mods_timeout
000000  00                DCB      0x00
                  sendmodeflag
000001  00                DCB      0x00
                  mode_sw
000002  00                DCB      0x00
                  rmtrig
000003  00                DCB      0x00
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  v
                          DCD      0x00000000
                  shortv
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\User\\stm32f4xx_it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_e289a1ee____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_stm32f4xx_it_c_e289a1ee____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_e289a1ee____REVSH|
#line 144
|__asm___14_stm32f4xx_it_c_e289a1ee____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
