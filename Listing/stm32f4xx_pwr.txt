; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_pwr.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_pwr.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_pwr.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_pwr.c]
                          THUMB

                          AREA ||i.PWR_BackupAccessCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupAccessCmd PROC
;;;156      */
;;;157    void PWR_BackupAccessCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L1.8|
;;;158    {
;;;159      /* Check the parameters */
;;;160      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;161      
;;;162      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
000002  6208              STR      r0,[r1,#0x20]
;;;163    }
000004  4770              BX       lr
;;;164    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_BackupRegulatorCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupRegulatorCmd PROC
;;;360      */
;;;361    void PWR_BackupRegulatorCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L2.8|
;;;362    {
;;;363      /* Check the parameters */
;;;364      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;365    
;;;366      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
000002  f8c100a4          STR      r0,[r1,#0xa4]
;;;367    }
000006  4770              BX       lr
;;;368    
                          ENDP

                  |L2.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_ClearFlag||, CODE, READONLY, ALIGN=2

                  PWR_ClearFlag PROC
;;;901      */
;;;902    void PWR_ClearFlag(uint32_t PWR_FLAG)
000000  4902              LDR      r1,|L3.12|
;;;903    {
;;;904      /* Check the parameters */
;;;905      assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;906      
;;;907    #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
;;;908      if (PWR_FLAG != PWR_FLAG_UDRDY)
;;;909      {
;;;910        PWR->CR |=  PWR_FLAG << 2;
;;;911      }
;;;912      else
;;;913      {
;;;914        PWR->CSR |= PWR_FLAG_UDRDY;
;;;915      }
;;;916    #endif /* STM32F427_437xx ||  STM32F429_439xx */
;;;917    
;;;918    #if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F411xE) 
;;;919      PWR->CR |=  PWR_FLAG << 2;
000002  680a              LDR      r2,[r1,#0]
000004  ea420080          ORR      r0,r2,r0,LSL #2
000008  6008              STR      r0,[r1,#0]
;;;920    #endif /* STM32F40_41xxx  || STM32F401xx || STM32F411xE */
;;;921    }
00000a  4770              BX       lr
;;;922    
                          ENDP

                  |L3.12|
                          DCD      0x40007000

                          AREA ||i.PWR_DeInit||, CODE, READONLY, ALIGN=1

                  PWR_DeInit PROC
;;;141      */
;;;142    void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  070c              LSLS     r4,r1,#28
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;145      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;146    }
;;;147    
                          ENDP


                          AREA ||i.PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTANDBYMode PROC
;;;813      */
;;;814    void PWR_EnterSTANDBYMode(void)
000000  4805              LDR      r0,|L5.24|
;;;815    {
;;;816      /* Select STANDBY mode */
;;;817      PWR->CR |= PWR_CR_PDDS;
000002  6801              LDR      r1,[r0,#0]
000004  f0410102          ORR      r1,r1,#2
000008  6001              STR      r1,[r0,#0]
;;;818      
;;;819      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;820      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000a  4804              LDR      r0,|L5.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410104          ORR      r1,r1,#4
000012  6001              STR      r1,[r0,#0]
;;;821      
;;;822      /* This option is used to ensure that store operations are completed */
;;;823    #if defined ( __CC_ARM   )
;;;824      __force_stores();
;;;825    #endif
;;;826      /* Request Wait For Interrupt */
;;;827      __WFI();
000014  bf30              WFI      
;;;828    }
000016  4770              BX       lr
;;;829    
                          ENDP

                  |L5.24|
                          DCD      0x40007000
                  |L5.28|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTOPMode PROC
;;;700      */
;;;701    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  4b0b              LDR      r3,|L6.48|
;;;702    {
000002  b510              PUSH     {r4,lr}
;;;703      uint32_t tmpreg = 0;
;;;704      
;;;705      /* Check the parameters */
;;;706      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;707      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;708      
;;;709      /* Select the regulator state in STOP mode ---------------------------------*/
;;;710      tmpreg = PWR->CR;
000004  681a              LDR      r2,[r3,#0]
;;;711      /* Clear PDDS and LPDS bits */
;;;712      tmpreg &= CR_DS_MASK;
000006  f6404403          MOV      r4,#0xc03
00000a  43a2              BICS     r2,r2,r4
;;;713      
;;;714      /* Set LPDS, MRLVDS and LPLVDS bits according to PWR_Regulator value */
;;;715      tmpreg |= PWR_Regulator;
00000c  4302              ORRS     r2,r2,r0
;;;716      
;;;717      /* Store the new value */
;;;718      PWR->CR = tmpreg;
00000e  601a              STR      r2,[r3,#0]
;;;719      
;;;720      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;721      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000010  4808              LDR      r0,|L6.52|
000012  6802              LDR      r2,[r0,#0]
000014  f0420204          ORR      r2,r2,#4
000018  6002              STR      r2,[r0,#0]
;;;722      
;;;723      /* Select STOP mode entry --------------------------------------------------*/
;;;724      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
00001a  2901              CMP      r1,#1
00001c  d005              BEQ      |L6.42|
;;;725      {   
;;;726        /* Request Wait For Interrupt */
;;;727        __WFI();
;;;728      }
;;;729      else
;;;730      {
;;;731        /* Request Wait For Event */
;;;732        __WFE();
00001e  bf20              WFE      
                  |L6.32|
;;;733      }
;;;734      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;735      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
000020  6801              LDR      r1,[r0,#0]
000022  f0210104          BIC      r1,r1,#4
000026  6001              STR      r1,[r0,#0]
;;;736    }
000028  bd10              POP      {r4,pc}
                  |L6.42|
00002a  bf30              WFI                            ;727
00002c  e7f8              B        |L6.32|
;;;737    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40007000
                  |L6.52|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterUnderDriveSTOPMode PROC
;;;764      */
;;;765    void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  4b0b              LDR      r3,|L7.48|
;;;766    {
000002  b510              PUSH     {r4,lr}
;;;767      uint32_t tmpreg = 0;
;;;768      
;;;769      /* Check the parameters */
;;;770      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(PWR_Regulator));
;;;771      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;772      
;;;773      /* Select the regulator state in STOP mode ---------------------------------*/
;;;774      tmpreg = PWR->CR;
000004  681a              LDR      r2,[r3,#0]
;;;775      /* Clear PDDS and LPDS bits */
;;;776      tmpreg &= CR_DS_MASK;
000006  f6404403          MOV      r4,#0xc03
00000a  43a2              BICS     r2,r2,r4
;;;777      
;;;778      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;779      tmpreg |= PWR_Regulator;
00000c  4302              ORRS     r2,r2,r0
;;;780      
;;;781      /* Store the new value */
;;;782      PWR->CR = tmpreg;
00000e  601a              STR      r2,[r3,#0]
;;;783      
;;;784      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;785      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000010  4808              LDR      r0,|L7.52|
000012  6802              LDR      r2,[r0,#0]
000014  f0420204          ORR      r2,r2,#4
000018  6002              STR      r2,[r0,#0]
;;;786      
;;;787      /* Select STOP mode entry --------------------------------------------------*/
;;;788      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
00001a  2901              CMP      r1,#1
00001c  d005              BEQ      |L7.42|
;;;789      {   
;;;790        /* Request Wait For Interrupt */
;;;791        __WFI();
;;;792      }
;;;793      else
;;;794      {
;;;795        /* Request Wait For Event */
;;;796        __WFE();
00001e  bf20              WFE      
                  |L7.32|
;;;797      }
;;;798      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;799      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
000020  6801              LDR      r1,[r0,#0]
000022  f0210104          BIC      r1,r1,#4
000026  6001              STR      r1,[r0,#0]
;;;800    }
000028  bd10              POP      {r4,pc}
                  |L7.42|
00002a  bf30              WFI                            ;791
00002c  e7f8              B        |L7.32|
;;;801    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0x40007000
                  |L7.52|
                          DCD      0xe000ed10

                          AREA ||i.PWR_FlashPowerDownCmd||, CODE, READONLY, ALIGN=2

                  PWR_FlashPowerDownCmd PROC
;;;554      */
;;;555    void PWR_FlashPowerDownCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;556    {
;;;557      /* Check the parameters */
;;;558      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;559    
;;;560      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
000002  6248              STR      r0,[r1,#0x24]
;;;561    }
000004  4770              BX       lr
;;;562    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  PWR_GetFlagStatus PROC
;;;873      */
;;;874    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
000000  4a03              LDR      r2,|L9.16|
;;;875    {
000002  4601              MOV      r1,r0
;;;876      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;877      
;;;878      /* Check the parameters */
;;;879      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;880      
;;;881      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
000006  6852              LDR      r2,[r2,#4]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L9.14|
;;;882      {
;;;883        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;884      }
;;;885      else
;;;886      {
;;;887        bitstatus = RESET;
;;;888      }
;;;889      /* Return the flag status */
;;;890      return bitstatus;
;;;891    }
00000e  4770              BX       lr
;;;892    
                          ENDP

                  |L9.16|
                          DCD      0x40007000

                          AREA ||i.PWR_LowRegulatorLowVoltageCmd||, CODE, READONLY, ALIGN=2

                  PWR_LowRegulatorLowVoltageCmd PROC
;;;512      */
;;;513    void PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState)
000000  4902              LDR      r1,|L10.12|
;;;514    {
000002  b100              CBZ      r0,|L10.6|
;;;515      /* Check the parameters */
;;;516      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;517      
;;;518      if (NewState != DISABLE)
;;;519      {
;;;520        *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;
000004  2001              MOVS     r0,#1
                  |L10.6|
000006  6288              STR      r0,[r1,#0x28]
;;;521      }
;;;522      else
;;;523      {
;;;524        *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;
;;;525      }
;;;526    }
000008  4770              BX       lr
;;;527    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x420e0000

                          AREA ||i.PWR_MainRegulatorLowVoltageCmd||, CODE, READONLY, ALIGN=2

                  PWR_MainRegulatorLowVoltageCmd PROC
;;;488      */
;;;489    void PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState)
000000  4902              LDR      r1,|L11.12|
;;;490    { 
000002  b100              CBZ      r0,|L11.6|
;;;491      /* Check the parameters */
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493      
;;;494      if (NewState != DISABLE)
;;;495      {
;;;496        *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;
000004  2001              MOVS     r0,#1
                  |L11.6|
000006  62c8              STR      r0,[r1,#0x2c]
;;;497      }
;;;498      else
;;;499      {
;;;500        *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;
;;;501      }
;;;502    }
000008  4770              BX       lr
;;;503    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x420e0000

                          AREA ||i.PWR_MainRegulatorModeConfig||, CODE, READONLY, ALIGN=2

                  PWR_MainRegulatorModeConfig PROC
;;;382      */
;;;383    void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
000000  4a03              LDR      r2,|L12.16|
;;;384    {
;;;385      uint32_t tmpreg = 0;
;;;386    	
;;;387      /* Check the parameters */
;;;388      assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
;;;389    
;;;390      tmpreg = PWR->CR;
000002  6811              LDR      r1,[r2,#0]
;;;391      
;;;392      /* Clear VOS[15:14] bits */
;;;393      tmpreg &= CR_VOS_MASK;
000004  f4214140          BIC      r1,r1,#0xc000
;;;394      
;;;395      /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
;;;396      tmpreg |= PWR_Regulator_Voltage;
000008  4301              ORRS     r1,r1,r0
;;;397      
;;;398      /* Store the new value */
;;;399      PWR->CR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;400    }
00000c  4770              BX       lr
;;;401    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x40007000

                          AREA ||i.PWR_OverDriveCmd||, CODE, READONLY, ALIGN=2

                  PWR_OverDriveCmd PROC
;;;417      */
;;;418    void PWR_OverDriveCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L13.8|
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422      
;;;423      /* Set/Reset the ODEN bit to enable/disable the Over Drive mode */
;;;424      *(__IO uint32_t *) CR_ODEN_BB = (uint32_t)NewState;
000002  6408              STR      r0,[r1,#0x40]
;;;425    }
000004  4770              BX       lr
;;;426    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_OverDriveSWCmd||, CODE, READONLY, ALIGN=2

                  PWR_OverDriveSWCmd PROC
;;;435      */
;;;436    void PWR_OverDriveSWCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L14.8|
;;;437    {
;;;438      /* Check the parameters */
;;;439      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;440    
;;;441      /* Set/Reset the ODSWEN bit to enable/disable the Over Drive switching mode */
;;;442      *(__IO uint32_t *) CR_ODSWEN_BB = (uint32_t)NewState;
000002  6448              STR      r0,[r1,#0x44]
;;;443    }
000004  4770              BX       lr
;;;444    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDCmd||, CODE, READONLY, ALIGN=2

                  PWR_PVDCmd PROC
;;;229      */
;;;230    void PWR_PVDCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L15.8|
;;;231    {
;;;232      /* Check the parameters */
;;;233      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;234      
;;;235      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
000002  6108              STR      r0,[r1,#0x10]
;;;236    }
000004  4770              BX       lr
;;;237    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDLevelConfig||, CODE, READONLY, ALIGN=2

                  PWR_PVDLevelConfig PROC
;;;204      */
;;;205    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
000000  4a03              LDR      r2,|L16.16|
;;;206    {
;;;207      uint32_t tmpreg = 0;
;;;208      
;;;209      /* Check the parameters */
;;;210      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;211      
;;;212      tmpreg = PWR->CR;
000002  6811              LDR      r1,[r2,#0]
;;;213      
;;;214      /* Clear PLS[7:5] bits */
;;;215      tmpreg &= CR_PLS_MASK;
000004  f02101e0          BIC      r1,r1,#0xe0
;;;216      
;;;217      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;218      tmpreg |= PWR_PVDLevel;
000008  4301              ORRS     r1,r1,r0
;;;219      
;;;220      /* Store the new value */
;;;221      PWR->CR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;222    }
00000c  4770              BX       lr
;;;223    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40007000

                          AREA ||i.PWR_UnderDriveCmd||, CODE, READONLY, ALIGN=2

                  PWR_UnderDriveCmd PROC
;;;462      */
;;;463    void PWR_UnderDriveCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L17.24|
;;;464    {
;;;465      /* Check the parameters */
;;;466      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;467    
;;;468      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;469      {
;;;470        /* Set the UDEN[1:0] bits to enable the Under Drive mode */
;;;471        PWR->CR |= (uint32_t)PWR_CR_UDEN;
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Reset the UDEN[1:0] bits to disable the Under Drive mode */
;;;476        PWR->CR &= (uint32_t)(~PWR_CR_UDEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L17.14|
000008  f4402040          ORR      r0,r0,#0xc0000        ;471
00000c  e001              B        |L17.18|
                  |L17.14|
00000e  f4202040          BIC      r0,r0,#0xc0000
                  |L17.18|
000012  6008              STR      r0,[r1,#0]            ;471
;;;477      }
;;;478    }
000014  4770              BX       lr
;;;479    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0x40007000

                          AREA ||i.PWR_WakeUpPinCmd||, CODE, READONLY, ALIGN=2

                  PWR_WakeUpPinCmd PROC
;;;263      */
;;;264    void PWR_WakeUpPinCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L18.8|
;;;265    {
;;;266      /* Check the parameters */  
;;;267      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;268    
;;;269      *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
000002  f8c100a0          STR      r0,[r1,#0xa0]
;;;270    }
000006  4770              BX       lr
;;;271    
                          ENDP

                  |L18.8|
                          DCD      0x420e0000

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH|
#line 144
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
