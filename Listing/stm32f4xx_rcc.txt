; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_rcc.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_rcc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=538 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_rcc.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1525     */
;;;1526   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L1.20|
;;;1527   {
;;;1528     /* Check the parameters */
;;;1529     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1530   
;;;1531     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1532     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1533     {
;;;1534       RCC->AHB1ENR |= RCC_AHB1Periph;
;;;1535     }
;;;1536     else
;;;1537     {
;;;1538       RCC->AHB1ENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;1534
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  6011              STR      r1,[r2,#0]            ;1534
;;;1539     }
;;;1540   }
000010  4770              BX       lr
;;;1541   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1917     */
;;;1918   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1919   {
;;;1920     /* Check the parameters */
;;;1921     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1922     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1923     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1924     {
;;;1925       RCC->AHB1LPENR |= RCC_AHB1Periph;
;;;1926     }
;;;1927     else
;;;1928     {
;;;1929       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1925
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6011              STR      r1,[r2,#0]            ;1925
;;;1930     }
;;;1931   }
000010  4770              BX       lr
;;;1932   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1724     */
;;;1725   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1726   {
;;;1727     /* Check the parameters */
;;;1728     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1729     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1730   
;;;1731     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1732     {
;;;1733       RCC->AHB1RSTR |= RCC_AHB1Periph;
;;;1734     }
;;;1735     else
;;;1736     {
;;;1737       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1733
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  6011              STR      r1,[r2,#0]            ;1733
;;;1738     }
;;;1739   }
000010  4770              BX       lr
;;;1740   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1557     */
;;;1558   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1559   {
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1562     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1563   
;;;1564     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1565     {
;;;1566       RCC->AHB2ENR |= RCC_AHB2Periph;
;;;1567     }
;;;1568     else
;;;1569     {
;;;1570       RCC->AHB2ENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1566
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6011              STR      r1,[r2,#0]            ;1566
;;;1571     }
;;;1572   }
000010  4770              BX       lr
;;;1573   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1949     */
;;;1950   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1951   {
;;;1952     /* Check the parameters */
;;;1953     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1954     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1955     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1956     {
;;;1957       RCC->AHB2LPENR |= RCC_AHB2Periph;
;;;1958     }
;;;1959     else
;;;1960     {
;;;1961       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1957
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6011              STR      r1,[r2,#0]            ;1957
;;;1962     }
;;;1963   }
000010  4770              BX       lr
;;;1964   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;1753     */
;;;1754   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1755   {
;;;1756     /* Check the parameters */
;;;1757     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1758     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1759   
;;;1760     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1761     {
;;;1762       RCC->AHB2RSTR |= RCC_AHB2Periph;
;;;1763     }
;;;1764     else
;;;1765     {
;;;1766       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1762
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6011              STR      r1,[r2,#0]            ;1762
;;;1767     }
;;;1768   }
000010  4770              BX       lr
;;;1769   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1585     */
;;;1586   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;1587   {
;;;1588     /* Check the parameters */
;;;1589     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1590     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1591   
;;;1592     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1593     {
;;;1594       RCC->AHB3ENR |= RCC_AHB3Periph;
;;;1595     }
;;;1596     else
;;;1597     {
;;;1598       RCC->AHB3ENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L7.12|
000008  4301              ORRS     r1,r1,r0              ;1594
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4381              BICS     r1,r1,r0
                  |L7.14|
00000e  6011              STR      r1,[r2,#0]            ;1594
;;;1599     }
;;;1600   }
000010  4770              BX       lr
;;;1601   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1977     */
;;;1978   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;1979   {
;;;1980     /* Check the parameters */
;;;1981     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1982     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1983     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1984     {
;;;1985       RCC->AHB3LPENR |= RCC_AHB3Periph;
;;;1986     }
;;;1987     else
;;;1988     {
;;;1989       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L8.12|
000008  4301              ORRS     r1,r1,r0              ;1985
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  4381              BICS     r1,r1,r0
                  |L8.14|
00000e  6011              STR      r1,[r2,#0]            ;1985
;;;1990     }
;;;1991   }
000010  4770              BX       lr
;;;1992   
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;1778     */
;;;1779   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;1780   {
;;;1781     /* Check the parameters */
;;;1782     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1783     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1784   
;;;1785     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1786     {
;;;1787       RCC->AHB3RSTR |= RCC_AHB3Periph;
;;;1788     }
;;;1789     else
;;;1790     {
;;;1791       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;1787
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;1787
;;;1792     }
;;;1793   }
000010  4770              BX       lr
;;;1794   
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1637     */
;;;1638   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;1639   {
;;;1640     /* Check the parameters */
;;;1641     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1642     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1643   
;;;1644     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1645     {
;;;1646       RCC->APB1ENR |= RCC_APB1Periph;
;;;1647     }
;;;1648     else
;;;1649     {
;;;1650       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;1646
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  4381              BICS     r1,r1,r0
                  |L10.14|
00000e  6011              STR      r1,[r2,#0]            ;1646
;;;1651     }
;;;1652   }
000010  4770              BX       lr
;;;1653   
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;2029     */
;;;2030   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;2031   {
;;;2032     /* Check the parameters */
;;;2033     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;2034     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2035     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2036     {
;;;2037       RCC->APB1LPENR |= RCC_APB1Periph;
;;;2038     }
;;;2039     else
;;;2040     {
;;;2041       RCC->APB1LPENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L11.12|
000008  4301              ORRS     r1,r1,r0              ;2037
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  4381              BICS     r1,r1,r0
                  |L11.14|
00000e  6011              STR      r1,[r2,#0]            ;2037
;;;2042     }
;;;2043   }
000010  4770              BX       lr
;;;2044   
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1827     */
;;;1828   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L12.20|
;;;1829   {
;;;1830     /* Check the parameters */
;;;1831     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1832     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1833     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1834     {
;;;1835       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1836     }
;;;1837     else
;;;1838     {
;;;1839       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L12.12|
000008  4301              ORRS     r1,r1,r0              ;1835
00000a  e000              B        |L12.14|
                  |L12.12|
00000c  4381              BICS     r1,r1,r0
                  |L12.14|
00000e  6011              STR      r1,[r2,#0]            ;1835
;;;1840     }
;;;1841   }
000010  4770              BX       lr
;;;1842   
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1682     */
;;;1683   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L13.20|
;;;1684   {
;;;1685     /* Check the parameters */
;;;1686     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1687     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1688   
;;;1689     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1690     {
;;;1691       RCC->APB2ENR |= RCC_APB2Periph;
;;;1692     }
;;;1693     else
;;;1694     {
;;;1695       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L13.12|
000008  4301              ORRS     r1,r1,r0              ;1691
00000a  e000              B        |L13.14|
                  |L13.12|
00000c  4381              BICS     r1,r1,r0
                  |L13.14|
00000e  6011              STR      r1,[r2,#0]            ;1691
;;;1696     }
;;;1697   }
000010  4770              BX       lr
;;;1698   
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;2074     */
;;;2075   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L14.20|
;;;2076   {
;;;2077     /* Check the parameters */
;;;2078     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;2079     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2080     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2081     {
;;;2082       RCC->APB2LPENR |= RCC_APB2Periph;
;;;2083     }
;;;2084     else
;;;2085     {
;;;2086       RCC->APB2LPENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L14.12|
000008  4301              ORRS     r1,r1,r0              ;2082
00000a  e000              B        |L14.14|
                  |L14.12|
00000c  4381              BICS     r1,r1,r0
                  |L14.14|
00000e  6011              STR      r1,[r2,#0]            ;2082
;;;2087     }
;;;2088   }
000010  4770              BX       lr
;;;2089   
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1868     */
;;;1869   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L15.20|
;;;1870   {
;;;1871     /* Check the parameters */
;;;1872     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1873     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1874     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1875     {
;;;1876       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1877     }
;;;1878     else
;;;1879     {
;;;1880       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L15.12|
000008  4301              ORRS     r1,r1,r0              ;1876
00000a  e000              B        |L15.14|
                  |L15.12|
00000c  4381              BICS     r1,r1,r0
                  |L15.14|
00000e  6011              STR      r1,[r2,#0]            ;1876
;;;1881     }
;;;1882   }
000010  4770              BX       lr
;;;1883   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;317      */
;;;318    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L16.16|
;;;319    {
;;;320      uint32_t tmpreg = 0;
;;;321      /* Check the parameters */
;;;322      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;323    
;;;324      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;325    
;;;326      /* Clear HSITRIM[4:0] bits */
;;;327      tmpreg &= ~RCC_CR_HSITRIM;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;328    
;;;329      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;330      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;331    
;;;332      /* Store the new value */
;;;333      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;334    }
00000e  4770              BX       lr
;;;335    
                          ENDP

                  |L16.16|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1270     */
;;;1271   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;1272   {
;;;1273     /* Check the parameters */
;;;1274     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1275     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1276   }
000004  4770              BX       lr
;;;1277   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;2226     */
;;;2227   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L18.12|
;;;2228   {
;;;2229     /* Set RMVF bit to clear the reset flags */
;;;2230     RCC->CSR |= RCC_CSR_RMVF;
000002  6801              LDR      r1,[r0,#0]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6001              STR      r1,[r0,#0]
;;;2231   }
00000a  4770              BX       lr
;;;2232   
                          ENDP

                  |L18.12|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;2280     */
;;;2281   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L19.8|
;;;2282   {
;;;2283     /* Check the parameters */
;;;2284     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;2285   
;;;2286     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;2287        pending bits */
;;;2288     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;2289   }
000004  4770              BX       lr
;;;2290   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;670      */
;;;671    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;672    {
;;;673      /* Check the parameters */
;;;674      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;675      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;676    }
000004  4770              BX       lr
;;;677    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;212      */
;;;213    void RCC_DeInit(void)
000000  4810              LDR      r0,|L21.68|
;;;214    {
;;;215      /* Set HSION bit */
;;;216      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;217    
;;;218      /* Reset CFGR register */
;;;219      RCC->CFGR = 0x00000000;
00000a  4a0e              LDR      r2,|L21.68|
00000c  2100              MOVS     r1,#0
00000e  3208              ADDS     r2,r2,#8
000010  6011              STR      r1,[r2,#0]
;;;220    
;;;221      /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
;;;222      RCC->CR &= (uint32_t)0xEAF6FFFF;
000012  6802              LDR      r2,[r0,#0]
000014  4b0c              LDR      r3,|L21.72|
000016  401a              ANDS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
;;;223    
;;;224      /* Reset PLLCFGR register */
;;;225      RCC->PLLCFGR = 0x24003010;
00001a  1d03              ADDS     r3,r0,#4
00001c  4a0b              LDR      r2,|L21.76|
00001e  601a              STR      r2,[r3,#0]
;;;226    
;;;227      /* Reset PLLI2SCFGR register */
;;;228      RCC->PLLI2SCFGR = 0x20003000;
000020  4b08              LDR      r3,|L21.68|
000022  4a0b              LDR      r2,|L21.80|
000024  3384              ADDS     r3,r3,#0x84
000026  601a              STR      r2,[r3,#0]
;;;229    
;;;230      /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
;;;231      RCC->PLLSAICFGR = 0x24003000;
000028  4a08              LDR      r2,|L21.76|
00002a  3a10              SUBS     r2,r2,#0x10
00002c  1d1b              ADDS     r3,r3,#4
00002e  601a              STR      r2,[r3,#0]
;;;232     
;;;233      /* Reset HSEBYP bit */
;;;234      RCC->CR &= (uint32_t)0xFFFBFFFF;
000030  6802              LDR      r2,[r0,#0]
000032  f4222280          BIC      r2,r2,#0x40000
000036  6002              STR      r2,[r0,#0]
;;;235    
;;;236      /* Disable all interrupts */
;;;237      RCC->CIR = 0x00000000;
000038  4802              LDR      r0,|L21.68|
00003a  300c              ADDS     r0,r0,#0xc
00003c  6001              STR      r1,[r0,#0]
;;;238    
;;;239      /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
;;;240      RCC->DCKCFGR = 0x00000000; 
00003e  1d18              ADDS     r0,r3,#4
000040  6001              STR      r1,[r0,#0]
;;;241    }
000042  4770              BX       lr
;;;242    
                          ENDP

                  |L21.68|
                          DCD      0x40023800
                  |L21.72|
                          DCD      0xeaf6ffff
                  |L21.76|
                          DCD      0x24003010
                  |L21.80|
                          DCD      0x20003000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;1096     */
;;;1097   void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b570              PUSH     {r4-r6,lr}
;;;1098   {
;;;1099     uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
;;;1100   
;;;1101     /* Get SYSCLK source -------------------------------------------------------*/
;;;1102     tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  4a20              LDR      r2,|L22.132|
000004  6811              LDR      r1,[r2,#0]
;;;1103   
;;;1104     switch (tmp)
;;;1105     {
;;;1106       case 0x00:  /* HSI used as system clock source */
;;;1107         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000006  4c20              LDR      r4,|L22.136|
000008  f011010c          ANDS     r1,r1,#0xc            ;1102
00000c  d004              BEQ      |L22.24|
;;;1108         break;
;;;1109       case 0x04:  /* HSE used as system clock  source */
;;;1110         RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00000e  1066              ASRS     r6,r4,#1
000010  2904              CMP      r1,#4                 ;1104
000012  d003              BEQ      |L22.28|
000014  2908              CMP      r1,#8                 ;1104
000016  d003              BEQ      |L22.32|
                  |L22.24|
000018  6004              STR      r4,[r0,#0]            ;1108
00001a  e01b              B        |L22.84|
                  |L22.28|
;;;1111         break;
00001c  6006              STR      r6,[r0,#0]
00001e  e019              B        |L22.84|
                  |L22.32|
;;;1112       case 0x08:  /* PLL used as system clock  source */
;;;1113   
;;;1114         /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1115            SYSCLK = PLL_VCO / PLLP
;;;1116            */    
;;;1117         pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
000020  4918              LDR      r1,|L22.132|
000022  1f09              SUBS     r1,r1,#4
000024  680b              LDR      r3,[r1,#0]
000026  f3c35580          UBFX     r5,r3,#22,#1
;;;1118         pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
00002a  680b              LDR      r3,[r1,#0]
00002c  f003033f          AND      r3,r3,#0x3f
;;;1119         
;;;1120         if (pllsource != 0)
000030  b115              CBZ      r5,|L22.56|
;;;1121         {
;;;1122           /* HSE used as PLL clock source */
;;;1123           pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000032  fbb6f3f3          UDIV     r3,r6,r3
000036  e001              B        |L22.60|
                  |L22.56|
;;;1124         }
;;;1125         else
;;;1126         {
;;;1127           /* HSI used as PLL clock source */
;;;1128           pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000038  fbb4f3f3          UDIV     r3,r4,r3
                  |L22.60|
00003c  680c              LDR      r4,[r1,#0]
;;;1129         }
;;;1130   
;;;1131         pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00003e  6809              LDR      r1,[r1,#0]
000040  f3c41488          UBFX     r4,r4,#6,#9           ;1128
000044  4363              MULS     r3,r4,r3              ;1128
000046  f3c14101          UBFX     r1,r1,#16,#2
00004a  1c49              ADDS     r1,r1,#1
00004c  0049              LSLS     r1,r1,#1
;;;1132         RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
00004e  fbb3f1f1          UDIV     r1,r3,r1
000052  6001              STR      r1,[r0,#0]
                  |L22.84|
;;;1133         break;
;;;1134       default:
;;;1135         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;1136         break;
;;;1137     }
;;;1138     /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;1139   
;;;1140     /* Get HCLK prescaler */
;;;1141     tmp = RCC->CFGR & RCC_CFGR_HPRE;
000054  6811              LDR      r1,[r2,#0]
;;;1142     tmp = tmp >> 4;
;;;1143     presc = APBAHBPrescTable[tmp];
;;;1144     /* HCLK clock frequency */
;;;1145     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;1146   
;;;1147     /* Get PCLK1 prescaler */
;;;1148     tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;1149     tmp = tmp >> 10;
;;;1150     presc = APBAHBPrescTable[tmp];
;;;1151     /* PCLK1 clock frequency */
;;;1152     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1153   
;;;1154     /* Get PCLK2 prescaler */
;;;1155     tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;1156     tmp = tmp >> 13;
;;;1157     presc = APBAHBPrescTable[tmp];
;;;1158     /* PCLK2 clock frequency */
;;;1159     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1160   }
000056  230f              MOVS     r3,#0xf
000058  ea031111          AND      r1,r3,r1,LSR #4
00005c  4b0b              LDR      r3,|L22.140|
00005e  5c5c              LDRB     r4,[r3,r1]            ;1143
000060  6801              LDR      r1,[r0,#0]            ;1145
000062  40e1              LSRS     r1,r1,r4              ;1145
000064  6041              STR      r1,[r0,#4]            ;1148
000066  6814              LDR      r4,[r2,#0]            ;1148
000068  2507              MOVS     r5,#7
00006a  ea052494          AND      r4,r5,r4,LSR #10
00006e  5d1c              LDRB     r4,[r3,r4]            ;1150
000070  fa21f404          LSR      r4,r1,r4              ;1152
000074  6084              STR      r4,[r0,#8]            ;1155
000076  6812              LDR      r2,[r2,#0]            ;1155
000078  ea053252          AND      r2,r5,r2,LSR #13
00007c  5c9a              LDRB     r2,[r3,r2]            ;1157
00007e  40d1              LSRS     r1,r1,r2              ;1159
000080  60c1              STR      r1,[r0,#0xc]          ;1159
000082  bd70              POP      {r4-r6,pc}
;;;1161   
                          ENDP

                  |L22.132|
                          DCD      0x40023808
                  |L22.136|
                          DCD      0x00f42400
                  |L22.140|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;2181     */
;;;2182   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4602              MOV      r2,r0
;;;2183   {
;;;2184     uint32_t tmp = 0;
;;;2185     uint32_t statusreg = 0;
;;;2186     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;2187   
;;;2188     /* Check the parameters */
;;;2189     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;2190   
;;;2191     /* Get the RCC register index */
;;;2192     tmp = RCC_FLAG >> 5;
000004  0951              LSRS     r1,r2,#5
;;;2193     if (tmp == 1)               /* The flag to check is in CR register */
000006  2901              CMP      r1,#1
000008  d00b              BEQ      |L23.34|
;;;2194     {
;;;2195       statusreg = RCC->CR;
;;;2196     }
;;;2197     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000a  2902              CMP      r1,#2
00000c  d00c              BEQ      |L23.40|
;;;2198     {
;;;2199       statusreg = RCC->BDCR;
;;;2200     }
;;;2201     else                       /* The flag to check is in CSR register */
;;;2202     {
;;;2203       statusreg = RCC->CSR;
00000e  4908              LDR      r1,|L23.48|
                  |L23.16|
000010  6809              LDR      r1,[r1,#0]            ;2199
;;;2204     }
;;;2205   
;;;2206     /* Get the flag position */
;;;2207     tmp = RCC_FLAG & FLAG_MASK;
000012  f002021f          AND      r2,r2,#0x1f
;;;2208     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000016  2301              MOVS     r3,#1
000018  4093              LSLS     r3,r3,r2
00001a  420b              TST      r3,r1
00001c  d000              BEQ      |L23.32|
;;;2209     {
;;;2210       bitstatus = SET;
00001e  2001              MOVS     r0,#1
                  |L23.32|
;;;2211     }
;;;2212     else
;;;2213     {
;;;2214       bitstatus = RESET;
;;;2215     }
;;;2216     /* Return the flag status */
;;;2217     return bitstatus;
;;;2218   }
000020  4770              BX       lr
                  |L23.34|
000022  4903              LDR      r1,|L23.48|
000024  3974              SUBS     r1,r1,#0x74           ;2195
000026  e7f3              B        |L23.16|
                  |L23.40|
000028  4901              LDR      r1,|L23.48|
00002a  1f09              SUBS     r1,r1,#4              ;2199
00002c  e7f0              B        |L23.16|
;;;2219   
                          ENDP

00002e  0000              DCW      0x0000
                  |L23.48|
                          DCD      0x40023874

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;2246     */
;;;2247   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L24.16|
;;;2248   {
000002  4601              MOV      r1,r0
;;;2249     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2250   
;;;2251     /* Check the parameters */
;;;2252     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;2253   
;;;2254     /* Check the status of the specified RCC interrupt */
;;;2255     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L24.14|
;;;2256     {
;;;2257       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L24.14|
;;;2258     }
;;;2259     else
;;;2260     {
;;;2261       bitstatus = RESET;
;;;2262     }
;;;2263     /* Return the RCC_IT status */
;;;2264     return  bitstatus;
;;;2265   }
00000e  4770              BX       lr
;;;2266   
                          ENDP

                  |L24.16|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;956      */
;;;957    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;958    {
;;;959      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;960    }
000008  4770              BX       lr
;;;961    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;981      */
;;;982    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L26.16|
;;;983    {
;;;984      uint32_t tmpreg = 0;
;;;985      
;;;986      /* Check the parameters */
;;;987      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;988    
;;;989      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;990    
;;;991      /* Clear HPRE[3:0] bits */
;;;992      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;993    
;;;994      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;995      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;996    
;;;997      /* Store the new value */
;;;998      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;999    }
00000c  4770              BX       lr
;;;1000   
                          ENDP

00000e  0000              DCW      0x0000
                  |L26.16|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;262      */
;;;263    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L27.12|
;;;264    {
;;;265      /* Check the parameters */
;;;266      assert_param(IS_RCC_HSE(RCC_HSE));
;;;267    
;;;268      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;269      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;270    
;;;271      /* Set the new HSE configuration -------------------------------------------*/
;;;272      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  7008              STRB     r0,[r1,#0]
;;;273    }
000008  4770              BX       lr
;;;274    
                          ENDP

00000a  0000              DCW      0x0000
                  |L27.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;353      */
;;;354    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;358    
;;;359      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;360    }
000004  4770              BX       lr
;;;361    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1287     */
;;;1288   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L29.8|
;;;1289   {
;;;1290     /* Check the parameters */
;;;1291     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1292   
;;;1293     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000002  f8c1015c          STR      r0,[r1,#0x15c]
;;;1294   }
000006  4770              BX       lr
;;;1295   
                          ENDP

                  |L29.8|
                          DCD      0x42470000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;2144     */
;;;2145   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L30.20|
;;;2146   {
;;;2147     /* Check the parameters */
;;;2148     assert_param(IS_RCC_IT(RCC_IT));
;;;2149     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2150     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2151     {
;;;2152       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;2153       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;2154     }
;;;2155     else
;;;2156     {
;;;2157       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;2158       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7811              LDRB     r1,[r2,#0]
000006  d001              BEQ      |L30.12|
000008  4301              ORRS     r1,r1,r0              ;2153
00000a  e000              B        |L30.14|
                  |L30.12|
00000c  4381              BICS     r1,r1,r0
                  |L30.14|
00000e  7011              STRB     r1,[r2,#0]            ;2153
;;;2159     }
;;;2160   }
000010  4770              BX       lr
;;;2161   
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;378      */
;;;379    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4905              LDR      r1,|L31.24|
;;;380    {
;;;381      /* Check the parameters */
;;;382      assert_param(IS_RCC_LSE(RCC_LSE));
;;;383    
;;;384      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;385      /* Reset LSEON bit */
;;;386      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;387    
;;;388      /* Reset LSEBYP bit */
;;;389      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  700a              STRB     r2,[r1,#0]
;;;390    
;;;391      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;392      switch (RCC_LSE)
000008  2801              CMP      r0,#1
00000a  d002              BEQ      |L31.18|
00000c  2804              CMP      r0,#4
00000e  d101              BNE      |L31.20|
;;;393      {
;;;394        case RCC_LSE_ON:
;;;395          /* Set LSEON bit */
;;;396          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;397          break;
;;;398        case RCC_LSE_Bypass:
;;;399          /* Set LSEBYP and LSEON bits */
;;;400          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000010  2005              MOVS     r0,#5
                  |L31.18|
000012  7008              STRB     r0,[r1,#0]
                  |L31.20|
;;;401          break;
;;;402        default:
;;;403          break;
;;;404      }
;;;405    }
000014  4770              BX       lr
;;;406    
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      0x40023870

                          AREA ||i.RCC_LSEModeConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEModeConfig PROC
;;;2098     */
;;;2099   void RCC_LSEModeConfig(uint8_t Mode)
000000  4905              LDR      r1,|L32.24|
;;;2100   {
;;;2101     /* Check the parameters */
;;;2102     assert_param(IS_RCC_LSE_MODE(Mode));
;;;2103     
;;;2104     if(Mode == RCC_LSE_HIGHDRIVE_MODE)
000002  2801              CMP      r0,#1
;;;2105     {
;;;2106       SET_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
;;;2107     }
;;;2108     else
;;;2109     {
;;;2110       CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
000004  6808              LDR      r0,[r1,#0]
000006  d003              BEQ      |L32.16|
000008  f0200008          BIC      r0,r0,#8
                  |L32.12|
00000c  6008              STR      r0,[r1,#0]            ;2106
;;;2111     }
;;;2112   }
00000e  4770              BX       lr
                  |L32.16|
000010  f0400008          ORR      r0,r0,#8              ;2106
000014  e7fa              B        |L32.12|
;;;2113   
                          ENDP

000016  0000              DCW      0x0000
                  |L32.24|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;418      */
;;;419    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L33.8|
;;;420    {
;;;421      /* Check the parameters */
;;;422      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;423    
;;;424      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;425    }
000004  4770              BX       lr
;;;426    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_LTDCCLKDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_LTDCCLKDivConfig PROC
;;;1445     */
;;;1446   void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
000000  4a03              LDR      r2,|L34.16|
;;;1447   {
;;;1448     uint32_t tmpreg = 0;
;;;1449     
;;;1450     /* Check the parameters */
;;;1451     assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
;;;1452     
;;;1453     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1454   
;;;1455     /* Clear PLLSAIDIVR[2:0] bits */
;;;1456     tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
000004  f4213140          BIC      r1,r1,#0x30000
;;;1457   
;;;1458     /* Set PLLSAIDIVR values */
;;;1459     tmpreg |= RCC_PLLSAIDivR;
000008  4301              ORRS     r1,r1,r0
;;;1460   
;;;1461     /* Store the new value */
;;;1462     RCC->DCKCFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;1463   }
00000c  4770              BX       lr
;;;1464   
                          ENDP

00000e  0000              DCW      0x0000
                  |L34.16|
                          DCD      0x4002388c

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;695      */
;;;696    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4a03              LDR      r2,|L35.16|
;;;697    {
;;;698      uint32_t tmpreg = 0;
;;;699      
;;;700      /* Check the parameters */
;;;701      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;702      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;703    
;;;704      tmpreg = RCC->CFGR;
000002  6813              LDR      r3,[r2,#0]
;;;705    
;;;706      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;707      tmpreg &= CFGR_MCO1_RESET_MASK;
;;;708    
;;;709      /* Select MCO1 clock source and prescaler */
;;;710      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
000004  4308              ORRS     r0,r0,r1
000006  f02363ec          BIC      r3,r3,#0x7600000      ;707
00000a  4318              ORRS     r0,r0,r3
;;;711    
;;;712      /* Store the new value */
;;;713      RCC->CFGR = tmpreg;  
00000c  6010              STR      r0,[r2,#0]
;;;714    }
00000e  4770              BX       lr
;;;715    
                          ENDP

                  |L35.16|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;733      */
;;;734    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4a03              LDR      r2,|L36.16|
;;;735    {
;;;736      uint32_t tmpreg = 0;
;;;737      
;;;738      /* Check the parameters */
;;;739      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;740      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;741      
;;;742      tmpreg = RCC->CFGR;
000002  6813              LDR      r3,[r2,#0]
;;;743      
;;;744      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;745      tmpreg &= CFGR_MCO2_RESET_MASK;
;;;746    
;;;747      /* Select MCO2 clock source and prescaler */
;;;748      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000004  4308              ORRS     r0,r0,r1
000006  f0234378          BIC      r3,r3,#0xf8000000     ;745
00000a  4318              ORRS     r0,r0,r3
;;;749    
;;;750      /* Store the new value */
;;;751      RCC->CFGR = tmpreg;  
00000c  6010              STR      r0,[r2,#0]
;;;752    }
00000e  4770              BX       lr
;;;753    
                          ENDP

                  |L36.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;1013     */
;;;1014   void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L37.16|
;;;1015   {
;;;1016     uint32_t tmpreg = 0;
;;;1017   
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;1020   
;;;1021     tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1022   
;;;1023     /* Clear PPRE1[2:0] bits */
;;;1024     tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42151e0          BIC      r1,r1,#0x1c00
;;;1025   
;;;1026     /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;1027     tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;1028   
;;;1029     /* Store the new value */
;;;1030     RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;1031   }
00000c  4770              BX       lr
;;;1032   
                          ENDP

00000e  0000              DCW      0x0000
                  |L37.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;1044     */
;;;1045   void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L38.16|
;;;1046   {
;;;1047     uint32_t tmpreg = 0;
;;;1048   
;;;1049     /* Check the parameters */
;;;1050     assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;1051   
;;;1052     tmpreg = RCC->CFGR;
000002  680a              LDR      r2,[r1,#0]
;;;1053   
;;;1054     /* Clear PPRE2[2:0] bits */
;;;1055     tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4224260          BIC      r2,r2,#0xe000
;;;1056   
;;;1057     /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;1058     tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;1059   
;;;1060     /* Store the new value */
;;;1061     RCC->CFGR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;1062   }
00000e  4770              BX       lr
;;;1063   
                          ENDP

                  |L38.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;484      */
;;;485    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L39.8|
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;489      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;490    }
000004  4770              BX       lr
;;;491    
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;461      */
;;;462    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  ea411182          ORR      r1,r1,r2,LSL #6
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;466      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;467      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;468      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;469      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;470    
;;;471      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000004  085a              LSRS     r2,r3,#1
000006  b510              PUSH     {r4,lr}               ;463
000008  4b05              LDR      r3,|L40.32|
00000a  9c02              LDR      r4,[sp,#8]
00000c  eb034202          ADD      r2,r3,r2,LSL #16
000010  4311              ORRS     r1,r1,r2
000012  4301              ORRS     r1,r1,r0
000014  ea416004          ORR      r0,r1,r4,LSL #24
000018  4902              LDR      r1,|L40.36|
00001a  6008              STR      r0,[r1,#0]
;;;472                     (PLLQ << 24);
;;;473    }
00001c  bd10              POP      {r4,pc}
;;;474    
                          ENDP

00001e  0000              DCW      0x0000
                  |L40.32|
                          DCD      0xffff0000
                  |L40.36|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;605      */
;;;606    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L41.8|
;;;607    {
;;;608      /* Check the parameters */
;;;609      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;610      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;611    }
000004  4770              BX       lr
;;;612    
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;514      */
;;;515    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  0180              LSLS     r0,r0,#6
;;;516    {
;;;517      /* Check the parameters */
;;;518      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;519      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;520    
;;;521      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000002  ea407001          ORR      r0,r0,r1,LSL #28
000006  4901              LDR      r1,|L42.12|
000008  6008              STR      r0,[r1,#0]
;;;522    }
00000a  4770              BX       lr
;;;523    
                          ENDP

                  |L42.12|
                          DCD      0x40023884

                          AREA ||i.RCC_PLLSAICmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAICmd PROC
;;;652      */
;;;653    void RCC_PLLSAICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L43.8|
;;;654    {
;;;655      /* Check the parameters */
;;;656      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;657      *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
000002  6708              STR      r0,[r1,#0x70]
;;;658    }
000004  4770              BX       lr
;;;659    
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLSAIConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAIConfig PROC
;;;634      */
;;;635    void RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR)
000000  0180              LSLS     r0,r0,#6
;;;636    {
;;;637      /* Check the parameters */
;;;638      assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
;;;639      assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));
;;;640    
;;;641      RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
000002  ea406001          ORR      r0,r0,r1,LSL #24
000006  4902              LDR      r1,|L44.16|
000008  ea407002          ORR      r0,r0,r2,LSL #28
00000c  6008              STR      r0,[r1,#0]
;;;642    }
00000e  4770              BX       lr
;;;643    
                          ENDP

                  |L44.16|
                          DCD      0x40023888

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1253     */
;;;1254   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L45.8|
;;;1255   {
;;;1256     /* Check the parameters */
;;;1257     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1258   
;;;1259     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1260   }
000004  4770              BX       lr
;;;1261   
                          ENDP

000006  0000              DCW      0x0000
                  |L45.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1221     */
;;;1222   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  f3c02101          UBFX     r1,r0,#8,#2
;;;1223   {
;;;1224     uint32_t tmpreg = 0;
;;;1225   
;;;1226     /* Check the parameters */
;;;1227     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1228   
;;;1229     if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000004  2903              CMP      r1,#3
000006  d107              BNE      |L46.24|
;;;1230     { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;1231       tmpreg = RCC->CFGR;
000008  4a07              LDR      r2,|L46.40|
00000a  6811              LDR      r1,[r2,#0]
;;;1232   
;;;1233       /* Clear RTCPRE[4:0] bits */
;;;1234       tmpreg &= ~RCC_CFGR_RTCPRE;
00000c  f42113f8          BIC      r3,r1,#0x1f0000
;;;1235   
;;;1236       /* Configure HSE division factor for RTC clock */
;;;1237       tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
000010  4906              LDR      r1,|L46.44|
000012  4001              ANDS     r1,r1,r0
000014  4319              ORRS     r1,r1,r3
;;;1238   
;;;1239       /* Store the new value */
;;;1240       RCC->CFGR = tmpreg;
000016  6011              STR      r1,[r2,#0]
                  |L46.24|
;;;1241     }
;;;1242       
;;;1243     /* Select the RTC clock source */
;;;1244     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
000018  4903              LDR      r1,|L46.40|
00001a  3168              ADDS     r1,r1,#0x68
00001c  680a              LDR      r2,[r1,#0]
00001e  f3c0000b          UBFX     r0,r0,#0,#12
000022  4302              ORRS     r2,r2,r0
000024  600a              STR      r2,[r1,#0]
;;;1245   }
000026  4770              BX       lr
;;;1246   
                          ENDP

                  |L46.40|
                          DCD      0x40023808
                  |L46.44|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SAIBlockACLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIBlockACLKConfig PROC
;;;1376     */
;;;1377   void RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource)
000000  4a03              LDR      r2,|L47.16|
;;;1378   {
;;;1379     uint32_t tmpreg = 0;
;;;1380     
;;;1381     /* Check the parameters */
;;;1382     assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
;;;1383     
;;;1384     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1385   
;;;1386     /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
;;;1387     tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
000004  f4211140          BIC      r1,r1,#0x300000
;;;1388   
;;;1389     /* Set SAI Block A source selection value */
;;;1390     tmpreg |= RCC_SAIBlockACLKSource;
000008  4301              ORRS     r1,r1,r0
;;;1391   
;;;1392     /* Store the new value */
;;;1393     RCC->DCKCFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;1394   }
00000c  4770              BX       lr
;;;1395   
                          ENDP

00000e  0000              DCW      0x0000
                  |L47.16|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIBlockBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIBlockBCLKConfig PROC
;;;1412     */
;;;1413   void RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource)
000000  4a03              LDR      r2,|L48.16|
;;;1414   {
;;;1415     uint32_t tmpreg = 0;
;;;1416     
;;;1417     /* Check the parameters */
;;;1418     assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
;;;1419     
;;;1420     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1421   
;;;1422     /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
;;;1423     tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
000004  f4210140          BIC      r1,r1,#0xc00000
;;;1424   
;;;1425     /* Set SAI Block B source selection value */
;;;1426     tmpreg |= RCC_SAIBlockBCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;1427   
;;;1428     /* Store the new value */
;;;1429     RCC->DCKCFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;1430   }
00000c  4770              BX       lr
;;;1431   
                          ENDP

00000e  0000              DCW      0x0000
                  |L48.16|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLI2SClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLI2SClkDivConfig PROC
;;;1308     */
;;;1309   void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
000000  4a03              LDR      r2,|L49.16|
;;;1310   {
;;;1311     uint32_t tmpreg = 0;
;;;1312     
;;;1313     /* Check the parameters */
;;;1314     assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
;;;1315     
;;;1316     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1317   
;;;1318     /* Clear PLLI2SDIVQ[4:0] bits */
;;;1319     tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
000004  1e40              SUBS     r0,r0,#1
000006  f021011f          BIC      r1,r1,#0x1f
;;;1320   
;;;1321     /* Set PLLI2SDIVQ values */
;;;1322     tmpreg |= (RCC_PLLI2SDivQ - 1);
00000a  4301              ORRS     r1,r1,r0
;;;1323   
;;;1324     /* Store the new value */
;;;1325     RCC->DCKCFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;1326   }
00000e  4770              BX       lr
;;;1327   
                          ENDP

                  |L49.16|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLSAIClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLSAIClkDivConfig PROC
;;;1340     */
;;;1341   void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
000000  4905              LDR      r1,|L50.24|
;;;1342   {
;;;1343     uint32_t tmpreg = 0;
;;;1344     
;;;1345     /* Check the parameters */
;;;1346     assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
;;;1347     
;;;1348     tmpreg = RCC->DCKCFGR;
000002  680a              LDR      r2,[r1,#0]
;;;1349   
;;;1350     /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
;;;1351     tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
;;;1352   
;;;1353     /* Set PLLSAIDIVQ values */
;;;1354     tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
000004  f06f03ff          MVN      r3,#0xff
000008  f42252f8          BIC      r2,r2,#0x1f00         ;1351
00000c  eb032000          ADD      r0,r3,r0,LSL #8
000010  4310              ORRS     r0,r0,r2
;;;1355   
;;;1356     /* Store the new value */
;;;1357     RCC->DCKCFGR = tmpreg;
000012  6008              STR      r0,[r1,#0]
;;;1358   }
000014  4770              BX       lr
;;;1359   
                          ENDP

000016  0000              DCW      0x0000
                  |L50.24|
                          DCD      0x4002388c

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;928      */
;;;929    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L51.16|
;;;930    {
;;;931      uint32_t tmpreg = 0;
;;;932    
;;;933      /* Check the parameters */
;;;934      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;935    
;;;936      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;937    
;;;938      /* Clear SW[1:0] bits */
;;;939      tmpreg &= ~RCC_CFGR_SW;
000004  f0210103          BIC      r1,r1,#3
;;;940    
;;;941      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;942      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;943    
;;;944      /* Store the new value */
;;;945      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;946    }
00000c  4770              BX       lr
;;;947    
                          ENDP

00000e  0000              DCW      0x0000
                  |L51.16|
                          DCD      0x40023808

                          AREA ||i.RCC_TIMCLKPresConfig||, CODE, READONLY, ALIGN=2

                  RCC_TIMCLKPresConfig PROC
;;;1482     */
;;;1483   void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
000000  4901              LDR      r1,|L52.8|
;;;1484   {
;;;1485     /* Check the parameters */
;;;1486     assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
;;;1487   
;;;1488     *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
000002  f8c101e0          STR      r0,[r1,#0x1e0]
;;;1489     
;;;1490   }
000006  4770              BX       lr
;;;1491   
                          ENDP

                  |L52.8|
                          DCD      0x42471000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;286      */
;;;287    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b518              PUSH     {r3,r4,lr}
;;;288    {
;;;289      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
;;;290      ErrorStatus status = ERROR;
;;;291      FlagStatus hsestatus = RESET;
;;;292      /* Wait till HSE is ready and if Time out is reached exit */
;;;293      do
;;;294      {
;;;295        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;296        startupcounter++;
;;;297      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
000004  f44f44a0          MOV      r4,#0x5000
000008  9000              STR      r0,[sp,#0]
                  |L53.10|
00000a  2031              MOVS     r0,#0x31              ;295
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;296
000012  1c49              ADDS     r1,r1,#1              ;296
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L53.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L53.10|
                  |L53.30|
;;;298    
;;;299      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2031              MOVS     r0,#0x31
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L53.42|
;;;300      {
;;;301        status = SUCCESS;
000028  2001              MOVS     r0,#1
                  |L53.42|
;;;302      }
;;;303      else
;;;304      {
;;;305        status = ERROR;
;;;306      }
;;;307      return (status);
;;;308    }
00002a  bd18              POP      {r3,r4,pc}
;;;309    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 144
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
