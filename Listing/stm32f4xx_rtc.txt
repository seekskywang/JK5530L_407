; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_rtc.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_rtc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=538 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\stm32f4xx_rtc.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1309     */
;;;1310   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1311   {
;;;1312     __IO uint32_t alarmcounter = 0x00;
000002  2200              MOVS     r2,#0
;;;1313     uint32_t alarmstatus = 0x00;
;;;1314     ErrorStatus status = ERROR;
;;;1315       
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1318     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1319   
;;;1320     /* Disable the write protection for RTC registers */
;;;1321     RTC->WPR = 0xCA;
000004  4b12              LDR      r3,|L1.80|
000006  9200              STR      r2,[sp,#0]
000008  22ca              MOVS     r2,#0xca
00000a  601a              STR      r2,[r3,#0]
;;;1322     RTC->WPR = 0x53;
00000c  2253              MOVS     r2,#0x53
00000e  601a              STR      r2,[r3,#0]
;;;1323   
;;;1324     /* Configure the Alarm state */
;;;1325     if (NewState != DISABLE)
;;;1326     {
;;;1327       RTC->CR |= (uint32_t)RTC_Alarm;
000010  4a0f              LDR      r2,|L1.80|
000012  3a1c              SUBS     r2,r2,#0x1c
000014  2900              CMP      r1,#0                 ;1325
;;;1328   
;;;1329       status = SUCCESS;    
;;;1330     }
;;;1331     else
;;;1332     { 
;;;1333       /* Disable the Alarm in RTC_CR register */
;;;1334       RTC->CR &= (uint32_t)~RTC_Alarm;
000016  6811              LDR      r1,[r2,#0]
000018  d002              BEQ      |L1.32|
00001a  4301              ORRS     r1,r1,r0              ;1327
00001c  6011              STR      r1,[r2,#0]            ;1327
00001e  e012              B        |L1.70|
                  |L1.32|
000020  4381              BICS     r1,r1,r0
000022  6011              STR      r1,[r2,#0]
;;;1335      
;;;1336       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1337       do
;;;1338       {
;;;1339         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
000024  4a0a              LDR      r2,|L1.80|
000026  3a18              SUBS     r2,r2,#0x18
;;;1340         alarmcounter++;  
;;;1341       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
000028  1395              ASRS     r5,r2,#14
                  |L1.42|
00002a  6811              LDR      r1,[r2,#0]            ;1339
00002c  9c00              LDR      r4,[sp,#0]            ;1340
00002e  ea012110          AND      r1,r1,r0,LSR #8       ;1339
000032  1c64              ADDS     r4,r4,#1              ;1340
000034  9400              STR      r4,[sp,#0]
000036  42ac              CMP      r4,r5
000038  d001              BEQ      |L1.62|
00003a  2900              CMP      r1,#0
00003c  d0f5              BEQ      |L1.42|
                  |L1.62|
;;;1342       
;;;1343       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
00003e  6811              LDR      r1,[r2,#0]
000040  ea112010          ANDS     r0,r1,r0,LSR #8
000044  d000              BEQ      |L1.72|
                  |L1.70|
;;;1344       {
;;;1345         status = ERROR;
;;;1346       } 
;;;1347       else
;;;1348       {
;;;1349         status = SUCCESS;
000046  2001              MOVS     r0,#1
                  |L1.72|
;;;1350       }        
;;;1351     } 
;;;1352   
;;;1353     /* Enable the write protection for RTC registers */
;;;1354     RTC->WPR = 0xFF; 
000048  21ff              MOVS     r1,#0xff
00004a  6019              STR      r1,[r3,#0]
;;;1355     
;;;1356     return status;
;;;1357   }
00004c  bd38              POP      {r3-r5,pc}
;;;1358   
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40002824

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1225     */
;;;1226   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1227   {
;;;1228     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1229     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1230     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1231     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1232     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1233   
;;;1234     /* Alarm Date Settings : Date = 1st day of the month */
;;;1235     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1236     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000a  2201              MOVS     r2,#1
00000c  6081              STR      r1,[r0,#8]
00000e  7302              STRB     r2,[r0,#0xc]
;;;1237   
;;;1238     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1239     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  6041              STR      r1,[r0,#4]
;;;1240   }
000012  4770              BX       lr
;;;1241   
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1403     */
;;;1404   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000000  b510              PUSH     {r4,lr}
;;;1405   {
;;;1406     uint32_t tmpreg = 0;
;;;1407   
;;;1408     /* Check the parameters */
;;;1409     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1410     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1411     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1412     
;;;1413     /* Disable the write protection for RTC registers */
;;;1414     RTC->WPR = 0xCA;
000002  4b09              LDR      r3,|L3.40|
000004  24ca              MOVS     r4,#0xca
000006  601c              STR      r4,[r3,#0]
;;;1415     RTC->WPR = 0x53;
000008  2453              MOVS     r4,#0x53
00000a  601c              STR      r4,[r3,#0]
;;;1416     
;;;1417     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;1418     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
00000c  4311              ORRS     r1,r1,r2
;;;1419     
;;;1420     if (RTC_Alarm == RTC_Alarm_A)
00000e  f5b07f80          CMP      r0,#0x100
000012  d005              BEQ      |L3.32|
;;;1421     {
;;;1422       /* Configure the Alarm A Sub Second register */
;;;1423       RTC->ALRMASSR = tmpreg;
;;;1424     }
;;;1425     else
;;;1426     {
;;;1427       /* Configure the Alarm B Sub Second register */
;;;1428       RTC->ALRMBSSR = tmpreg;
000014  4804              LDR      r0,|L3.40|
000016  3024              ADDS     r0,r0,#0x24
                  |L3.24|
000018  6001              STR      r1,[r0,#0]
;;;1429     }
;;;1430   
;;;1431     /* Enable the write protection for RTC registers */
;;;1432     RTC->WPR = 0xFF;
00001a  20ff              MOVS     r0,#0xff
00001c  6018              STR      r0,[r3,#0]
;;;1433   
;;;1434   }
00001e  bd10              POP      {r4,pc}
                  |L3.32|
000020  4801              LDR      r0,|L3.40|
000022  3020              ADDS     r0,r0,#0x20           ;1423
000024  e7f8              B        |L3.24|
;;;1435   
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40002824

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2741     */
;;;2742   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;2743   {
;;;2744     uint8_t tmp = 0;
;;;2745     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000002  eb010181          ADD      r1,r1,r1,LSL #2
;;;2746     return (tmp + (Value & (uint8_t)0x0F));
000006  f000000f          AND      r0,r0,#0xf
00000a  eb000041          ADD      r0,r0,r1,LSL #1
00000e  b2c0              UXTB     r0,r0
;;;2747   }
000010  4770              BX       lr
;;;2748   
                          ENDP


                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;709    */
;;;710    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L5.40|
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;714    
;;;715      /* Disable the write protection for RTC registers */
;;;716      RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;717      RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;718      
;;;719      if (NewState != DISABLE)
;;;720      {
;;;721        /* Set the BYPSHAD bit */
;;;722        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00000a  4907              LDR      r1,|L5.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;719
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Reset the BYPSHAD bit */
;;;727        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L5.26|
000014  f0400020          ORR      r0,r0,#0x20           ;722
000018  e001              B        |L5.30|
                  |L5.26|
00001a  f00000df          AND      r0,r0,#0xdf
                  |L5.30|
00001e  6008              STR      r0,[r1,#0]
;;;728      }
;;;729    
;;;730      /* Enable the write protection for RTC registers */
;;;731      RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;732    }
000024  4770              BX       lr
;;;733    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x40002824

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2723     */
;;;2724   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;2725   {
000002  e003              B        |L6.12|
                  |L6.4|
000004  1c49              ADDS     r1,r1,#1
;;;2726     uint8_t bcdhigh = 0;
;;;2727     
;;;2728     while (Value >= 10)
;;;2729     {
;;;2730       bcdhigh++;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c9              UXTB     r1,r1
;;;2731       Value -= 10;
00000a  b2c0              UXTB     r0,r0
                  |L6.12|
00000c  280a              CMP      r0,#0xa               ;2728
00000e  d2f9              BCS      |L6.4|
;;;2732     }
;;;2733     
;;;2734     return  ((uint8_t)(bcdhigh << 4) | Value);
000010  0709              LSLS     r1,r1,#28
000012  ea406011          ORR      r0,r0,r1,LSR #24
;;;2735   }
000016  4770              BX       lr
;;;2736   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1837     */
;;;1838   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L7.40|
;;;1839   {
;;;1840     /* Check the parameters */
;;;1841     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1842     
;;;1843     /* Disable the write protection for RTC registers */
;;;1844     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1845     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1846     
;;;1847     if (NewState != DISABLE)
;;;1848     {
;;;1849       /* Enable the RTC clock output */
;;;1850       RTC->CR |= (uint32_t)RTC_CR_COE;
00000a  4907              LDR      r1,|L7.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;1847
;;;1851     }
;;;1852     else
;;;1853     { 
;;;1854       /* Disable the RTC clock output */
;;;1855       RTC->CR &= (uint32_t)~RTC_CR_COE;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L7.26|
000014  f4400000          ORR      r0,r0,#0x800000       ;1850
000018  e001              B        |L7.30|
                  |L7.26|
00001a  f4200000          BIC      r0,r0,#0x800000
                  |L7.30|
00001e  6008              STR      r0,[r1,#0]
;;;1856     }
;;;1857     
;;;1858     /* Enable the write protection for RTC registers */
;;;1859     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;1860   }
000024  4770              BX       lr
;;;1861   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40002824

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1869   */
;;;1870   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  4a08              LDR      r2,|L8.36|
;;;1871   {
;;;1872     /* Check the parameters */
;;;1873     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1874   
;;;1875     /* Disable the write protection for RTC registers */
;;;1876     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1877     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1878     
;;;1879     /*clear flags before configuration */
;;;1880     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
00000a  4906              LDR      r1,|L8.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f4232300          BIC      r3,r3,#0x80000
000014  600b              STR      r3,[r1,#0]
;;;1881   
;;;1882     /* Configure the RTC_CR register */
;;;1883     RTC->CR |= (uint32_t)RTC_CalibOutput;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1884   
;;;1885     /* Enable the write protection for RTC registers */
;;;1886     RTC->WPR = 0xFF;
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1887   }
000020  4770              BX       lr
;;;1888   
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40002824

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2640     */
;;;2641   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  b280              UXTH     r0,r0
;;;2642   {
;;;2643     /* Check the parameters */
;;;2644     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2645   
;;;2646     /* Clear the Flags in the RTC_ISR register */
;;;2647     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
000002  f0400080          ORR      r0,r0,#0x80
000006  43c1              MVNS     r1,r0
000008  4803              LDR      r0,|L9.24|
00000a  6802              LDR      r2,[r0,#0]
00000c  f0020280          AND      r2,r2,#0x80
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;2648   }
000014  4770              BX       lr
;;;2649   
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2700     */
;;;2701   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  f3c0100f          UBFX     r0,r0,#4,#16
;;;2702   {
;;;2703     uint32_t tmpreg = 0;
;;;2704   
;;;2705     /* Check the parameters */
;;;2706     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2707   
;;;2708     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2709     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2710   
;;;2711     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2712     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000004  f0400080          ORR      r0,r0,#0x80
000008  43c1              MVNS     r1,r0
00000a  4803              LDR      r0,|L10.24|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0020280          AND      r2,r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;2713   }
000016  4770              BX       lr
;;;2714   
                          ENDP

                  |L10.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibCmd||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibCmd PROC
;;;1791     */
;;;1792   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1793   {
;;;1794     ErrorStatus status = ERROR;
;;;1795     
;;;1796     /* Check the parameters */
;;;1797     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1798   
;;;1799     /* Disable the write protection for RTC registers */
;;;1800     RTC->WPR = 0xCA;
000002  4c0d              LDR      r4,|L11.56|
000004  4606              MOV      r6,r0                 ;1793
000006  2500              MOVS     r5,#0                 ;1794
000008  20ca              MOVS     r0,#0xca
00000a  6020              STR      r0,[r4,#0]
;;;1801     RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6020              STR      r0,[r4,#0]
;;;1802     
;;;1803     /* Set Initialization mode */
;;;1804     if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b160              CBZ      r0,|L11.48|
;;;1805     {
;;;1806       status =  ERROR;
;;;1807     }
;;;1808     else
;;;1809     {
;;;1810       if (NewState != DISABLE)
;;;1811       {
;;;1812         /* Enable the Coarse Calibration */
;;;1813         RTC->CR |= (uint32_t)RTC_CR_DCE;
000016  4808              LDR      r0,|L11.56|
000018  381c              SUBS     r0,r0,#0x1c
;;;1814       }
;;;1815       else
;;;1816       { 
;;;1817         /* Disable the Coarse Calibration */
;;;1818         RTC->CR &= (uint32_t)~RTC_CR_DCE;
00001a  6801              LDR      r1,[r0,#0]
00001c  b116              CBZ      r6,|L11.36|
00001e  f0410180          ORR      r1,r1,#0x80           ;1813
000022  e001              B        |L11.40|
                  |L11.36|
000024  f0210180          BIC      r1,r1,#0x80
                  |L11.40|
000028  6001              STR      r1,[r0,#0]
;;;1819       }
;;;1820       /* Exit Initialization mode */
;;;1821       RTC_ExitInitMode();
00002a  f7fffffe          BL       RTC_ExitInitMode
;;;1822       
;;;1823       status = SUCCESS;
00002e  2501              MOVS     r5,#1
                  |L11.48|
;;;1824     } 
;;;1825     
;;;1826     /* Enable the write protection for RTC registers */
;;;1827     RTC->WPR = 0xFF; 
000030  20ff              MOVS     r0,#0xff
000032  6020              STR      r0,[r4,#0]
;;;1828     
;;;1829     return status;
000034  4628              MOV      r0,r5
;;;1830   }
000036  bd70              POP      {r4-r6,pc}
;;;1831   
                          ENDP

                  |L11.56|
                          DCD      0x40002824

                          AREA ||i.RTC_CoarseCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibConfig PROC
;;;1750     */
;;;1751   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1752   {
;;;1753     ErrorStatus status = ERROR;
;;;1754      
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1757     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1758   
;;;1759     /* Disable the write protection for RTC registers */
;;;1760     RTC->WPR = 0xCA;
000002  4c0b              LDR      r4,|L12.48|
000004  4606              MOV      r6,r0                 ;1752
000006  2500              MOVS     r5,#0                 ;1753
000008  20ca              MOVS     r0,#0xca
00000a  460f              MOV      r7,r1                 ;1752
00000c  6020              STR      r0,[r4,#0]
;;;1761     RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6020              STR      r0,[r4,#0]
;;;1762   
;;;1763     /* Set Initialization mode */
;;;1764     if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b130              CBZ      r0,|L12.38|
;;;1765     {
;;;1766       status = ERROR;
;;;1767     } 
;;;1768     else
;;;1769     {
;;;1770       /* Set the coarse calibration value */
;;;1771       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
000018  4805              LDR      r0,|L12.48|
00001a  433e              ORRS     r6,r6,r7
00001c  380c              SUBS     r0,r0,#0xc
00001e  6006              STR      r6,[r0,#0]
;;;1772       /* Exit Initialization mode */
;;;1773       RTC_ExitInitMode();
000020  f7fffffe          BL       RTC_ExitInitMode
;;;1774       
;;;1775       status = SUCCESS;
000024  2501              MOVS     r5,#1
                  |L12.38|
;;;1776     } 
;;;1777   
;;;1778     /* Enable the write protection for RTC registers */
;;;1779     RTC->WPR = 0xFF; 
000026  20ff              MOVS     r0,#0xff
000028  6020              STR      r0,[r4,#0]
;;;1780     
;;;1781     return status;
00002a  4628              MOV      r0,r5
;;;1782   }
00002c  bdf0              POP      {r4-r7,pc}
;;;1783   
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40002824

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;1035     */
;;;1036   void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;1037   {
;;;1038     /* Monday, January 01 xx00 */
;;;1039     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;1040     RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;1041     RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;1042     RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;1043   }
00000c  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1630     */
;;;1631   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  4b09              LDR      r3,|L14.40|
;;;1632   {
000002  b510              PUSH     {r4,lr}
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1635     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1636   
;;;1637     /* Disable the write protection for RTC registers */
;;;1638     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1639     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1640   
;;;1641     /* Clear the bits to be configured */
;;;1642     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000c  4a06              LDR      r2,|L14.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f4242480          BIC      r4,r4,#0x40000
000016  6014              STR      r4,[r2,#0]
;;;1643   
;;;1644     /* Configure the RTC_CR register */
;;;1645     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1646   
;;;1647     /* Enable the write protection for RTC registers */
;;;1648     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1649   }
000024  bd10              POP      {r4,pc}
;;;1650   
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      0x40002824

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;374      */
;;;375    ErrorStatus RTC_DeInit(void)
000000  b578              PUSH     {r3-r6,lr}
;;;376    {
;;;377      __IO uint32_t wutcounter = 0x00;
000002  2400              MOVS     r4,#0
;;;378      uint32_t wutwfstatus = 0x00;
;;;379      ErrorStatus status = ERROR;
;;;380      
;;;381      /* Disable the write protection for RTC registers */
;;;382      RTC->WPR = 0xCA;
000004  4e28              LDR      r6,|L15.168|
000006  20ca              MOVS     r0,#0xca
000008  9400              STR      r4,[sp,#0]
00000a  4625              MOV      r5,r4                 ;379
00000c  6030              STR      r0,[r6,#0]
;;;383      RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6030              STR      r0,[r6,#0]
;;;384    
;;;385      /* Set Initialization mode */
;;;386      if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b3e0              CBZ      r0,|L15.146|
;;;387      {
;;;388        status = ERROR;
;;;389      }  
;;;390      else
;;;391      {
;;;392        /* Reset TR, DR and CR registers */
;;;393        RTC->TR = (uint32_t)0x00000000;
000018  4823              LDR      r0,|L15.168|
00001a  3824              SUBS     r0,r0,#0x24
00001c  6004              STR      r4,[r0,#0]
;;;394        RTC->DR = (uint32_t)0x00002101;
00001e  4922              LDR      r1,|L15.168|
000020  f2421001          MOV      r0,#0x2101
000024  3920              SUBS     r1,r1,#0x20
000026  6008              STR      r0,[r1,#0]
;;;395        /* Reset All CR bits except CR[2:0] */
;;;396        RTC->CR &= (uint32_t)0x00000007;
000028  1d09              ADDS     r1,r1,#4
00002a  6808              LDR      r0,[r1,#0]
00002c  f0000007          AND      r0,r0,#7
000030  6008              STR      r0,[r1,#0]
;;;397      
;;;398        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;399        do
;;;400        {
;;;401          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
;;;402          wutcounter++;  
;;;403        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
000032  138d              ASRS     r5,r1,#14
000034  1d08              ADDS     r0,r1,#4              ;401
                  |L15.54|
000036  6802              LDR      r2,[r0,#0]            ;401
000038  9b00              LDR      r3,[sp,#0]            ;402
00003a  f0020204          AND      r2,r2,#4              ;401
00003e  1c5b              ADDS     r3,r3,#1              ;402
000040  9300              STR      r3,[sp,#0]
000042  42ab              CMP      r3,r5
000044  d001              BEQ      |L15.74|
000046  2a00              CMP      r2,#0
000048  d0f5              BEQ      |L15.54|
                  |L15.74|
;;;404        
;;;405        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
00004a  6802              LDR      r2,[r0,#0]
00004c  0752              LSLS     r2,r2,#29
00004e  d529              BPL      |L15.164|
;;;406        {
;;;407          status = ERROR;
;;;408        }
;;;409        else
;;;410        {
;;;411          /* Reset all RTC CR register bits */
;;;412          RTC->CR &= (uint32_t)0x00000000;
000050  680a              LDR      r2,[r1,#0]
000052  600c              STR      r4,[r1,#0]
;;;413          RTC->WUTR = (uint32_t)0x0000FFFF;
000054  4a14              LDR      r2,|L15.168|
000056  f64f71ff          MOV      r1,#0xffff
00005a  3a10              SUBS     r2,r2,#0x10
00005c  6011              STR      r1,[r2,#0]
;;;414          RTC->PRER = (uint32_t)0x007F00FF;
00005e  1f12              SUBS     r2,r2,#4
000060  4912              LDR      r1,|L15.172|
000062  6011              STR      r1,[r2,#0]
;;;415          RTC->CALIBR = (uint32_t)0x00000000;
000064  4910              LDR      r1,|L15.168|
000066  390c              SUBS     r1,r1,#0xc
000068  600c              STR      r4,[r1,#0]
;;;416          RTC->ALRMAR = (uint32_t)0x00000000;        
00006a  1d09              ADDS     r1,r1,#4
00006c  600c              STR      r4,[r1,#0]
;;;417          RTC->ALRMBR = (uint32_t)0x00000000;
00006e  1d09              ADDS     r1,r1,#4
000070  600c              STR      r4,[r1,#0]
;;;418          RTC->SHIFTR = (uint32_t)0x00000000;
000072  490d              LDR      r1,|L15.168|
000074  3108              ADDS     r1,r1,#8
000076  600c              STR      r4,[r1,#0]
;;;419          RTC->CALR = (uint32_t)0x00000000;
000078  490b              LDR      r1,|L15.168|
00007a  3118              ADDS     r1,r1,#0x18
00007c  600c              STR      r4,[r1,#0]
;;;420          RTC->ALRMASSR = (uint32_t)0x00000000;
00007e  490a              LDR      r1,|L15.168|
000080  3120              ADDS     r1,r1,#0x20
000082  600c              STR      r4,[r1,#0]
;;;421          RTC->ALRMBSSR = (uint32_t)0x00000000;
000084  1d09              ADDS     r1,r1,#4
000086  600c              STR      r4,[r1,#0]
;;;422          
;;;423          /* Reset ISR register and exit initialization mode */
;;;424          RTC->ISR = (uint32_t)0x00000000;
000088  6004              STR      r4,[r0,#0]
;;;425          
;;;426          /* Reset Tamper and alternate functions configuration register */
;;;427          RTC->TAFCR = 0x00000000;
00008a  4807              LDR      r0,|L15.168|
00008c  301c              ADDS     r0,r0,#0x1c
00008e  6004              STR      r4,[r0,#0]
;;;428      
;;;429          if(RTC_WaitForSynchro() == ERROR)
000090  e000              B        |L15.148|
                  |L15.146|
000092  e003              B        |L15.156|
                  |L15.148|
000094  f7fffffe          BL       RTC_WaitForSynchro
000098  b120              CBZ      r0,|L15.164|
;;;430          {
;;;431            status = ERROR;
;;;432          }
;;;433          else
;;;434          {
;;;435            status = SUCCESS;      
00009a  2501              MOVS     r5,#1
                  |L15.156|
;;;436          }
;;;437        }
;;;438      }
;;;439      
;;;440      /* Enable the write protection for RTC registers */
;;;441      RTC->WPR = 0xFF;  
00009c  20ff              MOVS     r0,#0xff
00009e  6030              STR      r0,[r6,#0]
;;;442      
;;;443      return status;
0000a0  4628              MOV      r0,r5
;;;444    }
0000a2  bd78              POP      {r3-r6,pc}
                  |L15.164|
0000a4  2500              MOVS     r5,#0                 ;431
0000a6  e7f9              B        |L15.156|
;;;445    
                          ENDP

                  |L15.168|
                          DCD      0x40002824
                  |L15.172|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;551      */
;;;552    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;553    {
;;;554      __IO uint32_t initcounter = 0x00;
000002  2000              MOVS     r0,#0
;;;555      ErrorStatus status = ERROR;
;;;556      uint32_t initstatus = 0x00;
;;;557         
;;;558      /* Check if the Initialization mode is set */
;;;559      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000004  9000              STR      r0,[sp,#0]
000006  480c              LDR      r0,|L16.56|
000008  6801              LDR      r1,[r0,#0]
00000a  0649              LSLS     r1,r1,#25
00000c  d412              BMI      |L16.52|
;;;560      {
;;;561        /* Set the Initialization mode */
;;;562        RTC->ISR = (uint32_t)RTC_INIT_MASK;
00000e  f04f31ff          MOV      r1,#0xffffffff
000012  6001              STR      r1,[r0,#0]
;;;563        
;;;564        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;565        do
;;;566        {
;;;567          initstatus = RTC->ISR & RTC_ISR_INITF;
;;;568          initcounter++;  
;;;569        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000014  1383              ASRS     r3,r0,#14
                  |L16.22|
000016  6801              LDR      r1,[r0,#0]            ;567
000018  9a00              LDR      r2,[sp,#0]            ;568
00001a  f0010140          AND      r1,r1,#0x40           ;567
00001e  1c52              ADDS     r2,r2,#1              ;568
000020  9200              STR      r2,[sp,#0]
000022  429a              CMP      r2,r3
000024  d001              BEQ      |L16.42|
000026  2900              CMP      r1,#0
000028  d0f5              BEQ      |L16.22|
                  |L16.42|
;;;570        
;;;571        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00002a  6800              LDR      r0,[r0,#0]
00002c  0640              LSLS     r0,r0,#25
00002e  d401              BMI      |L16.52|
;;;572        {
;;;573          status = SUCCESS;
;;;574        }
;;;575        else
;;;576        {
;;;577          status = ERROR;
000030  2000              MOVS     r0,#0
;;;578        }        
;;;579      }
;;;580      else
;;;581      {
;;;582        status = SUCCESS;  
;;;583      } 
;;;584        
;;;585      return (status);  
;;;586    }
000032  bd08              POP      {r3,pc}
                  |L16.52|
000034  2001              MOVS     r0,#1                 ;582
000036  bd08              POP      {r3,pc}
;;;587    
                          ENDP

                  |L16.56|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;596      */
;;;597    void RTC_ExitInitMode(void)
000000  4802              LDR      r0,|L17.12|
;;;598    { 
;;;599      /* Exit Initialization mode */
;;;600      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
000002  6801              LDR      r1,[r0,#0]
000004  f0210180          BIC      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;601    }
00000a  4770              BX       lr
;;;602    
                          ENDP

                  |L17.12|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1255     */
;;;1256   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b510              PUSH     {r4,lr}
;;;1257   {
000002  4614              MOV      r4,r2
;;;1258     uint32_t tmpreg = 0;
;;;1259   
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1262     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1263   
;;;1264     /* Get the RTC_ALRMxR register */
;;;1265     if (RTC_Alarm == RTC_Alarm_A)
000004  f5b17f80          CMP      r1,#0x100
000008  d02a              BEQ      |L18.96|
;;;1266     {
;;;1267       tmpreg = (uint32_t)(RTC->ALRMAR);
;;;1268     }
;;;1269     else
;;;1270     {
;;;1271       tmpreg = (uint32_t)(RTC->ALRMBR);
00000a  4917              LDR      r1,|L18.104|
                  |L18.12|
00000c  6809              LDR      r1,[r1,#0]
;;;1272     }
;;;1273   
;;;1274     /* Fill the structure with the read parameters */
;;;1275     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
00000e  f3c14205          UBFX     r2,r1,#16,#6
000012  7022              STRB     r2,[r4,#0]
;;;1276                                                        RTC_ALRMAR_HU)) >> 16);
;;;1277     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000014  f3c12306          UBFX     r3,r1,#8,#7
000018  7063              STRB     r3,[r4,#1]
;;;1278                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1279     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
00001a  f001037f          AND      r3,r1,#0x7f
00001e  70a3              STRB     r3,[r4,#2]
;;;1280                                                        RTC_ALRMAR_SU));
;;;1281     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000020  2340              MOVS     r3,#0x40
000022  ea034311          AND      r3,r3,r1,LSR #16
000026  70e3              STRB     r3,[r4,#3]
;;;1282     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
000028  f3c16305          UBFX     r3,r1,#24,#6
00002c  7323              STRB     r3,[r4,#0xc]
;;;1283     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00002e  f0014380          AND      r3,r1,#0x40000000
;;;1284     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000032  f0013180          AND      r1,r1,#0x80808080
000036  e9c41301          STRD     r1,r3,[r4,#4]
00003a  2800              CMP      r0,#0
00003c  d10f              BNE      |L18.94|
00003e  4610              MOV      r0,r2
;;;1285   
;;;1286     if (RTC_Format == RTC_Format_BIN)
;;;1287     {
;;;1288       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000040  f7fffffe          BL       RTC_Bcd2ToByte
000044  7020              STRB     r0,[r4,#0]
;;;1289                                                           RTC_AlarmTime.RTC_Hours);
;;;1290       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000046  7860              LDRB     r0,[r4,#1]
000048  f7fffffe          BL       RTC_Bcd2ToByte
00004c  7060              STRB     r0,[r4,#1]
;;;1291                                                           RTC_AlarmTime.RTC_Minutes);
;;;1292       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00004e  78a0              LDRB     r0,[r4,#2]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  70a0              STRB     r0,[r4,#2]
;;;1293                                                           RTC_AlarmTime.RTC_Seconds);
;;;1294       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000056  7b20              LDRB     r0,[r4,#0xc]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7320              STRB     r0,[r4,#0xc]
                  |L18.94|
;;;1295     }  
;;;1296   }
00005e  bd10              POP      {r4,pc}
                  |L18.96|
000060  4901              LDR      r1,|L18.104|
000062  1f09              SUBS     r1,r1,#4              ;1267
000064  e7d2              B        |L18.12|
;;;1297   
                          ENDP

000066  0000              DCW      0x0000
                  |L18.104|
                          DCD      0x40002820

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1444     */
;;;1445   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  f5b07f80          CMP      r0,#0x100
;;;1446   {
000004  d004              BEQ      |L19.16|
;;;1447     uint32_t tmpreg = 0;
;;;1448     
;;;1449     /* Get the RTC_ALRMxR register */
;;;1450     if (RTC_Alarm == RTC_Alarm_A)
;;;1451     {
;;;1452       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
;;;1453     }
;;;1454     else
;;;1455     {
;;;1456       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
000006  4804              LDR      r0,|L19.24|
                  |L19.8|
000008  6800              LDR      r0,[r0,#0]            ;1452
00000a  f3c0000e          UBFX     r0,r0,#0,#15          ;1452
;;;1457     } 
;;;1458     
;;;1459     return (tmpreg);
;;;1460   }
00000e  4770              BX       lr
                  |L19.16|
000010  4801              LDR      r0,|L19.24|
000012  1f00              SUBS     r0,r0,#4              ;1452
000014  e7f8              B        |L19.8|
;;;1461   
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      0x40002848

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;1054     */
;;;1055   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b510              PUSH     {r4,lr}
;;;1056   {
000002  460c              MOV      r4,r1
;;;1057     uint32_t tmpreg = 0;
;;;1058   
;;;1059     /* Check the parameters */
;;;1060     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1061     
;;;1062     /* Get the RTC_TR register */
;;;1063     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000004  490e              LDR      r1,|L20.64|
000006  6809              LDR      r1,[r1,#0]
000008  4a0e              LDR      r2,|L20.68|
00000a  4011              ANDS     r1,r1,r2
;;;1064   
;;;1065     /* Fill the structure fields with the read parameters */
;;;1066     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
00000c  0c0a              LSRS     r2,r1,#16
00000e  70e2              STRB     r2,[r4,#3]
;;;1067     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000010  f3c12304          UBFX     r3,r1,#8,#5
000014  7063              STRB     r3,[r4,#1]
;;;1068     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
000016  f001033f          AND      r3,r1,#0x3f
00001a  70a3              STRB     r3,[r4,#2]
;;;1069     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
00001c  f3c13142          UBFX     r1,r1,#13,#3
000020  7021              STRB     r1,[r4,#0]
000022  2800              CMP      r0,#0                 ;1056
000024  d10b              BNE      |L20.62|
000026  4610              MOV      r0,r2                 ;1056
;;;1070   
;;;1071     /* Check the input parameters format */
;;;1072     if (RTC_Format == RTC_Format_BIN)
;;;1073     {
;;;1074       /* Convert the structure parameters to Binary format */
;;;1075       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
000028  f7fffffe          BL       RTC_Bcd2ToByte
00002c  70e0              STRB     r0,[r4,#3]
;;;1076       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  7060              STRB     r0,[r4,#1]
;;;1077       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000036  78a0              LDRB     r0,[r4,#2]
000038  f7fffffe          BL       RTC_Bcd2ToByte
00003c  70a0              STRB     r0,[r4,#2]
                  |L20.62|
;;;1078     }
;;;1079   }
00003e  bd10              POP      {r4,pc}
;;;1080   
                          ENDP

                  |L20.64|
                          DCD      0x40002804
                  |L20.68|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2604     */
;;;2605   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  4904              LDR      r1,|L21.20|
;;;2606   {
000002  4602              MOV      r2,r0
;;;2607     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2608     uint32_t tmpreg = 0;
;;;2609     
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2612     
;;;2613     /* Get all the flags */
;;;2614     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000006  6809              LDR      r1,[r1,#0]
000008  4b03              LDR      r3,|L21.24|
00000a  4019              ANDS     r1,r1,r3
;;;2615     
;;;2616     /* Return the status of the flag */
;;;2617     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
00000c  4211              TST      r1,r2
00000e  d000              BEQ      |L21.18|
;;;2618     {
;;;2619       bitstatus = SET;
000010  2001              MOVS     r0,#1
                  |L21.18|
;;;2620     }
;;;2621     else
;;;2622     {
;;;2623       bitstatus = RESET;
;;;2624     }
;;;2625     return bitstatus;
;;;2626   }
000012  4770              BX       lr
;;;2627   
                          ENDP

                  |L21.20|
                          DCD      0x4000280c
                  |L21.24|
                          DCD      0x00013f7f

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2660     */
;;;2661   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  4a0b              LDR      r2,|L22.48|
;;;2662   {
;;;2663     ITStatus bitstatus = RESET;
000002  2100              MOVS     r1,#0
;;;2664     uint32_t tmpreg = 0, enablestatus = 0;
;;;2665    
;;;2666     /* Check the parameters */
;;;2667     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2668     
;;;2669     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2670     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
000004  6812              LDR      r2,[r2,#0]
000006  f0020304          AND      r3,r2,#4
;;;2671    
;;;2672     /* Get the Interrupt enable Status */
;;;2673     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
00000a  4a09              LDR      r2,|L22.48|
00000c  3a38              SUBS     r2,r2,#0x38
00000e  6812              LDR      r2,[r2,#0]
000010  ea0333d0          AND      r3,r3,r0,LSR #15
000014  4002              ANDS     r2,r2,r0
000016  431a              ORRS     r2,r2,r3
;;;2674     
;;;2675     /* Get the Interrupt pending bit */
;;;2676     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000018  4b06              LDR      r3,|L22.52|
00001a  681b              LDR      r3,[r3,#0]
00001c  ea031010          AND      r0,r3,r0,LSR #4
000020  d003              BEQ      |L22.42|
;;;2677     
;;;2678     /* Get the status of the Interrupt */
;;;2679     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
000022  0400              LSLS     r0,r0,#16
000024  0c00              LSRS     r0,r0,#16
000026  d000              BEQ      |L22.42|
;;;2680     {
;;;2681       bitstatus = SET;
000028  2101              MOVS     r1,#1
                  |L22.42|
;;;2682     }
;;;2683     else
;;;2684     {
;;;2685       bitstatus = RESET;
;;;2686     }
;;;2687     return bitstatus;
00002a  4608              MOV      r0,r1
;;;2688   }
00002c  4770              BX       lr
;;;2689   
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      0x40002840
                  |L22.52|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1657     */
;;;1658   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L23.12|
;;;1659   {
;;;1660     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1661   }
000008  4770              BX       lr
;;;1662   
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;919      */
;;;920    uint32_t RTC_GetSubSecond(void)
000000  4802              LDR      r0,|L24.12|
;;;921    {
;;;922      uint32_t tmpreg = 0;
;;;923      
;;;924      /* Get sub seconds values from the correspondent registers*/
;;;925      tmpreg = (uint32_t)(RTC->SSR);
000002  6800              LDR      r0,[r0,#0]
;;;926      
;;;927      /* Read DR register to unfroze calendar registers */
;;;928      (void) (RTC->DR);
000004  4901              LDR      r1,|L24.12|
000006  3924              SUBS     r1,r1,#0x24
000008  6809              LDR      r1,[r1,#0]
;;;929      
;;;930      return (tmpreg);
;;;931    }
00000a  4770              BX       lr
;;;932    
                          ENDP

                  |L24.12|
                          DCD      0x40002828

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;886      */
;;;887    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b510              PUSH     {r4,lr}
;;;888    {
000002  460c              MOV      r4,r1
;;;889      uint32_t tmpreg = 0;
;;;890    
;;;891      /* Check the parameters */
;;;892      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;893    
;;;894      /* Get the RTC_TR register */
;;;895      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000004  490f              LDR      r1,|L25.68|
000006  6809              LDR      r1,[r1,#0]
000008  4a0f              LDR      r2,|L25.72|
00000a  4011              ANDS     r1,r1,r2
;;;896      
;;;897      /* Fill the structure fields with the read parameters */
;;;898      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00000c  f3c14205          UBFX     r2,r1,#16,#6
000010  7022              STRB     r2,[r4,#0]
;;;899      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000012  f3c12306          UBFX     r3,r1,#8,#7
000016  7063              STRB     r3,[r4,#1]
;;;900      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
000018  f001037f          AND      r3,r1,#0x7f
00001c  70a3              STRB     r3,[r4,#2]
;;;901      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
00001e  2340              MOVS     r3,#0x40
000020  ea034111          AND      r1,r3,r1,LSR #16
000024  70e1              STRB     r1,[r4,#3]
000026  2800              CMP      r0,#0                 ;888
000028  d10b              BNE      |L25.66|
00002a  4610              MOV      r0,r2                 ;888
;;;902    
;;;903      /* Check the input parameters format */
;;;904      if (RTC_Format == RTC_Format_BIN)
;;;905      {
;;;906        /* Convert the structure parameters to Binary format */
;;;907        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002c  f7fffffe          BL       RTC_Bcd2ToByte
000030  7020              STRB     r0,[r4,#0]
;;;908        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000032  7860              LDRB     r0,[r4,#1]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  7060              STRB     r0,[r4,#1]
;;;909        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  70a0              STRB     r0,[r4,#2]
                  |L25.66|
;;;910      }
;;;911    }
000042  bd10              POP      {r4,pc}
;;;912    
                          ENDP

                  |L25.68|
                          DCD      0x40002800
                  |L25.72|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;2025     */
;;;2026   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  b570              PUSH     {r4-r6,lr}
;;;2027                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;2028   {
000002  460d              MOV      r5,r1
;;;2029     uint32_t tmptime = 0, tmpdate = 0;
;;;2030   
;;;2031     /* Check the parameters */
;;;2032     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;2033   
;;;2034     /* Get the TimeStamp time and date registers values */
;;;2035     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
000004  491e              LDR      r1,|L26.128|
000006  4614              MOV      r4,r2                 ;2028
000008  6809              LDR      r1,[r1,#0]
00000a  4a1e              LDR      r2,|L26.132|
00000c  4011              ANDS     r1,r1,r2
;;;2036     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
00000e  4a1c              LDR      r2,|L26.128|
000010  1d12              ADDS     r2,r2,#4
000012  6812              LDR      r2,[r2,#0]
000014  f64f733f          MOV      r3,#0xff3f
000018  401a              ANDS     r2,r2,r3
;;;2037   
;;;2038     /* Fill the Time structure fields with the read parameters */
;;;2039     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00001a  f3c14305          UBFX     r3,r1,#16,#6
00001e  702b              STRB     r3,[r5,#0]
;;;2040     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
000020  f3c12306          UBFX     r3,r1,#8,#7
000024  706b              STRB     r3,[r5,#1]
;;;2041     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000026  f001037f          AND      r3,r1,#0x7f
00002a  70ab              STRB     r3,[r5,#2]
;;;2042     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
00002c  2340              MOVS     r3,#0x40
00002e  ea034111          AND      r1,r3,r1,LSR #16
000032  70e9              STRB     r1,[r5,#3]
;;;2043   
;;;2044     /* Fill the Date structure fields with the read parameters */
;;;2045     RTC_StampDateStruct->RTC_Year = 0;
000034  2100              MOVS     r1,#0
000036  70e1              STRB     r1,[r4,#3]
;;;2046     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000038  f3c22104          UBFX     r1,r2,#8,#5
00003c  7061              STRB     r1,[r4,#1]
;;;2047     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
00003e  f002013f          AND      r1,r2,#0x3f
000042  70a1              STRB     r1,[r4,#2]
;;;2048     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000044  f3c23142          UBFX     r1,r2,#13,#3
000048  7021              STRB     r1,[r4,#0]
00004a  2800              CMP      r0,#0                 ;2028
00004c  d117              BNE      |L26.126|
;;;2049   
;;;2050     /* Check the input parameters format */
;;;2051     if (RTC_Format == RTC_Format_BIN)
;;;2052     {
;;;2053       /* Convert the Time structure parameters to Binary format */
;;;2054       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
00004e  7828              LDRB     r0,[r5,#0]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  7028              STRB     r0,[r5,#0]
;;;2055       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000056  7868              LDRB     r0,[r5,#1]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7068              STRB     r0,[r5,#1]
;;;2056       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
00005e  78a8              LDRB     r0,[r5,#2]
000060  f7fffffe          BL       RTC_Bcd2ToByte
000064  70a8              STRB     r0,[r5,#2]
;;;2057   
;;;2058       /* Convert the Date structure parameters to Binary format */
;;;2059       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000066  7860              LDRB     r0,[r4,#1]
000068  f7fffffe          BL       RTC_Bcd2ToByte
00006c  7060              STRB     r0,[r4,#1]
;;;2060       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
00006e  78a0              LDRB     r0,[r4,#2]
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  70a0              STRB     r0,[r4,#2]
;;;2061       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000076  7820              LDRB     r0,[r4,#0]
000078  f7fffffe          BL       RTC_Bcd2ToByte
00007c  7020              STRB     r0,[r4,#0]
                  |L26.126|
;;;2062     }
;;;2063   }
00007e  bd70              POP      {r4-r6,pc}
;;;2064   
                          ENDP

                  |L26.128|
                          DCD      0x40002830
                  |L26.132|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;2069     */
;;;2070   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L27.8|
;;;2071   {
;;;2072     /* Get timestamp sub seconds values from the correspondent registers */
;;;2073     return (uint32_t)(RTC->TSSSR);
000002  6800              LDR      r0,[r0,#0]
;;;2074   }
000004  4770              BX       lr
;;;2075   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40002838

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1541     */
;;;1542   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L28.8|
;;;1543   {
;;;1544     /* Get the counter value */
;;;1545     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1546   }
000006  4770              BX       lr
;;;1547   
                          ENDP

                  |L28.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2556     */
;;;2557   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;2558   {
;;;2559     /* Check the parameters */
;;;2560     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2562   
;;;2563     /* Disable the write protection for RTC registers */
;;;2564     RTC->WPR = 0xCA;
000002  4d0e              LDR      r5,|L29.60|
000004  22ca              MOVS     r2,#0xca
000006  602a              STR      r2,[r5,#0]
;;;2565     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  602a              STR      r2,[r5,#0]
;;;2566   
;;;2567     if (NewState != DISABLE)
;;;2568     {
;;;2569       /* Configure the Interrupts in the RTC_CR register */
;;;2570       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
00000c  4b0b              LDR      r3,|L29.60|
;;;2571       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2572       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00000e  4a0b              LDR      r2,|L29.60|
000010  3b1c              SUBS     r3,r3,#0x1c           ;2570
000012  321c              ADDS     r2,r2,#0x1c
000014  2900              CMP      r1,#0                 ;2567
000016  f0200404          BIC      r4,r0,#4              ;2570
;;;2573     }
;;;2574     else
;;;2575     {
;;;2576       /* Configure the Interrupts in the RTC_CR register */
;;;2577       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
00001a  6819              LDR      r1,[r3,#0]
00001c  f0000004          AND      r0,r0,#4              ;2572
000020  d004              BEQ      |L29.44|
000022  4321              ORRS     r1,r1,r4              ;2570
000024  6019              STR      r1,[r3,#0]            ;2570
000026  6811              LDR      r1,[r2,#0]            ;2572
000028  4301              ORRS     r1,r1,r0              ;2572
00002a  e003              B        |L29.52|
                  |L29.44|
00002c  43a1              BICS     r1,r1,r4
00002e  6019              STR      r1,[r3,#0]
;;;2578       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2579       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000030  6811              LDR      r1,[r2,#0]
000032  4381              BICS     r1,r1,r0
                  |L29.52|
000034  6011              STR      r1,[r2,#0]
;;;2580     }
;;;2581     /* Enable the write protection for RTC registers */
;;;2582     RTC->WPR = 0xFF; 
000036  20ff              MOVS     r0,#0xff
000038  6028              STR      r0,[r5,#0]
;;;2583   }
00003a  bd30              POP      {r4,r5,pc}
;;;2584   
                          ENDP

                  |L29.60|
                          DCD      0x40002824

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;456      */
;;;457    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;458    {
;;;459      ErrorStatus status = ERROR;
;;;460      
;;;461      /* Check the parameters */
;;;462      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;463      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;464      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;465    
;;;466      /* Disable the write protection for RTC registers */
;;;467      RTC->WPR = 0xCA;
000002  4d12              LDR      r5,|L30.76|
000004  4604              MOV      r4,r0                 ;458
000006  2600              MOVS     r6,#0                 ;459
000008  20ca              MOVS     r0,#0xca
00000a  6028              STR      r0,[r5,#0]
;;;468      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6028              STR      r0,[r5,#0]
;;;469    
;;;470      /* Set Initialization mode */
;;;471      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b1a8              CBZ      r0,|L30.66|
;;;472      {
;;;473        status = ERROR;
;;;474      } 
;;;475      else
;;;476      {
;;;477        /* Clear RTC CR FMT Bit */
;;;478        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000016  480d              LDR      r0,|L30.76|
000018  381c              SUBS     r0,r0,#0x1c
00001a  6801              LDR      r1,[r0,#0]
00001c  f0210140          BIC      r1,r1,#0x40
000020  6001              STR      r1,[r0,#0]
;;;479        /* Set RTC_CR register */
;;;480        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000022  6801              LDR      r1,[r0,#0]
000024  6822              LDR      r2,[r4,#0]
000026  4311              ORRS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;481      
;;;482        /* Configure the RTC PRER */
;;;483        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
00002a  4808              LDR      r0,|L30.76|
00002c  68a1              LDR      r1,[r4,#8]
00002e  3814              SUBS     r0,r0,#0x14
000030  6001              STR      r1,[r0,#0]
;;;484        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000032  6801              LDR      r1,[r0,#0]
000034  88a2              LDRH     r2,[r4,#4]
000036  ea414102          ORR      r1,r1,r2,LSL #16
00003a  6001              STR      r1,[r0,#0]
;;;485    
;;;486        /* Exit Initialization mode */
;;;487        RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;488    
;;;489        status = SUCCESS;    
000040  2601              MOVS     r6,#1
                  |L30.66|
;;;490      }
;;;491      /* Enable the write protection for RTC registers */
;;;492      RTC->WPR = 0xFF; 
000042  20ff              MOVS     r0,#0xff
000044  6028              STR      r0,[r5,#0]
;;;493      
;;;494      return status;
000046  4630              MOV      r0,r6
;;;495    }
000048  bd70              POP      {r4-r6,pc}
;;;496    
                          ENDP

00004a  0000              DCW      0x0000
                  |L30.76|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1696     */
;;;1697   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  4b09              LDR      r3,|L31.40|
;;;1698   {
000002  b510              PUSH     {r4,lr}
;;;1699     /* Check the parameters */
;;;1700     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1701     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1702   
;;;1703     /* Disable the write protection for RTC registers */
;;;1704     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1705     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1706   
;;;1707     /* Clear the bits to be configured */
;;;1708     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000c  4a06              LDR      r2,|L31.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f42404e0          BIC      r4,r4,#0x700000
000016  6014              STR      r4,[r2,#0]
;;;1709   
;;;1710     /* Configure the output selection and polarity */
;;;1711     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1712   
;;;1713     /* Enable the write protection for RTC registers */
;;;1714     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1715   }
000024  bd10              POP      {r4,pc}
;;;1716   
                          ENDP

000026  0000              DCW      0x0000
                  |L31.40|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;2398     */
;;;2399   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4904              LDR      r1,|L32.20|
;;;2400   {
;;;2401     /* Check the parameters */
;;;2402     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2403     
;;;2404     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  680a              LDR      r2,[r1,#0]
000004  f4222280          BIC      r2,r2,#0x40000
000008  600a              STR      r2,[r1,#0]
;;;2405     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2406   }
000010  4770              BX       lr
;;;2407   
                          ENDP

000012  0000              DCW      0x0000
                  |L32.20|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;2323     */
;;;2324   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  b508              PUSH     {r3,lr}
;;;2325   {
;;;2326     __IO uint32_t tmp = 0;
;;;2327     
;;;2328     /* Check the parameters */
;;;2329     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2330   
;;;2331     tmp = RTC_BASE + 0x50;
000002  4903              LDR      r1,|L33.16|
;;;2332     tmp += (RTC_BKP_DR * 4);
000004  eb010080          ADD      r0,r1,r0,LSL #2
;;;2333     
;;;2334     /* Read the specified register */
;;;2335     return (*(__IO uint32_t *)tmp);
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
;;;2336   }
00000c  bd08              POP      {r3,pc}
;;;2337   
                          ENDP

00000e  0000              DCW      0x0000
                  |L33.16|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;661      */
;;;662    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;663    { 
;;;664      ErrorStatus status = ERROR;
;;;665      
;;;666      /* Check the parameters */
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;668      
;;;669      /* Disable the write protection for RTC registers */
;;;670      RTC->WPR = 0xCA;
000002  4c0d              LDR      r4,|L34.56|
000004  4606              MOV      r6,r0                 ;663
000006  2500              MOVS     r5,#0                 ;664
000008  20ca              MOVS     r0,#0xca
00000a  6020              STR      r0,[r4,#0]
;;;671      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6020              STR      r0,[r4,#0]
;;;672        
;;;673      /* Set Initialization mode */
;;;674      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b160              CBZ      r0,|L34.48|
;;;675      {
;;;676        status = ERROR;
;;;677      } 
;;;678      else
;;;679      {  
;;;680        if (NewState != DISABLE)
;;;681        {
;;;682          /* Enable the RTC reference clock detection */
;;;683          RTC->CR |= RTC_CR_REFCKON;   
000016  4808              LDR      r0,|L34.56|
000018  381c              SUBS     r0,r0,#0x1c
;;;684        }
;;;685        else
;;;686        {
;;;687          /* Disable the RTC reference clock detection */
;;;688          RTC->CR &= ~RTC_CR_REFCKON;    
00001a  6801              LDR      r1,[r0,#0]
00001c  b116              CBZ      r6,|L34.36|
00001e  f0410110          ORR      r1,r1,#0x10           ;683
000022  e001              B        |L34.40|
                  |L34.36|
000024  f0210110          BIC      r1,r1,#0x10
                  |L34.40|
000028  6001              STR      r1,[r0,#0]
;;;689        }
;;;690        /* Exit Initialization mode */
;;;691        RTC_ExitInitMode();
00002a  f7fffffe          BL       RTC_ExitInitMode
;;;692        
;;;693        status = SUCCESS;
00002e  2501              MOVS     r5,#1
                  |L34.48|
;;;694      }
;;;695      
;;;696      /* Enable the write protection for RTC registers */
;;;697      RTC->WPR = 0xFF;  
000030  20ff              MOVS     r0,#0xff
000032  6020              STR      r0,[r4,#0]
;;;698      
;;;699      return status; 
000034  4628              MOV      r0,r5
;;;700    }
000036  bd70              POP      {r4-r6,pc}
;;;701    
                          ENDP

                  |L34.56|
                          DCD      0x40002824

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1114     */
;;;1115   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1116   {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
;;;1117     uint32_t tmpreg = 0;
;;;1118     
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1121     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1122     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1123     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1124   
;;;1125     if (RTC_Format == RTC_Format_BIN)
;;;1126     {
;;;1127       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000006  4a26              LDR      r2,|L35.160|
000008  2100              MOVS     r1,#0                 ;1116
00000a  2800              CMP      r0,#0                 ;1125
;;;1128       {
;;;1129         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1130         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1131       } 
;;;1132       else
;;;1133       {
;;;1134         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1135         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1136       }
;;;1137       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1138       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1139       
;;;1140       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1141       {
;;;1142         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1147       }
;;;1148     }
;;;1149     else
;;;1150     {
;;;1151       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000c  6810              LDR      r0,[r2,#0]
00000e  ea4f6040          LSL      r0,r0,#25
000012  d005              BEQ      |L35.32|
000014  2800              CMP      r0,#0
000016  da1c              BGE      |L35.82|
;;;1152       {
;;;1153         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000018  7820              LDRB     r0,[r4,#0]
00001a  f7fffffe          BL       RTC_Bcd2ToByte
;;;1154         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1155         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00001e  e019              B        |L35.84|
                  |L35.32|
000020  2800              CMP      r0,#0                 ;1127
000022  db00              BLT      |L35.38|
000024  70e1              STRB     r1,[r4,#3]            ;1134
                  |L35.38|
;;;1156       } 
;;;1157       else
;;;1158       {
;;;1159         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1160         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
;;;1161       }
;;;1162       
;;;1163       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1164       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1165       
;;;1166       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1167       {
;;;1168         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1169         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1170       }
;;;1171       else
;;;1172       {
;;;1173         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1174         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
;;;1175       }    
;;;1176     }
;;;1177   
;;;1178     /* Check the input parameters format */
;;;1179     if (RTC_Format != RTC_Format_BIN)
;;;1180     {
;;;1181       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
;;;1182                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1183                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1184                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1185                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1186                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1187                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1188     }  
;;;1189     else
;;;1190     {
;;;1191       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000026  7820              LDRB     r0,[r4,#0]
000028  f7fffffe          BL       RTC_ByteToBcd2
00002c  0406              LSLS     r6,r0,#16
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_ByteToBcd2
000034  ea462600          ORR      r6,r6,r0,LSL #8
000038  78a0              LDRB     r0,[r4,#2]
00003a  f7fffffe          BL       RTC_ByteToBcd2
00003e  4306              ORRS     r6,r6,r0
000040  78e0              LDRB     r0,[r4,#3]
000042  ea464600          ORR      r6,r6,r0,LSL #16
000046  7b20              LDRB     r0,[r4,#0xc]
000048  f7fffffe          BL       RTC_ByteToBcd2
00004c  ea466000          ORR      r0,r6,r0,LSL #24
000050  e010              B        |L35.116|
                  |L35.82|
000052  70e1              STRB     r1,[r4,#3]            ;1159
                  |L35.84|
000054  7b20              LDRB     r0,[r4,#0xc]          ;1168
000056  f7fffffe          BL       RTC_Bcd2ToByte
00005a  78a0              LDRB     r0,[r4,#2]            ;1181
00005c  7821              LDRB     r1,[r4,#0]            ;1181
00005e  78e2              LDRB     r2,[r4,#3]            ;1181
000060  ea404001          ORR      r0,r0,r1,LSL #16      ;1181
000064  7861              LDRB     r1,[r4,#1]            ;1181
000066  0209              LSLS     r1,r1,#8              ;1181
000068  ea414102          ORR      r1,r1,r2,LSL #16      ;1181
00006c  4308              ORRS     r0,r0,r1              ;1181
00006e  7b21              LDRB     r1,[r4,#0xc]          ;1181
000070  ea406001          ORR      r0,r0,r1,LSL #24      ;1181
                  |L35.116|
000074  68a1              LDR      r1,[r4,#8]
;;;1192                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1193                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1194                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1195                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1196                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1197                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1198     } 
;;;1199   
;;;1200     /* Disable the write protection for RTC registers */
;;;1201     RTC->WPR = 0xCA;
000076  4a0a              LDR      r2,|L35.160|
000078  4308              ORRS     r0,r0,r1              ;1191
00007a  6861              LDR      r1,[r4,#4]            ;1191
00007c  4308              ORRS     r0,r0,r1              ;1191
00007e  21ca              MOVS     r1,#0xca
000080  321c              ADDS     r2,r2,#0x1c
000082  6011              STR      r1,[r2,#0]
;;;1202     RTC->WPR = 0x53;
000084  2153              MOVS     r1,#0x53
000086  6011              STR      r1,[r2,#0]
;;;1203   
;;;1204     /* Configure the Alarm register */
;;;1205     if (RTC_Alarm == RTC_Alarm_A)
000088  f5b57f80          CMP      r5,#0x100
00008c  d004              BEQ      |L35.152|
;;;1206     {
;;;1207       RTC->ALRMAR = (uint32_t)tmpreg;
;;;1208     }
;;;1209     else
;;;1210     {
;;;1211       RTC->ALRMBR = (uint32_t)tmpreg;
00008e  1f11              SUBS     r1,r2,#4
                  |L35.144|
000090  6008              STR      r0,[r1,#0]
;;;1212     }
;;;1213   
;;;1214     /* Enable the write protection for RTC registers */
;;;1215     RTC->WPR = 0xFF;   
000092  20ff              MOVS     r0,#0xff
000094  6010              STR      r0,[r2,#0]
;;;1216   }
000096  bd70              POP      {r4-r6,pc}
                  |L35.152|
000098  4901              LDR      r1,|L35.160|
00009a  3114              ADDS     r1,r1,#0x14           ;1207
00009c  e7f8              B        |L35.144|
;;;1217   
                          ENDP

00009e  0000              DCW      0x0000
                  |L35.160|
                          DCD      0x40002808

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;944      */
;;;945    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;946    {
000002  460c              MOV      r4,r1
000004  0001              MOVS     r1,r0
;;;947      uint32_t tmpreg = 0;
;;;948      ErrorStatus status = ERROR;
;;;949      
;;;950      /* Check the parameters */
;;;951      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;952    
;;;953      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
000006  7860              LDRB     r0,[r4,#1]
000008  f04f0600          MOV      r6,#0                 ;948
00000c  d02a              BEQ      |L36.100|
;;;954      {
;;;955        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;956      }  
;;;957      if (RTC_Format == RTC_Format_BIN)
;;;958      {
;;;959        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;960        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;961        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;962      }
;;;963      else
;;;964      {
;;;965        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;966        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00000e  f7fffffe          BL       RTC_Bcd2ToByte
;;;967        assert_param(IS_RTC_MONTH(tmpreg));
;;;968        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000012  78a0              LDRB     r0,[r4,#2]
000014  f7fffffe          BL       RTC_Bcd2ToByte
;;;969        assert_param(IS_RTC_DATE(tmpreg));
;;;970      }
;;;971      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;972    
;;;973      /* Check the input parameters format */
;;;974      if (RTC_Format != RTC_Format_BIN)
;;;975      {
;;;976        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
000018  78a0              LDRB     r0,[r4,#2]
00001a  78e1              LDRB     r1,[r4,#3]
00001c  ea404501          ORR      r5,r0,r1,LSL #16
000020  7860              LDRB     r0,[r4,#1]
000022  7821              LDRB     r1,[r4,#0]
000024  0200              LSLS     r0,r0,#8
000026  ea403041          ORR      r0,r0,r1,LSL #13
00002a  4305              ORRS     r5,r5,r0
                  |L36.44|
;;;977                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;978                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;979                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;980      }  
;;;981      else
;;;982      {
;;;983        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
;;;984                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;985                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;986                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;987      }
;;;988    
;;;989      /* Disable the write protection for RTC registers */
;;;990      RTC->WPR = 0xCA;
00002c  4c19              LDR      r4,|L36.148|
00002e  20ca              MOVS     r0,#0xca
000030  6020              STR      r0,[r4,#0]
;;;991      RTC->WPR = 0x53;
000032  2053              MOVS     r0,#0x53
000034  6020              STR      r0,[r4,#0]
;;;992    
;;;993      /* Set Initialization mode */
;;;994      if (RTC_EnterInitMode() == ERROR)
000036  f7fffffe          BL       RTC_EnterInitMode
00003a  b178              CBZ      r0,|L36.92|
;;;995      {
;;;996        status = ERROR;
;;;997      } 
;;;998      else
;;;999      {
;;;1000       /* Set the RTC_DR register */
;;;1001       RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
00003c  4816              LDR      r0,|L36.152|
00003e  4005              ANDS     r5,r5,r0
000040  4814              LDR      r0,|L36.148|
000042  3820              SUBS     r0,r0,#0x20
000044  6005              STR      r5,[r0,#0]
;;;1002   
;;;1003       /* Exit Initialization mode */
;;;1004       RTC_ExitInitMode(); 
000046  f7fffffe          BL       RTC_ExitInitMode
;;;1005   
;;;1006       /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;1007       if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
00004a  4812              LDR      r0,|L36.148|
00004c  381c              SUBS     r0,r0,#0x1c
00004e  6800              LDR      r0,[r0,#0]
000050  0680              LSLS     r0,r0,#26
000052  d402              BMI      |L36.90|
;;;1008       {
;;;1009       if(RTC_WaitForSynchro() == ERROR)
000054  f7fffffe          BL       RTC_WaitForSynchro
000058  b100              CBZ      r0,|L36.92|
                  |L36.90|
;;;1010       {
;;;1011         status = ERROR;
;;;1012       }
;;;1013       else
;;;1014       {
;;;1015         status = SUCCESS;
;;;1016       }
;;;1017     }
;;;1018       else
;;;1019       {
;;;1020         status = SUCCESS;
00005a  2601              MOVS     r6,#1
                  |L36.92|
;;;1021       }
;;;1022     }
;;;1023     /* Enable the write protection for RTC registers */
;;;1024     RTC->WPR = 0xFF;   
00005c  20ff              MOVS     r0,#0xff
00005e  6020              STR      r0,[r4,#0]
;;;1025     
;;;1026     return status;
000060  4630              MOV      r0,r6
;;;1027   }
000062  bd70              POP      {r4-r6,pc}
                  |L36.100|
000064  06c1              LSLS     r1,r0,#27             ;953
000066  d503              BPL      |L36.112|
000068  f0200010          BIC      r0,r0,#0x10           ;955
00006c  300a              ADDS     r0,r0,#0xa            ;955
00006e  7060              STRB     r0,[r4,#1]            ;955
                  |L36.112|
000070  78e0              LDRB     r0,[r4,#3]            ;983
000072  f7fffffe          BL       RTC_ByteToBcd2
000076  0405              LSLS     r5,r0,#16             ;983
000078  7860              LDRB     r0,[r4,#1]            ;983
00007a  f7fffffe          BL       RTC_ByteToBcd2
00007e  ea452500          ORR      r5,r5,r0,LSL #8       ;983
000082  78a0              LDRB     r0,[r4,#2]            ;983
000084  f7fffffe          BL       RTC_ByteToBcd2
000088  4305              ORRS     r5,r5,r0              ;983
00008a  7820              LDRB     r0,[r4,#0]            ;983
00008c  ea453540          ORR      r5,r5,r0,LSL #13      ;983
000090  e7cc              B        |L36.44|
;;;1028   
                          ENDP

000092  0000              DCW      0x0000
                  |L36.148|
                          DCD      0x40002824
                  |L36.152|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;764      */
;;;765    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;766    {
;;;767      uint32_t tmpreg = 0;
;;;768      ErrorStatus status = ERROR;
;;;769        
;;;770      /* Check the parameters */
;;;771      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;772      
;;;773      if (RTC_Format == RTC_Format_BIN)
;;;774      {
;;;775        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000004  4f24              LDR      r7,|L37.152|
000006  460c              MOV      r4,r1                 ;766
000008  0002              MOVS     r2,r0                 ;766
00000a  f04f0600          MOV      r6,#0                 ;768
;;;776        {
;;;777          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;778          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;779        } 
;;;780        else
;;;781        {
;;;782          RTC_TimeStruct->RTC_H12 = 0x00;
;;;783          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;784        }
;;;785        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;786        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;787      }
;;;788      else
;;;789      {
;;;790        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;791        {
;;;792          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00000e  7820              LDRB     r0,[r4,#0]
000010  683a              LDR      r2,[r7,#0]            ;790
000012  4631              MOV      r1,r6                 ;768
000014  ea4f6242          LSL      r2,r2,#25             ;790
000018  d004              BEQ      |L37.36|
00001a  2a00              CMP      r2,#0                 ;790
00001c  da15              BGE      |L37.74|
00001e  f7fffffe          BL       RTC_Bcd2ToByte
;;;793          assert_param(IS_RTC_HOUR12(tmpreg));
;;;794          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
000022  e013              B        |L37.76|
                  |L37.36|
000024  2a00              CMP      r2,#0                 ;775
000026  db00              BLT      |L37.42|
000028  70e1              STRB     r1,[r4,#3]            ;782
                  |L37.42|
;;;795        } 
;;;796        else
;;;797        {
;;;798          RTC_TimeStruct->RTC_H12 = 0x00;
;;;799          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;800        }
;;;801        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;802        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;803      }
;;;804      
;;;805      /* Check the input parameters format */
;;;806      if (RTC_Format != RTC_Format_BIN)
;;;807      {
;;;808        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
;;;809                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;810                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;811                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;812      }  
;;;813      else
;;;814      {
;;;815        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
00002a  f7fffffe          BL       RTC_ByteToBcd2
00002e  0405              LSLS     r5,r0,#16
000030  7860              LDRB     r0,[r4,#1]
000032  f7fffffe          BL       RTC_ByteToBcd2
000036  ea452500          ORR      r5,r5,r0,LSL #8
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_ByteToBcd2
000040  4305              ORRS     r5,r5,r0
000042  78e0              LDRB     r0,[r4,#3]
000044  ea454500          ORR      r5,r5,r0,LSL #16
000048  e00a              B        |L37.96|
                  |L37.74|
00004a  70e1              STRB     r1,[r4,#3]            ;798
                  |L37.76|
00004c  78a0              LDRB     r0,[r4,#2]            ;808
00004e  7821              LDRB     r1,[r4,#0]            ;808
000050  ea404501          ORR      r5,r0,r1,LSL #16      ;808
000054  7860              LDRB     r0,[r4,#1]            ;808
000056  78e1              LDRB     r1,[r4,#3]            ;808
000058  0200              LSLS     r0,r0,#8              ;808
00005a  ea404001          ORR      r0,r0,r1,LSL #16      ;808
00005e  4305              ORRS     r5,r5,r0              ;808
                  |L37.96|
;;;816                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;817                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;818                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;819      }  
;;;820    
;;;821      /* Disable the write protection for RTC registers */
;;;822      RTC->WPR = 0xCA;
000060  4c0d              LDR      r4,|L37.152|
000062  20ca              MOVS     r0,#0xca
000064  341c              ADDS     r4,r4,#0x1c
000066  6020              STR      r0,[r4,#0]
;;;823      RTC->WPR = 0x53;
000068  2053              MOVS     r0,#0x53
00006a  6020              STR      r0,[r4,#0]
;;;824    
;;;825      /* Set Initialization mode */
;;;826      if (RTC_EnterInitMode() == ERROR)
00006c  f7fffffe          BL       RTC_EnterInitMode
000070  b168              CBZ      r0,|L37.142|
;;;827      {
;;;828        status = ERROR;
;;;829      } 
;;;830      else
;;;831      {
;;;832        /* Set the RTC_TR register */
;;;833        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000072  480a              LDR      r0,|L37.156|
000074  4005              ANDS     r5,r5,r0
000076  4808              LDR      r0,|L37.152|
000078  3808              SUBS     r0,r0,#8
00007a  6005              STR      r5,[r0,#0]
;;;834    
;;;835        /* Exit Initialization mode */
;;;836        RTC_ExitInitMode(); 
00007c  f7fffffe          BL       RTC_ExitInitMode
;;;837    
;;;838        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;839        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
000080  6838              LDR      r0,[r7,#0]
000082  0680              LSLS     r0,r0,#26
000084  d402              BMI      |L37.140|
;;;840        {
;;;841        if(RTC_WaitForSynchro() == ERROR)
000086  f7fffffe          BL       RTC_WaitForSynchro
00008a  b100              CBZ      r0,|L37.142|
                  |L37.140|
;;;842        {
;;;843          status = ERROR;
;;;844        }
;;;845        else
;;;846        {
;;;847          status = SUCCESS;
;;;848        }
;;;849      }
;;;850        else
;;;851        {
;;;852          status = SUCCESS;
00008c  2601              MOVS     r6,#1
                  |L37.142|
;;;853        }
;;;854      }
;;;855      /* Enable the write protection for RTC registers */
;;;856      RTC->WPR = 0xFF; 
00008e  20ff              MOVS     r0,#0xff
000090  6020              STR      r0,[r4,#0]
;;;857        
;;;858      return status;
000092  4630              MOV      r0,r6
;;;859    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;860    
                          ENDP

                  |L37.152|
                          DCD      0x40002808
                  |L37.156|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1520     */
;;;1521   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  4905              LDR      r1,|L38.24|
;;;1522   {
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1525     
;;;1526     /* Disable the write protection for RTC registers */
;;;1527     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  600a              STR      r2,[r1,#0]
;;;1528     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  600a              STR      r2,[r1,#0]
;;;1529     
;;;1530     /* Configure the Wakeup Timer counter */
;;;1531     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00000a  4a03              LDR      r2,|L38.24|
00000c  3a10              SUBS     r2,r2,#0x10
00000e  6010              STR      r0,[r2,#0]
;;;1532     
;;;1533     /* Enable the write protection for RTC registers */
;;;1534     RTC->WPR = 0xFF; 
000010  20ff              MOVS     r0,#0xff
000012  6008              STR      r0,[r1,#0]
;;;1535   }
000014  4770              BX       lr
;;;1536   
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      0x40002824

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1905   */
;;;1906   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1907                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1908                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1909   {
;;;1910     ErrorStatus status = ERROR;
;;;1911     uint32_t recalpfcount = 0;
;;;1912   
;;;1913     /* Check the parameters */
;;;1914     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1915     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1916     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1917   
;;;1918     /* Disable the write protection for RTC registers */
;;;1919     RTC->WPR = 0xCA;
000002  4b11              LDR      r3,|L39.72|
000004  2400              MOVS     r4,#0                 ;1911
000006  25ca              MOVS     r5,#0xca
000008  601d              STR      r5,[r3,#0]
;;;1920     RTC->WPR = 0x53;
00000a  2553              MOVS     r5,#0x53
00000c  601d              STR      r5,[r3,#0]
;;;1921     
;;;1922     /* check if a calibration is pending*/
;;;1923     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
00000e  4d0e              LDR      r5,|L39.72|
000010  3d18              SUBS     r5,r5,#0x18
000012  682e              LDR      r6,[r5,#0]
000014  03f6              LSLS     r6,r6,#15
000016  d508              BPL      |L39.42|
;;;1924     {
;;;1925       /* wait until the Calibration is completed*/
;;;1926       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
000018  f44f3600          MOV      r6,#0x20000
                  |L39.28|
00001c  682f              LDR      r7,[r5,#0]
00001e  03ff              LSLS     r7,r7,#15
000020  d503              BPL      |L39.42|
000022  42b4              CMP      r4,r6
000024  d001              BEQ      |L39.42|
000026  1c64              ADDS     r4,r4,#1
;;;1927       {
;;;1928         recalpfcount++;
000028  e7f8              B        |L39.28|
                  |L39.42|
;;;1929       }
;;;1930     }
;;;1931   
;;;1932     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1933     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
00002a  682c              LDR      r4,[r5,#0]
00002c  03e4              LSLS     r4,r4,#15
00002e  d406              BMI      |L39.62|
;;;1934     {
;;;1935       /* Configure the Smooth calibration settings */
;;;1936       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
000030  4308              ORRS     r0,r0,r1
000032  4905              LDR      r1,|L39.72|
000034  4310              ORRS     r0,r0,r2
000036  3118              ADDS     r1,r1,#0x18
000038  6008              STR      r0,[r1,#0]
;;;1937   
;;;1938       status = SUCCESS;
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L39.64|
                  |L39.62|
;;;1939     }
;;;1940     else
;;;1941     {
;;;1942       status = ERROR;
00003e  2000              MOVS     r0,#0
                  |L39.64|
;;;1943     }
;;;1944   
;;;1945     /* Enable the write protection for RTC registers */
;;;1946     RTC->WPR = 0xFF;
000040  21ff              MOVS     r1,#0xff
000042  6019              STR      r1,[r3,#0]
;;;1947     
;;;1948     return (ErrorStatus)(status);
;;;1949   }
000044  bdf0              POP      {r4-r7,pc}
;;;1950   
                          ENDP

000046  0000              DCW      0x0000
                  |L39.72|
                          DCD      0x40002824

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;502      */
;;;503    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;504    {
;;;505      /* Initialize the RTC_HourFormat member */
;;;506      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;507        
;;;508      /* Initialize the RTC_AsynchPrediv member */
;;;509      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000002  6001              STR      r1,[r0,#0]
000004  217f              MOVS     r1,#0x7f
;;;510    
;;;511      /* Initialize the RTC_SynchPrediv member */
;;;512      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000006  6041              STR      r1,[r0,#4]
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;513    }
00000c  4770              BX       lr
;;;514    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;2436   */
;;;2437   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  b570              PUSH     {r4-r6,lr}
;;;2438   {
;;;2439     ErrorStatus status = ERROR;
;;;2440     uint32_t shpfcount = 0;
;;;2441   
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2444     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2445   
;;;2446     /* Disable the write protection for RTC registers */
;;;2447     RTC->WPR = 0xCA;
000002  4c14              LDR      r4,|L41.84|
000004  2200              MOVS     r2,#0                 ;2440
000006  23ca              MOVS     r3,#0xca
000008  6023              STR      r3,[r4,#0]
;;;2448     RTC->WPR = 0x53;
00000a  2353              MOVS     r3,#0x53
00000c  6023              STR      r3,[r4,#0]
;;;2449     
;;;2450     /* Check if a Shift is pending*/
;;;2451     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
00000e  4b11              LDR      r3,|L41.84|
000010  3b18              SUBS     r3,r3,#0x18
000012  681d              LDR      r5,[r3,#0]
000014  072d              LSLS     r5,r5,#28
000016  d507              BPL      |L41.40|
;;;2452     {
;;;2453       /* Wait until the shift is completed*/
;;;2454       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000018  149d              ASRS     r5,r3,#18
                  |L41.26|
00001a  681e              LDR      r6,[r3,#0]
00001c  0736              LSLS     r6,r6,#28
00001e  d503              BPL      |L41.40|
000020  42aa              CMP      r2,r5
000022  d001              BEQ      |L41.40|
000024  1c52              ADDS     r2,r2,#1
;;;2455       {
;;;2456         shpfcount++;
000026  e7f8              B        |L41.26|
                  |L41.40|
;;;2457       }
;;;2458     }
;;;2459   
;;;2460     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2461     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
000028  681a              LDR      r2,[r3,#0]
00002a  0712              LSLS     r2,r2,#28
00002c  d40d              BMI      |L41.74|
;;;2462     {
;;;2463       /* check if the reference clock detection is disabled */
;;;2464       if((RTC->CR & RTC_CR_REFCKON) == RESET)
00002e  4a09              LDR      r2,|L41.84|
000030  3a1c              SUBS     r2,r2,#0x1c
000032  6812              LDR      r2,[r2,#0]
000034  06d2              LSLS     r2,r2,#27
000036  d408              BMI      |L41.74|
;;;2465       {
;;;2466         /* Configure the Shift settings */
;;;2467         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
000038  4301              ORRS     r1,r1,r0
00003a  4806              LDR      r0,|L41.84|
00003c  3008              ADDS     r0,r0,#8
00003e  6001              STR      r1,[r0,#0]
;;;2468       
;;;2469         if(RTC_WaitForSynchro() == ERROR)
000040  f7fffffe          BL       RTC_WaitForSynchro
000044  b110              CBZ      r0,|L41.76|
;;;2470         {
;;;2471           status = ERROR;
;;;2472         }
;;;2473         else
;;;2474         {
;;;2475           status = SUCCESS;
000046  2001              MOVS     r0,#1
000048  e000              B        |L41.76|
                  |L41.74|
;;;2476         }
;;;2477       }
;;;2478       else
;;;2479       {
;;;2480         status = ERROR;
00004a  2000              MOVS     r0,#0
                  |L41.76|
;;;2481       }
;;;2482     }
;;;2483     else
;;;2484     {
;;;2485       status = ERROR;
;;;2486     }
;;;2487   
;;;2488     /* Enable the write protection for RTC registers */
;;;2489     RTC->WPR = 0xFF;
00004c  21ff              MOVS     r1,#0xff
00004e  6021              STR      r1,[r4,#0]
;;;2490     
;;;2491     return (ErrorStatus)(status);
;;;2492   }
000050  bd70              POP      {r4-r6,pc}
;;;2493   
                          ENDP

000052  0000              DCW      0x0000
                  |L41.84|
                          DCD      0x40002824

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;2130     */
;;;2131   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  4a04              LDR      r2,|L42.20|
;;;2132   {
;;;2133     /* Check the parameters */
;;;2134     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;2135     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2136     
;;;2137     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2138     {
;;;2139       /* Enable the selected Tamper pin */
;;;2140       RTC->TAFCR |= (uint32_t)RTC_Tamper;
;;;2141     }
;;;2142     else
;;;2143     {
;;;2144       /* Disable the selected Tamper pin */
;;;2145       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L42.12|
000008  4301              ORRS     r1,r1,r0              ;2140
00000a  e000              B        |L42.14|
                  |L42.12|
00000c  4381              BICS     r1,r1,r0
                  |L42.14|
00000e  6011              STR      r1,[r2,#0]            ;2140
;;;2146     }  
;;;2147   }
000010  4770              BX       lr
;;;2148   
                          ENDP

000012  0000              DCW      0x0000
                  |L42.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;2161     */
;;;2162   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  4904              LDR      r1,|L43.20|
;;;2163   {
;;;2164     /* Check the parameters */
;;;2165     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;2166      
;;;2167     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2168     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000002  680a              LDR      r2,[r1,#0]
000004  f42252c0          BIC      r2,r2,#0x1800
000008  600a              STR      r2,[r1,#0]
;;;2169   
;;;2170     /* Configure the RTC_TAFCR register */
;;;2171     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2172   }
000010  4770              BX       lr
;;;2173   
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinSelection PROC
;;;2362     */
;;;2363   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
000000  4904              LDR      r1,|L44.20|
;;;2364   {
;;;2365     /* Check the parameters */
;;;2366     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
;;;2367     
;;;2368     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;2369     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2370   }
000010  4770              BX       lr
;;;2371   
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;2218     */
;;;2219   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  4904              LDR      r1,|L45.20|
;;;2220   {
;;;2221     /* Check the parameters */
;;;2222     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;2223      
;;;2224     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2225     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000002  680a              LDR      r2,[r1,#0]
000004  f42242c0          BIC      r2,r2,#0x6000
000008  600a              STR      r2,[r1,#0]
;;;2226   
;;;2227     /* Configure the RTC_TAFCR register */
;;;2228     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2229   }
000010  4770              BX       lr
;;;2230   
                          ENDP

000012  0000              DCW      0x0000
                  |L45.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;2261     */
;;;2262   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L46.24|
;;;2263   {
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2266     
;;;2267    if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2268     {
;;;2269       /* Enable precharge of the selected Tamper pin */
;;;2270       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Disable precharge of the selected Tamper pin */
;;;2275       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L46.14|
000008  f4204000          BIC      r0,r0,#0x8000         ;2270
00000c  e001              B        |L46.18|
                  |L46.14|
00000e  f4404000          ORR      r0,r0,#0x8000
                  |L46.18|
000012  6008              STR      r0,[r1,#0]            ;2270
;;;2276     } 
;;;2277   }
000014  4770              BX       lr
;;;2278   
                          ENDP

000016  0000              DCW      0x0000
                  |L46.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;2195     */
;;;2196   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  4904              LDR      r1,|L47.20|
;;;2197   {
;;;2198     /* Check the parameters */
;;;2199     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;2200    
;;;2201     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2202     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000002  680a              LDR      r2,[r1,#0]
000004  f42262e0          BIC      r2,r2,#0x700
000008  600a              STR      r2,[r1,#0]
;;;2203   
;;;2204     /* Configure the RTC_TAFCR register */
;;;2205     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2206   }
000010  4770              BX       lr
;;;2207   
                          ENDP

000012  0000              DCW      0x0000
                  |L47.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;2104     */
;;;2105   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  4a05              LDR      r2,|L48.24|
;;;2106   {
;;;2107     /* Check the parameters */
;;;2108     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;2109     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;2110    
;;;2111     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
000002  2900              CMP      r1,#0
;;;2112     {  
;;;2113       /* Configure the RTC_TAFCR register */
;;;2114       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
;;;2115     }
;;;2116     else
;;;2117     { 
;;;2118       /* Configure the RTC_TAFCR register */
;;;2119       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000004  6811              LDR      r1,[r2,#0]
000006  d003              BEQ      |L48.16|
000008  ea410040          ORR      r0,r1,r0,LSL #1
                  |L48.12|
00000c  6010              STR      r0,[r2,#0]            ;2114
;;;2120     }  
;;;2121   }
00000e  4770              BX       lr
                  |L48.16|
000010  ea210040          BIC      r0,r1,r0,LSL #1       ;2114
000014  e7fa              B        |L48.12|
;;;2122   
                          ENDP

000016  0000              DCW      0x0000
                  |L48.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1981     */
;;;1982   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  4b0a              LDR      r3,|L49.44|
;;;1983   {
000002  b510              PUSH     {r4,lr}
;;;1984     uint32_t tmpreg = 0;
;;;1985   
;;;1986     /* Check the parameters */
;;;1987     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1988     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1989   
;;;1990     /* Get the RTC_CR register and clear the bits to be configured */
;;;1991     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000004  681a              LDR      r2,[r3,#0]
000006  f6400408          MOV      r4,#0x808
00000a  43a2              BICS     r2,r2,r4
;;;1992   
;;;1993     /* Get the new configuration */
;;;1994     if (NewState != DISABLE)
;;;1995     {
;;;1996       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
;;;1997     }
;;;1998     else
;;;1999     {
;;;2000       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00000c  ea420200          ORR      r2,r2,r0
000010  b109              CBZ      r1,|L49.22|
000012  f4426200          ORR      r2,r2,#0x800          ;1996
                  |L49.22|
;;;2001     }
;;;2002   
;;;2003     /* Disable the write protection for RTC registers */
;;;2004     RTC->WPR = 0xCA;
000016  4805              LDR      r0,|L49.44|
000018  21ca              MOVS     r1,#0xca
00001a  301c              ADDS     r0,r0,#0x1c
00001c  6001              STR      r1,[r0,#0]
;;;2005     RTC->WPR = 0x53;
00001e  2153              MOVS     r1,#0x53
000020  6001              STR      r1,[r0,#0]
;;;2006   
;;;2007     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;2008     RTC->CR = (uint32_t)tmpreg;
000022  601a              STR      r2,[r3,#0]
;;;2009   
;;;2010     /* Enable the write protection for RTC registers */
;;;2011     RTC->WPR = 0xFF; 
000024  21ff              MOVS     r1,#0xff
000026  6001              STR      r1,[r0,#0]
;;;2012   }
000028  bd10              POP      {r4,pc}
;;;2013   
                          ENDP

00002a  0000              DCW      0x0000
                  |L49.44|
                          DCD      0x40002808

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2238     */
;;;2239   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L50.24|
;;;2240   {
;;;2241     /* Check the parameters */
;;;2242     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2243      
;;;2244     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2245     {
;;;2246       /* Save timestamp on tamper detection event */
;;;2247       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
;;;2248     }
;;;2249     else
;;;2250     {
;;;2251       /* Tamper detection does not cause a timestamp to be saved */
;;;2252       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L50.14|
000008  f0400080          ORR      r0,r0,#0x80           ;2247
00000c  e001              B        |L50.18|
                  |L50.14|
00000e  f0200080          BIC      r0,r0,#0x80
                  |L50.18|
000012  6008              STR      r0,[r1,#0]            ;2247
;;;2253     }
;;;2254   }
000014  4770              BX       lr
;;;2255   
                          ENDP

000016  0000              DCW      0x0000
                  |L50.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampPinSelection PROC
;;;2379     */
;;;2380   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
000000  4904              LDR      r1,|L51.20|
;;;2381   {
;;;2382     /* Check the parameters */
;;;2383     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;2384     
;;;2385     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
000002  680a              LDR      r2,[r1,#0]
000004  f4223200          BIC      r2,r2,#0x20000
000008  600a              STR      r2,[r1,#0]
;;;2386     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2387   }
000010  4770              BX       lr
;;;2388   
                          ENDP

000012  0000              DCW      0x0000
                  |L51.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;867      */
;;;868    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;869    {
;;;870      /* Time = 00h:00min:00sec */
;;;871      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;872      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;873      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;874      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;875    }
00000a  4770              BX       lr
;;;876    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;618      */
;;;619    ErrorStatus RTC_WaitForSynchro(void)
000000  b518              PUSH     {r3,r4,lr}
;;;620    {
;;;621      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;622      ErrorStatus status = ERROR;
;;;623      uint32_t synchrostatus = 0x00;
;;;624    
;;;625      /* Disable the write protection for RTC registers */
;;;626      RTC->WPR = 0xCA;
000004  4910              LDR      r1,|L53.72|
000006  9000              STR      r0,[sp,#0]
000008  20ca              MOVS     r0,#0xca
00000a  6008              STR      r0,[r1,#0]
;;;627      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;628        
;;;629      /* Clear RSF flag */
;;;630      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000010  480d              LDR      r0,|L53.72|
000012  3818              SUBS     r0,r0,#0x18
000014  6802              LDR      r2,[r0,#0]
000016  f02202a0          BIC      r2,r2,#0xa0
00001a  6002              STR      r2,[r0,#0]
;;;631        
;;;632      /* Wait the registers to be synchronised */
;;;633      do
;;;634      {
;;;635        synchrostatus = RTC->ISR & RTC_ISR_RSF;
;;;636        synchrocounter++;  
;;;637      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
00001c  f44f3400          MOV      r4,#0x20000
                  |L53.32|
000020  6802              LDR      r2,[r0,#0]            ;635
000022  9b00              LDR      r3,[sp,#0]            ;636
000024  f0020220          AND      r2,r2,#0x20           ;635
000028  1c5b              ADDS     r3,r3,#1              ;636
00002a  9300              STR      r3,[sp,#0]
00002c  42a3              CMP      r3,r4
00002e  d001              BEQ      |L53.52|
000030  2a00              CMP      r2,#0
000032  d0f5              BEQ      |L53.32|
                  |L53.52|
;;;638        
;;;639      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000034  6800              LDR      r0,[r0,#0]
000036  0680              LSLS     r0,r0,#26
000038  d501              BPL      |L53.62|
;;;640      {
;;;641        status = SUCCESS;
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L53.64|
                  |L53.62|
;;;642      }
;;;643      else
;;;644      {
;;;645        status = ERROR;
00003e  2000              MOVS     r0,#0
                  |L53.64|
;;;646      }        
;;;647    
;;;648      /* Enable the write protection for RTC registers */
;;;649      RTC->WPR = 0xFF; 
000040  22ff              MOVS     r2,#0xff
000042  600a              STR      r2,[r1,#0]
;;;650        
;;;651      return (status); 
;;;652    }
000044  bd18              POP      {r3,r4,pc}
;;;653    
                          ENDP

000046  0000              DCW      0x0000
                  |L53.72|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1493     */
;;;1494   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  4a08              LDR      r2,|L54.36|
;;;1495   {
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1498   
;;;1499     /* Disable the write protection for RTC registers */
;;;1500     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1501     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1502   
;;;1503     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1504     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00000a  4906              LDR      r1,|L54.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f0230307          BIC      r3,r3,#7
000014  600b              STR      r3,[r1,#0]
;;;1505   
;;;1506     /* Configure the clock source */
;;;1507     RTC->CR |= (uint32_t)RTC_WakeUpClock;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1508     
;;;1509     /* Enable the write protection for RTC registers */
;;;1510     RTC->WPR = 0xFF; 
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1511   }
000020  4770              BX       lr
;;;1512   
                          ENDP

000022  0000              DCW      0x0000
                  |L54.36|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1553     */
;;;1554   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b518              PUSH     {r3,r4,lr}
;;;1555   {
;;;1556     __IO uint32_t wutcounter = 0x00;
000002  2100              MOVS     r1,#0
;;;1557     uint32_t wutwfstatus = 0x00;
;;;1558     ErrorStatus status = ERROR;
;;;1559     
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1562   
;;;1563     /* Disable the write protection for RTC registers */
;;;1564     RTC->WPR = 0xCA;
000004  4a13              LDR      r2,|L55.84|
000006  9100              STR      r1,[sp,#0]
000008  21ca              MOVS     r1,#0xca
00000a  6011              STR      r1,[r2,#0]
;;;1565     RTC->WPR = 0x53;
00000c  2153              MOVS     r1,#0x53
00000e  6011              STR      r1,[r2,#0]
;;;1566   
;;;1567     if (NewState != DISABLE)
;;;1568     {
;;;1569       /* Enable the Wakeup Timer */
;;;1570       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000010  4910              LDR      r1,|L55.84|
000012  391c              SUBS     r1,r1,#0x1c
000014  2800              CMP      r0,#0                 ;1567
;;;1571       status = SUCCESS;    
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       /* Disable the Wakeup Timer */
;;;1576       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
000016  6808              LDR      r0,[r1,#0]
000018  d003              BEQ      |L55.34|
00001a  f4406080          ORR      r0,r0,#0x400          ;1570
00001e  6008              STR      r0,[r1,#0]            ;1570
000020  e014              B        |L55.76|
                  |L55.34|
000022  f4206080          BIC      r0,r0,#0x400
000026  6008              STR      r0,[r1,#0]
;;;1577       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1578       do
;;;1579       {
;;;1580         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
000028  480a              LDR      r0,|L55.84|
00002a  3818              SUBS     r0,r0,#0x18
;;;1581         wutcounter++;  
;;;1582       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00002c  1384              ASRS     r4,r0,#14
                  |L55.46|
00002e  6801              LDR      r1,[r0,#0]            ;1580
000030  9b00              LDR      r3,[sp,#0]            ;1581
000032  f0010104          AND      r1,r1,#4              ;1580
000036  1c5b              ADDS     r3,r3,#1              ;1581
000038  9300              STR      r3,[sp,#0]
00003a  42a3              CMP      r3,r4
00003c  d001              BEQ      |L55.66|
00003e  2900              CMP      r1,#0
000040  d0f5              BEQ      |L55.46|
                  |L55.66|
;;;1583       
;;;1584       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000042  6800              LDR      r0,[r0,#0]
000044  0740              LSLS     r0,r0,#29
000046  d401              BMI      |L55.76|
;;;1585       {
;;;1586         status = ERROR;
000048  2000              MOVS     r0,#0
00004a  e000              B        |L55.78|
                  |L55.76|
;;;1587       }
;;;1588       else
;;;1589       {
;;;1590         status = SUCCESS;
00004c  2001              MOVS     r0,#1
                  |L55.78|
;;;1591       }    
;;;1592     }
;;;1593   
;;;1594     /* Enable the write protection for RTC registers */
;;;1595     RTC->WPR = 0xFF; 
00004e  21ff              MOVS     r1,#0xff
000050  6011              STR      r1,[r2,#0]
;;;1596     
;;;1597     return status;
;;;1598   }
000052  bd18              POP      {r3,r4,pc}
;;;1599   
                          ENDP

                  |L55.84|
                          DCD      0x40002824

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;2302     */
;;;2303   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  b508              PUSH     {r3,lr}
;;;2304   {
;;;2305     __IO uint32_t tmp = 0;
;;;2306     
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2309   
;;;2310     tmp = RTC_BASE + 0x50;
000002  4a03              LDR      r2,|L56.16|
;;;2311     tmp += (RTC_BKP_DR * 4);
000004  eb020080          ADD      r0,r2,r0,LSL #2
;;;2312   
;;;2313     /* Write the specified register */
;;;2314     *(__IO uint32_t *)tmp = (uint32_t)Data;
000008  9000              STR      r0,[sp,#0]
00000a  6001              STR      r1,[r0,#0]
;;;2315   }
00000c  bd08              POP      {r3,pc}
;;;2316   
                          ENDP

00000e  0000              DCW      0x0000
                  |L56.16|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;524      */
;;;525    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L57.20|
;;;526    {
000002  b108              CBZ      r0,|L57.8|
;;;527      /* Check the parameters */
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;529        
;;;530      if (NewState != DISABLE)
;;;531      {
;;;532        /* Enable the write protection for RTC registers */
;;;533        RTC->WPR = 0xFF;   
000004  20ff              MOVS     r0,#0xff
000006  e002              B        |L57.14|
                  |L57.8|
;;;534      }
;;;535      else
;;;536      {
;;;537        /* Disable the write protection for RTC registers */
;;;538        RTC->WPR = 0xCA;
000008  20ca              MOVS     r0,#0xca
00000a  6008              STR      r0,[r1,#0]
;;;539        RTC->WPR = 0x53;    
00000c  2053              MOVS     r0,#0x53
                  |L57.14|
00000e  6008              STR      r0,[r1,#0]            ;533
;;;540      }
;;;541    }
000010  4770              BX       lr
;;;542    
                          ENDP

000012  0000              DCW      0x0000
                  |L57.20|
                          DCD      0x40002824

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rtc_c_81435638____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REVSH|
#line 144
|__asm___15_stm32f4xx_rtc_c_81435638____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
