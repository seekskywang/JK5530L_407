; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usb_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usb_core.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=538 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\usb_core.crf --no_multibyte_chars ..\USB\STM32_USB_OTG_Driver\src\usb_core.c]
                          THUMB

                          AREA ||i.USB_OTG_CoreInit||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInit PROC
;;;322    */
;;;323    USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;324    {
000002  4604              MOV      r4,r0
;;;325      USB_OTG_STS status = USB_OTG_OK;
;;;326      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;327      USB_OTG_GCCFG_TypeDef    gccfg;
;;;328      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;329      
;;;330      usbcfg.d32 = 0;
;;;331      gccfg.d32 = 0;
;;;332      ahbcfg.d32 = 0;
;;;333      
;;;334      
;;;335      
;;;336      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
000004  7a01              LDRB     r1,[r0,#8]
000006  2500              MOVS     r5,#0                 ;325
;;;337      {
;;;338        gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2901              CMP      r1,#1                 ;336
00000c  d015              BEQ      |L1.58|
;;;339        gccfg.b.pwdn = 0;
;;;340        
;;;341        if (pdev->cfg.Sof_output)
;;;342        {
;;;343          gccfg.b.sofouten = 1;   
;;;344        }
;;;345        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
;;;346        
;;;347        /* Init The ULPI Interface */
;;;348        usbcfg.d32 = 0;
;;;349        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;350        
;;;351        usbcfg.b.physel            = 0; /* HS Interface */
;;;352    #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
;;;353        usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
;;;354    #else
;;;355    #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
;;;356        usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
;;;357    #endif
;;;358    #endif 
;;;359        usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
;;;360        
;;;361        usbcfg.b.ulpi_fsls = 0;
;;;362        usbcfg.b.ulpi_clk_sus_m = 0;
;;;363        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;364        
;;;365        /* Reset after a PHY select  */
;;;366        USB_OTG_CoreReset(pdev);
;;;367        
;;;368        if(pdev->cfg.dma_enable == 1)
;;;369        {
;;;370          
;;;371          ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
;;;372          ahbcfg.b.dmaenable = 1;
;;;373          USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
;;;374          
;;;375        }    
;;;376      }
;;;377      else /* FS interface (embedded Phy) */
;;;378      {
;;;379        
;;;380        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
00000e  68c1              LDR      r1,[r0,#0xc]
;;;381        usbcfg.b.physel  = 1; /* FS Interface */
000010  f0410140          ORR      r1,r1,#0x40
;;;382        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
000014  60c1              STR      r1,[r0,#0xc]
;;;383        /* Reset after a PHY select and set Host mode */
;;;384        USB_OTG_CoreReset(pdev);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USB_OTG_CoreReset
;;;385        /* Deactivate the power down*/
;;;386        gccfg.d32 = 0;
;;;387        gccfg.b.pwdn = 1;
;;;388        
;;;389        gccfg.b.vbussensingA = 1 ;
;;;390        gccfg.b.vbussensingB = 1 ;     
;;;391    #ifndef VBUS_SENSING_ENABLED
;;;392        gccfg.b.disablevbussensing = 1; 
;;;393    #endif    
;;;394        
;;;395        if(pdev->cfg.Sof_output)
00001c  7a61              LDRB     r1,[r4,#9]
00001e  f44f1034          MOV      r0,#0x2d0000          ;392
000022  b109              CBZ      r1,|L1.40|
;;;396        {
;;;397          gccfg.b.sofouten = 1;  
000024  f44f1074          MOV      r0,#0x3d0000
                  |L1.40|
;;;398        }
;;;399        
;;;400        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
000028  68e1              LDR      r1,[r4,#0xc]
00002a  6388              STR      r0,[r1,#0x38]
;;;401        USB_OTG_BSP_mDelay(20);
00002c  2014              MOVS     r0,#0x14
00002e  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L1.50|
;;;402      }
;;;403      /* case the HS core is working in FS mode */
;;;404      if(pdev->cfg.dma_enable == 1)
000032  78e0              LDRB     r0,[r4,#3]
000034  2801              CMP      r0,#1
000036  d01b              BEQ      |L1.112|
000038  e022              B        |L1.128|
                  |L1.58|
00003a  6b81              LDR      r1,[r0,#0x38]         ;338
00003c  7a62              LDRB     r2,[r4,#9]            ;341
00003e  f4213180          BIC      r1,r1,#0x10000        ;339
000042  b10a              CBZ      r2,|L1.72|
000044  f4411180          ORR      r1,r1,#0x100000       ;343
                  |L1.72|
000048  6381              STR      r1,[r0,#0x38]         ;345
00004a  68e0              LDR      r0,[r4,#0xc]          ;349
00004c  68c1              LDR      r1,[r0,#0xc]          ;349
00004e  f0211140          BIC      r1,r1,#0x400040       ;356
000052  f4212120          BIC      r1,r1,#0xa0000        ;361
000056  f4411180          ORR      r1,r1,#0x100000       ;362
00005a  60c1              STR      r1,[r0,#0xc]          ;363
00005c  4620              MOV      r0,r4                 ;366
00005e  f7fffffe          BL       USB_OTG_CoreReset
000062  78e0              LDRB     r0,[r4,#3]            ;368
000064  2801              CMP      r0,#1                 ;368
000066  d10b              BNE      |L1.128|
000068  68e1              LDR      r1,[r4,#0xc]          ;373
00006a  202a              MOVS     r0,#0x2a              ;372
00006c  6088              STR      r0,[r1,#8]            ;373
00006e  e7e0              B        |L1.50|
                  |L1.112|
;;;405      {
;;;406        
;;;407        ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
000070  68e0              LDR      r0,[r4,#0xc]
000072  6881              LDR      r1,[r0,#8]
;;;408        ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
000074  f021011e          BIC      r1,r1,#0x1e
000078  310a              ADDS     r1,r1,#0xa
;;;409        ahbcfg.b.dmaenable = 1;
00007a  f0410120          ORR      r1,r1,#0x20
;;;410        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
00007e  6081              STR      r1,[r0,#8]
                  |L1.128|
;;;411        
;;;412      }
;;;413      /* initialize OTG features */
;;;414    #ifdef  USE_OTG_MODE
;;;415      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;416      usbcfg.b.hnpcap = 1;
;;;417      usbcfg.b.srpcap = 1;
;;;418      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;419      USB_OTG_EnableCommonInt(pdev);
;;;420    #endif
;;;421      return status;
000080  4628              MOV      r0,r5
;;;422    }
000082  bd70              POP      {r4-r6,pc}
;;;423    /**
                          ENDP


                          AREA ||i.USB_OTG_CoreInitHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInitHost PROC
;;;611    */
;;;612    USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;613    {
;;;614      USB_OTG_STS                     status = USB_OTG_OK;
000004  f04f0900          MOV      r9,#0
;;;615      USB_OTG_FSIZ_TypeDef            nptxfifosize;
;;;616      USB_OTG_FSIZ_TypeDef            ptxfifosize;  
;;;617      USB_OTG_HCFG_TypeDef            hcfg;
;;;618      
;;;619    #ifdef USE_OTG_MODE
;;;620      USB_OTG_OTGCTL_TypeDef          gotgctl;
;;;621    #endif
;;;622      
;;;623      uint32_t                        i = 0;
;;;624      
;;;625      nptxfifosize.d32 = 0;  
000008  46c8              MOV      r8,r9
00000a  4606              MOV      r6,r0                 ;613
00000c  464f              MOV      r7,r9                 ;623
00000e  4644              MOV      r4,r8
;;;626      ptxfifosize.d32 = 0;
000010  4645              MOV      r5,r8
;;;627    #ifdef USE_OTG_MODE
;;;628      gotgctl.d32 = 0;
;;;629    #endif
;;;630      hcfg.d32 = 0;
;;;631      
;;;632      
;;;633      /* configure charge pump IO */
;;;634      USB_OTG_BSP_ConfigVBUS(pdev);
000012  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;635      
;;;636      /* Restart the Phy Clock */
;;;637      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000016  f8d6010c          LDR      r0,[r6,#0x10c]
00001a  6004              STR      r4,[r0,#0]
;;;638      
;;;639      /* Initialize Host Configuration Register */
;;;640      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00001c  7a30              LDRB     r0,[r6,#8]
00001e  2801              CMP      r0,#1
000020  d00f              BEQ      |L2.66|
;;;641      {
;;;642        USB_OTG_InitFSLSPClkSel(pdev , HCFG_30_60_MHZ); 
;;;643      }
;;;644      else
;;;645      {
;;;646        USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
000022  2101              MOVS     r1,#1
                  |L2.36|
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
;;;647      }
;;;648      USB_OTG_ResetPort(pdev);
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       USB_OTG_ResetPort
;;;649      
;;;650      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000030  6970              LDR      r0,[r6,#0x14]
000032  6801              LDR      r1,[r0,#0]
;;;651      hcfg.b.fslssupp = 0;
000034  f0210104          BIC      r1,r1,#4
;;;652      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000038  6001              STR      r1,[r0,#0]
;;;653      
;;;654      /* Configure data FIFO sizes */
;;;655      /* Rx FIFO */
;;;656    #ifdef USB_OTG_FS_CORE
;;;657      if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
00003a  7af0              LDRB     r0,[r6,#0xb]
00003c  2801              CMP      r0,#1
00003e  d002              BEQ      |L2.70|
000040  e013              B        |L2.106|
                  |L2.66|
000042  2100              MOVS     r1,#0                 ;642
000044  e7ee              B        |L2.36|
                  |L2.70|
;;;658      {
;;;659        /* set Rx FIFO size */
;;;660        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
000046  68f1              LDR      r1,[r6,#0xc]
000048  2080              MOVS     r0,#0x80
00004a  6248              STR      r0,[r1,#0x24]
00004c  f360040f          BFI      r4,r0,#0,#16
;;;661        nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
;;;662        nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
;;;663        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
000050  68f1              LDR      r1,[r6,#0xc]
000052  2060              MOVS     r0,#0x60              ;662
000054  f360441f          BFI      r4,r0,#16,#16         ;662
000058  628c              STR      r4,[r1,#0x28]
;;;664        
;;;665        ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
00005a  21e0              MOVS     r1,#0xe0
00005c  f361050f          BFI      r5,r1,#0,#16
000060  f360451f          BFI      r5,r0,#16,#16
;;;666        ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
;;;667        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
000064  68f0              LDR      r0,[r6,#0xc]
000066  f8c05100          STR      r5,[r0,#0x100]
                  |L2.106|
;;;668      }
;;;669    #endif
;;;670    #ifdef USB_OTG_HS_CORE  
;;;671      if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
00006a  7af0              LDRB     r0,[r6,#0xb]
00006c  b998              CBNZ     r0,|L2.150|
;;;672      {
;;;673        /* set Rx FIFO size */
;;;674        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
00006e  68f1              LDR      r1,[r6,#0xc]
000070  f44f7000          MOV      r0,#0x200
000074  6248              STR      r0,[r1,#0x24]
000076  f360040f          BFI      r4,r0,#0,#16
;;;675        nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
;;;676        nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
;;;677        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
00007a  68f1              LDR      r1,[r6,#0xc]
00007c  1040              ASRS     r0,r0,#1              ;676
00007e  f360441f          BFI      r4,r0,#16,#16         ;676
000082  628c              STR      r4,[r1,#0x28]
;;;678        
;;;679        ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
000084  f44f7140          MOV      r1,#0x300
000088  f361050f          BFI      r5,r1,#0,#16
00008c  f360451f          BFI      r5,r0,#16,#16
;;;680        ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
;;;681        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
000090  68f0              LDR      r0,[r6,#0xc]
000092  f8c05100          STR      r5,[r0,#0x100]
                  |L2.150|
;;;682      }
;;;683    #endif  
;;;684      
;;;685    #ifdef USE_OTG_MODE
;;;686      /* Clear Host Set HNP Enable in the USB_OTG Control Register */
;;;687      gotgctl.b.hstsethnpen = 1;
;;;688      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
;;;689    #endif
;;;690      
;;;691      /* Make sure the FIFOs are flushed. */
;;;692      USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
000096  2110              MOVS     r1,#0x10
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;693      USB_OTG_FlushRxFifo(pdev);
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       USB_OTG_FlushRxFifo
0000a4  4640              MOV      r0,r8
;;;694      
;;;695      
;;;696      /* Clear all pending HC Interrupts */
;;;697      for (i = 0; i < pdev->cfg.host_channels; i++)
;;;698      {
;;;699        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
0000a6  f04f32ff          MOV      r2,#0xffffffff
0000aa  e007              B        |L2.188|
                  |L2.172|
0000ac  eb060187          ADD      r1,r6,r7,LSL #2
0000b0  f8513f90          LDR      r3,[r1,#0x90]!
0000b4  609a              STR      r2,[r3,#8]
;;;700        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
0000b6  6809              LDR      r1,[r1,#0]
0000b8  60c8              STR      r0,[r1,#0xc]
0000ba  1c7f              ADDS     r7,r7,#1
                  |L2.188|
0000bc  7831              LDRB     r1,[r6,#0]            ;697
0000be  42b9              CMP      r1,r7                 ;697
0000c0  d8f4              BHI      |L2.172|
;;;701      }
;;;702    #ifndef USE_OTG_MODE
;;;703      USB_OTG_DriveVbus(pdev, 1);
0000c2  2101              MOVS     r1,#1
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       USB_OTG_DriveVbus
;;;704    #endif
;;;705      
;;;706      USB_OTG_EnableHostInt(pdev);
0000ca  4630              MOV      r0,r6
0000cc  f7fffffe          BL       USB_OTG_EnableHostInt
;;;707      return status;
0000d0  4648              MOV      r0,r9
;;;708    }
0000d2  e8bd87f0          POP      {r4-r10,pc}
;;;709    
                          ENDP


                          AREA ||i.USB_OTG_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreReset PROC
;;;122    */
;;;123    static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;124    {
;;;125      USB_OTG_STS status = USB_OTG_OK;
000002  2700              MOVS     r7,#0
000004  4604              MOV      r4,r0                 ;124
;;;126      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;127      uint32_t count = 0;
000006  463e              MOV      r6,r7
;;;128      
;;;129      greset.d32 = 0;
000008  9700              STR      r7,[sp,#0]
;;;130      /* Wait for AHB master IDLE state. */
;;;131      do
;;;132      {
;;;133        USB_OTG_BSP_uDelay(3);
;;;134        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;135        if (++count > 200000)
00000a  4d12              LDR      r5,|L3.84|
                  |L3.12|
00000c  2003              MOVS     r0,#3                 ;133
00000e  f7fffffe          BL       USB_OTG_BSP_uDelay
000012  68e0              LDR      r0,[r4,#0xc]          ;134
000014  6900              LDR      r0,[r0,#0x10]         ;134
000016  9000              STR      r0,[sp,#0]            ;134
000018  1c76              ADDS     r6,r6,#1              ;134
00001a  42ae              CMP      r6,r5
00001c  d901              BLS      |L3.34|
;;;136        {
;;;137          return USB_OTG_OK;
00001e  2000              MOVS     r0,#0
;;;138        }
;;;139      }
;;;140      while (greset.b.ahbidle == 0);
;;;141      /* Core Soft Reset */
;;;142      count = 0;
;;;143      greset.b.csftrst = 1;
;;;144      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
;;;145      do
;;;146      {
;;;147        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;148        if (++count > 200000)
;;;149        {
;;;150          break;
;;;151        }
;;;152      }
;;;153      while (greset.b.csftrst == 1);
;;;154      /* Wait for 3 PHY Clocks*/
;;;155      USB_OTG_BSP_uDelay(3);
;;;156      return status;
;;;157    }
000020  bdf8              POP      {r3-r7,pc}
                  |L3.34|
000022  9800              LDR      r0,[sp,#0]            ;140
000024  2800              CMP      r0,#0                 ;140
000026  daf1              BGE      |L3.12|
000028  9900              LDR      r1,[sp,#0]            ;143
00002a  2000              MOVS     r0,#0                 ;142
00002c  f0410101          ORR      r1,r1,#1              ;143
000030  9100              STR      r1,[sp,#0]            ;143
000032  9900              LDR      r1,[sp,#0]            ;144
000034  68e2              LDR      r2,[r4,#0xc]          ;144
000036  6111              STR      r1,[r2,#0x10]         ;144
000038  68e1              LDR      r1,[r4,#0xc]          ;134
                  |L3.58|
00003a  690a              LDR      r2,[r1,#0x10]         ;147
00003c  9200              STR      r2,[sp,#0]            ;147
00003e  1c40              ADDS     r0,r0,#1              ;147
000040  42a8              CMP      r0,r5                 ;148
000042  d802              BHI      |L3.74|
000044  9a00              LDR      r2,[sp,#0]            ;153
000046  07d2              LSLS     r2,r2,#31             ;153
000048  d1f7              BNE      |L3.58|
                  |L3.74|
00004a  2003              MOVS     r0,#3                 ;155
00004c  f7fffffe          BL       USB_OTG_BSP_uDelay
000050  4638              MOV      r0,r7                 ;156
000052  bdf8              POP      {r3-r7,pc}
;;;158    
                          ENDP

                  |L3.84|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_DisableGlobalInt PROC
;;;446    */
;;;447    USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;448    {
;;;449      USB_OTG_STS status = USB_OTG_OK;
;;;450      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;451      ahbcfg.d32 = 0;
000002  2100              MOVS     r1,#0
;;;452      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;453      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
000004  6882              LDR      r2,[r0,#8]
000006  f0220201          BIC      r2,r2,#1
00000a  6082              STR      r2,[r0,#8]
;;;454      return status;
00000c  4608              MOV      r0,r1
;;;455    }
00000e  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.USB_OTG_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_OTG_DriveVbus PROC
;;;726    */
;;;727    void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
000000  b570              PUSH     {r4-r6,lr}
;;;728    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;729      USB_OTG_HPRT0_TypeDef     hprt0;
;;;730      
;;;731      hprt0.d32 = 0;
;;;732      
;;;733      /* enable disable the external charge pump */
;;;734      USB_OTG_BSP_DriveVBUS(pdev, state);
000006  f7fffffe          BL       USB_OTG_BSP_DriveVBUS
;;;735      
;;;736      /* Turn on the Host port power. */
;;;737      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;738      if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
000010  04c1              LSLS     r1,r0,#19
000012  d403              BMI      |L5.28|
000014  2c01              CMP      r4,#1
000016  d003              BEQ      |L5.32|
;;;739      {
;;;740        hprt0.b.prtpwr = 1;
;;;741        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
;;;742      }
;;;743      if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
000018  04c1              LSLS     r1,r0,#19
00001a  d509              BPL      |L5.48|
                  |L5.28|
00001c  b11c              CBZ      r4,|L5.38|
00001e  e007              B        |L5.48|
                  |L5.32|
000020  f4405080          ORR      r0,r0,#0x1000         ;740
000024  e001              B        |L5.42|
                  |L5.38|
;;;744      {
;;;745        hprt0.b.prtpwr = 0;
000026  f4205080          BIC      r0,r0,#0x1000
                  |L5.42|
00002a  f8d510cc          LDR      r1,[r5,#0xcc]         ;741
00002e  6008              STR      r0,[r1,#0]            ;741
                  |L5.48|
;;;746        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
;;;747      }
;;;748      
;;;749      USB_OTG_BSP_mDelay(200);
000030  e8bd4070          POP      {r4-r6,lr}
000034  20c8              MOVS     r0,#0xc8
000036  f7ffbffe          B.W      USB_OTG_BSP_mDelay
;;;750    }
;;;751    /**
                          ENDP


                          AREA ||i.USB_OTG_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableGlobalInt PROC
;;;428    */
;;;429    USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;430    {
;;;431      USB_OTG_STS status = USB_OTG_OK;
;;;432      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;433      
;;;434      ahbcfg.d32 = 0;
000002  2100              MOVS     r1,#0
;;;435      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;436      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
000004  6882              LDR      r2,[r0,#8]
000006  f0420201          ORR      r2,r2,#1
00000a  6082              STR      r2,[r0,#8]
;;;437      return status;
00000c  4608              MOV      r0,r1
;;;438    }
00000e  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.USB_OTG_EnableHostInt||, CODE, READONLY, ALIGN=2

                  USB_OTG_EnableHostInt PROC
;;;755    */
;;;756    USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;757    {
;;;758      USB_OTG_STS       status = USB_OTG_OK;
;;;759      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;760      intmsk.d32 = 0;
;;;761      /* Disable all interrupts. */
;;;762      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
000002  68c3              LDR      r3,[r0,#0xc]
000004  2200              MOVS     r2,#0                 ;758
000006  4611              MOV      r1,r2                 ;760
000008  619a              STR      r2,[r3,#0x18]
;;;763      
;;;764      /* Clear any pending interrupts. */
;;;765      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
00000a  68c4              LDR      r4,[r0,#0xc]
00000c  1e53              SUBS     r3,r2,#1
00000e  6163              STR      r3,[r4,#0x14]
000010  68c4              LDR      r4,[r0,#0xc]
000012  6063              STR      r3,[r4,#4]
000014  68c4              LDR      r4,[r0,#0xc]
000016  f06f4380          MVN      r3,#0x40000000
00001a  6163              STR      r3,[r4,#0x14]
00001c  68c4              LDR      r4,[r0,#0xc]
00001e  4b09              LDR      r3,|L7.68|
000020  61a3              STR      r3,[r4,#0x18]
;;;766      
;;;767      /* Enable the common interrupts */
;;;768      USB_OTG_EnableCommonInt(pdev);
;;;769      
;;;770      if (pdev->cfg.dma_enable == 0)
000022  78c3              LDRB     r3,[r0,#3]
000024  b903              CBNZ     r3,|L7.40|
;;;771      {  
;;;772        intmsk.b.rxstsqlvl  = 1;
000026  2110              MOVS     r1,#0x10
                  |L7.40|
;;;773      }  
;;;774      intmsk.b.portintr   = 1;
;;;775      intmsk.b.hcintr     = 1;
;;;776      intmsk.b.disconnect = 1;  
;;;777      intmsk.b.sofintr    = 1;  
;;;778      intmsk.b.incomplisoout  = 1; 
;;;779      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f041510c          ORR      r1,r1,#0x23000000     ;774
00002e  f0410108          ORR      r1,r1,#8              ;777
000032  6983              LDR      r3,[r0,#0x18]
000034  f4411100          ORR      r1,r1,#0x200000       ;778
000038  438b              BICS     r3,r3,r1
00003a  430b              ORRS     r3,r3,r1
00003c  6183              STR      r3,[r0,#0x18]
;;;780      return status;
00003e  4610              MOV      r0,r2
;;;781    }
000040  bd10              POP      {r4,pc}
;;;782    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x80000800

                          AREA ||i.USB_OTG_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushRxFifo PROC
;;;493    */
;;;494    USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
000000  b538              PUSH     {r3-r5,lr}
;;;495    {
;;;496      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
;;;497      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;498      uint32_t count = 0;
000004  4621              MOV      r1,r4
;;;499      
;;;500      greset.d32 = 0;
000006  9400              STR      r4,[sp,#0]
;;;501      greset.b.rxfflsh = 1;
000008  9a00              LDR      r2,[sp,#0]
00000a  f0420210          ORR      r2,r2,#0x10
00000e  9200              STR      r2,[sp,#0]
;;;502      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000010  9a00              LDR      r2,[sp,#0]
000012  68c3              LDR      r3,[r0,#0xc]
000014  611a              STR      r2,[r3,#0x10]
;;;503      do
;;;504      {
;;;505        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;506        if (++count > 200000)
000016  4a07              LDR      r2,|L8.52|
000018  68c0              LDR      r0,[r0,#0xc]          ;502
                  |L8.26|
00001a  6903              LDR      r3,[r0,#0x10]         ;505
00001c  9300              STR      r3,[sp,#0]            ;505
00001e  1c49              ADDS     r1,r1,#1              ;505
000020  4291              CMP      r1,r2
000022  d802              BHI      |L8.42|
;;;507        {
;;;508          break;
;;;509        }
;;;510      }
;;;511      while (greset.b.rxfflsh == 1);
000024  9b00              LDR      r3,[sp,#0]
000026  06db              LSLS     r3,r3,#27
000028  d4f7              BMI      |L8.26|
                  |L8.42|
;;;512      /* Wait for 3 PHY Clocks*/
;;;513      USB_OTG_BSP_uDelay(3);
00002a  2003              MOVS     r0,#3
00002c  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;514      return status;
000030  4620              MOV      r0,r4
;;;515    }
000032  bd38              POP      {r3-r5,pc}
;;;516    
                          ENDP

                  |L8.52|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushTxFifo PROC
;;;463    */
;;;464    USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
000000  b538              PUSH     {r3-r5,lr}
;;;465    {
;;;466      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
;;;467      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;468      
;;;469      uint32_t count = 0;
000004  4622              MOV      r2,r4
;;;470      greset.d32 = 0;
000006  9400              STR      r4,[sp,#0]
;;;471      greset.b.txfflsh = 1;
000008  9b00              LDR      r3,[sp,#0]
00000a  f0430320          ORR      r3,r3,#0x20
00000e  9300              STR      r3,[sp,#0]
;;;472      greset.b.txfnum  = num;
000010  9b00              LDR      r3,[sp,#0]
000012  f361138a          BFI      r3,r1,#6,#5
000016  9300              STR      r3,[sp,#0]
;;;473      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000018  9900              LDR      r1,[sp,#0]
00001a  68c3              LDR      r3,[r0,#0xc]
00001c  6119              STR      r1,[r3,#0x10]
;;;474      do
;;;475      {
;;;476        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;477        if (++count > 200000)
00001e  4907              LDR      r1,|L9.60|
000020  68c0              LDR      r0,[r0,#0xc]          ;473
                  |L9.34|
000022  6903              LDR      r3,[r0,#0x10]         ;476
000024  9300              STR      r3,[sp,#0]            ;476
000026  1c52              ADDS     r2,r2,#1              ;476
000028  428a              CMP      r2,r1
00002a  d802              BHI      |L9.50|
;;;478        {
;;;479          break;
;;;480        }
;;;481      }
;;;482      while (greset.b.txfflsh == 1);
00002c  9b00              LDR      r3,[sp,#0]
00002e  069b              LSLS     r3,r3,#26
000030  d4f7              BMI      |L9.34|
                  |L9.50|
;;;483      /* Wait for 3 PHY Clocks*/
;;;484      USB_OTG_BSP_uDelay(3);
000032  2003              MOVS     r0,#3
000034  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;485      return status;
000038  4620              MOV      r0,r4
;;;486    }
00003a  bd38              POP      {r3-r5,pc}
;;;487    
                          ENDP

                  |L9.60|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_GetMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetMode PROC
;;;553    */
;;;554    uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;555    {
;;;556      return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
000002  6940              LDR      r0,[r0,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;557    }
000008  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.USB_OTG_HC_DoPing||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_DoPing PROC
;;;1122   */
;;;1123   USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1124   {
;;;1125     USB_OTG_STS               status = USB_OTG_OK;
;;;1126     USB_OTG_HCCHAR_TypeDef    hcchar;
;;;1127     USB_OTG_HCTSIZn_TypeDef   hctsiz;  
;;;1128     
;;;1129     hctsiz.d32 = 0;
;;;1130     hctsiz.b.dopng = 1;
;;;1131     hctsiz.b.pktcnt = 1;
;;;1132     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000002  eb000081          ADD      r0,r0,r1,LSL #2
000006  2300              MOVS     r3,#0                 ;1129
000008  f8501f90          LDR      r1,[r0,#0x90]!
00000c  f04f4200          MOV      r2,#0x80000000        ;1130
000010  2401              MOVS     r4,#1                 ;1131
000012  f36442dc          BFI      r2,r4,#19,#10         ;1131
000016  610a              STR      r2,[r1,#0x10]
;;;1133     
;;;1134     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
000018  6800              LDR      r0,[r0,#0]
00001a  6801              LDR      r1,[r0,#0]
;;;1135     hcchar.b.chen = 1;
00001c  f0214180          BIC      r1,r1,#0x40000000
;;;1136     hcchar.b.chdis = 0;
000020  f0414100          ORR      r1,r1,#0x80000000
;;;1137     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000024  6001              STR      r1,[r0,#0]
;;;1138     return status;  
000026  4618              MOV      r0,r3
;;;1139   }
000028  bd10              POP      {r4,pc}
;;;1140   
                          ENDP


                          AREA ||i.USB_OTG_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Halt PROC
;;;1083   */
;;;1084   USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1085   {
;;;1086     USB_OTG_STS status = USB_OTG_OK;
;;;1087     USB_OTG_HNPTXSTS_TypeDef            nptxsts;
;;;1088     USB_OTG_HPTXSTS_TypeDef             hptxsts;
;;;1089     USB_OTG_HCCHAR_TypeDef              hcchar;
;;;1090     
;;;1091     nptxsts.d32 = 0;
;;;1092     hptxsts.d32 = 0;
;;;1093     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
000002  eb000181          ADD      r1,r0,r1,LSL #2
000006  2200              MOVS     r2,#0                 ;1086
000008  f8d13090          LDR      r3,[r1,#0x90]
00000c  6819              LDR      r1,[r3,#0]
;;;1094     hcchar.b.chen = 1;
;;;1095     hcchar.b.chdis = 1;
00000e  f0414140          ORR      r1,r1,#0xc0000000
;;;1096     
;;;1097     /* Check for space in the request queue to issue the halt. */
;;;1098     if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
000012  f4112f40          TST      r1,#0xc0000
000016  d009              BEQ      |L12.44|
000018  f3c14481          UBFX     r4,r1,#18,#2
00001c  2c02              CMP      r4,#2
00001e  d005              BEQ      |L12.44|
;;;1099     {
;;;1100       nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
;;;1101       if (nptxsts.b.nptxqspcavail == 0)
;;;1102       {
;;;1103         hcchar.b.chen = 0;
;;;1104       }
;;;1105     }
;;;1106     else
;;;1107     {
;;;1108       hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
000020  6940              LDR      r0,[r0,#0x14]
000022  6900              LDR      r0,[r0,#0x10]
                  |L12.36|
;;;1109       if (hptxsts.b.ptxqspcavail == 0)
000024  f4100f7f          TST      r0,#0xff0000
000028  d003              BEQ      |L12.50|
00002a  e004              B        |L12.54|
                  |L12.44|
00002c  68c0              LDR      r0,[r0,#0xc]          ;1100
00002e  6ac0              LDR      r0,[r0,#0x2c]         ;1100
000030  e7f8              B        |L12.36|
                  |L12.50|
;;;1110       {
;;;1111         hcchar.b.chen = 0;
000032  f0214100          BIC      r1,r1,#0x80000000
                  |L12.54|
;;;1112       }
;;;1113     }
;;;1114     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000036  6019              STR      r1,[r3,#0]
;;;1115     return status;
000038  4610              MOV      r0,r2
;;;1116   }
00003a  bd10              POP      {r4,pc}
;;;1117   
                          ENDP


                          AREA ||i.USB_OTG_HC_Init||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Init PROC
;;;856    */
;;;857    USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;858    {
000002  4607              MOV      r7,r0
;;;859      USB_OTG_STS status = USB_OTG_OK;
;;;860      uint32_t intr_enable = 0;
;;;861      USB_OTG_HCINTMSK_TypeDef  hcintmsk;
;;;862      USB_OTG_GINTMSK_TypeDef    gintmsk;
;;;863      USB_OTG_HCCHAR_TypeDef     hcchar;
;;;864      USB_OTG_HCINTn_TypeDef     hcint;
;;;865      
;;;866      
;;;867      gintmsk.d32 = 0;
;;;868      hcintmsk.d32 = 0;
;;;869      hcchar.d32 = 0;
;;;870      
;;;871      /* Clear old interrupt conditions for this host channel. */
;;;872      hcint.d32 = 0xFFFFFFFF;
;;;873      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
000004  eb070681          ADD      r6,r7,r1,LSL #2
000008  2000              MOVS     r0,#0                 ;859
00000a  f8d65090          LDR      r5,[r6,#0x90]
00000e  4604              MOV      r4,r0                 ;867
000010  1e43              SUBS     r3,r0,#1              ;872
000012  4622              MOV      r2,r4                 ;867
000014  60ab              STR      r3,[r5,#8]
;;;874      
;;;875      /* Enable channel interrupts required for this transfer. */
;;;876      hcintmsk.d32 = 0;
;;;877      
;;;878      if (pdev->cfg.dma_enable == 1)
000016  78fb              LDRB     r3,[r7,#3]
000018  2b01              CMP      r3,#1
00001a  d100              BNE      |L13.30|
;;;879      {
;;;880        hcintmsk.b.ahberr = 1;
00001c  2204              MOVS     r2,#4
                  |L13.30|
;;;881      }
;;;882      
;;;883      switch (pdev->host.hc[hc_num].ep_type) 
00001e  eb071341          ADD      r3,r7,r1,LSL #5
000022  f89353b1          LDRB     r5,[r3,#0x3b1]
000026  b135              CBZ      r5,|L13.54|
000028  2d01              CMP      r5,#1
00002a  d01f              BEQ      |L13.108|
00002c  2d02              CMP      r5,#2
00002e  d002              BEQ      |L13.54|
000030  2d03              CMP      r5,#3
000032  d127              BNE      |L13.132|
000034  e00e              B        |L13.84|
                  |L13.54|
;;;884      {
;;;885      case EP_TYPE_CTRL:
;;;886      case EP_TYPE_BULK:
;;;887        hcintmsk.b.xfercompl = 1;
000036  f0420589          ORR      r5,r2,#0x89
;;;888        hcintmsk.b.stall = 1;
;;;889        hcintmsk.b.xacterr = 1;
;;;890        hcintmsk.b.datatglerr = 1;
;;;891        hcintmsk.b.nak = 1;  
00003a  f4456282          ORR      r2,r5,#0x410
;;;892        if (pdev->host.hc[hc_num].ep_is_in) 
00003e  f89353ae          LDRB     r5,[r3,#0x3ae]
000042  b985              CBNZ     r5,|L13.102|
;;;893        {
;;;894          hcintmsk.b.bblerr = 1;
;;;895        } 
;;;896        else 
;;;897        {
;;;898          hcintmsk.b.nyet = 1;
;;;899          if (pdev->host.hc[hc_num].do_ping) 
000044  f89353b0          LDRB     r5,[r3,#0x3b0]
000048  f0420240          ORR      r2,r2,#0x40           ;898
00004c  b1d5              CBZ      r5,|L13.132|
;;;900          {
;;;901            hcintmsk.b.ack = 1;
00004e  f0420220          ORR      r2,r2,#0x20
000052  e017              B        |L13.132|
                  |L13.84|
;;;902          }
;;;903        }
;;;904        break;
;;;905      case EP_TYPE_INTR:
;;;906        hcintmsk.b.xfercompl = 1;
;;;907        hcintmsk.b.nak = 1;
;;;908        hcintmsk.b.stall = 1;
;;;909        hcintmsk.b.xacterr = 1;
;;;910        hcintmsk.b.datatglerr = 1;
;;;911        hcintmsk.b.frmovrun = 1;
;;;912        
;;;913        if (pdev->host.hc[hc_num].ep_is_in) 
000054  f893c3ae          LDRB     r12,[r3,#0x3ae]
000058  f0420299          ORR      r2,r2,#0x99           ;906
00005c  f44262c0          ORR      r2,r2,#0x600          ;910
000060  f1bc0f00          CMP      r12,#0
000064  d00e              BEQ      |L13.132|
                  |L13.102|
;;;914        {
;;;915          hcintmsk.b.bblerr = 1;
000066  f4427280          ORR      r2,r2,#0x100
00006a  e00b              B        |L13.132|
                  |L13.108|
;;;916        }
;;;917        
;;;918        break;
;;;919      case EP_TYPE_ISOC:
;;;920        hcintmsk.b.xfercompl = 1;
;;;921        hcintmsk.b.frmovrun = 1;
;;;922        hcintmsk.b.ack = 1;
;;;923        
;;;924        if (pdev->host.hc[hc_num].ep_is_in) 
00006c  f893c3ae          LDRB     r12,[r3,#0x3ae]
000070  f0420201          ORR      r2,r2,#1              ;920
000074  f4427208          ORR      r2,r2,#0x220          ;921
000078  f1bc0f00          CMP      r12,#0
00007c  d002              BEQ      |L13.132|
;;;925        {
;;;926          hcintmsk.b.xacterr = 1;
00007e  f0420280          ORR      r2,r2,#0x80
;;;927          hcintmsk.b.bblerr = 1;
000082  e7f0              B        |L13.102|
                  |L13.132|
;;;928        }
;;;929        break;
;;;930      }
;;;931      
;;;932      
;;;933      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
000084  f8d65090          LDR      r5,[r6,#0x90]
000088  60ea              STR      r2,[r5,#0xc]
;;;934      
;;;935      
;;;936      /* Enable the top level host channel interrupt. */
;;;937      intr_enable = (1 << hc_num);
00008a  2201              MOVS     r2,#1
00008c  408a              LSLS     r2,r2,r1
;;;938      USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
00008e  6979              LDR      r1,[r7,#0x14]
000090  698d              LDR      r5,[r1,#0x18]
000092  4315              ORRS     r5,r5,r2
000094  618d              STR      r5,[r1,#0x18]
;;;939      
;;;940      /* Make sure host channel interrupts are enabled. */
;;;941      gintmsk.b.hcintr = 1;
;;;942      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
000096  68f9              LDR      r1,[r7,#0xc]
000098  698a              LDR      r2,[r1,#0x18]
00009a  f0427200          ORR      r2,r2,#0x2000000
00009e  618a              STR      r2,[r1,#0x18]
;;;943      
;;;944      /* Program the HCCHAR register */
;;;945      hcchar.d32 = 0;
;;;946      hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
0000a0  f89313ac          LDRB     r1,[r3,#0x3ac]
0000a4  f361549c          BFI      r4,r1,#22,#7
;;;947      hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
0000a8  f89313ad          LDRB     r1,[r3,#0x3ad]
0000ac  f36124ce          BFI      r4,r1,#11,#4
;;;948      hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
0000b0  f89313ae          LDRB     r1,[r3,#0x3ae]
0000b4  f36134cf          BFI      r4,r1,#15,#1
;;;949      hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
0000b8  f89313af          LDRB     r1,[r3,#0x3af]
0000bc  2902              CMP      r1,#2
0000be  d00c              BEQ      |L13.218|
0000c0  f4243100          BIC      r1,r4,#0x20000
                  |L13.196|
;;;950      hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
0000c4  f89323b1          LDRB     r2,[r3,#0x3b1]
;;;951      hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
0000c8  f8b333b2          LDRH     r3,[r3,#0x3b2]
0000cc  f3624193          BFI      r1,r2,#18,#2          ;950
0000d0  f363010a          BFI      r1,r3,#0,#11
;;;952      if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
0000d4  2a03              CMP      r2,#3
0000d6  d003              BEQ      |L13.224|
0000d8  e004              B        |L13.228|
                  |L13.218|
0000da  f4443100          ORR      r1,r4,#0x20000        ;949
0000de  e7f1              B        |L13.196|
                  |L13.224|
;;;953      {
;;;954        hcchar.b.oddfrm  = 1;
0000e0  f0415100          ORR      r1,r1,#0x20000000
                  |L13.228|
;;;955      }
;;;956      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
0000e4  f8d62090          LDR      r2,[r6,#0x90]
0000e8  6011              STR      r1,[r2,#0]
;;;957      return status;
;;;958    }
0000ea  bdf0              POP      {r4-r7,pc}
;;;959    
                          ENDP


                          AREA ||i.USB_OTG_HC_StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_StartXfer PROC
;;;966    */
;;;967    USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;968    {
;;;969      USB_OTG_STS status = USB_OTG_OK;
;;;970      USB_OTG_HCCHAR_TypeDef   hcchar;
;;;971      USB_OTG_HCTSIZn_TypeDef  hctsiz;
;;;972      USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
;;;973      USB_OTG_HPTXSTS_TypeDef  hptxsts; 
;;;974      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;975      uint16_t                 len_words = 0;   
;;;976      
;;;977      uint16_t num_packets;
;;;978      uint16_t max_hc_pkt_count;
;;;979      
;;;980      max_hc_pkt_count = 256;
;;;981      hctsiz.d32 = 0;
;;;982      hcchar.d32 = 0;
;;;983      intmsk.d32 = 0;
;;;984      
;;;985      /* Compute the expected number of packets associated to the transfer */
;;;986      if (pdev->host.hc[hc_num].xfer_len > 0)
000002  eb001441          ADD      r4,r0,r1,LSL #5
000006  4605              MOV      r5,r0                 ;968
000008  2600              MOVS     r6,#0                 ;969
00000a  f8d403bc          LDR      r0,[r4,#0x3bc]        ;968
00000e  f44f7780          MOV      r7,#0x100             ;980
000012  4633              MOV      r3,r6                 ;981
000014  b168              CBZ      r0,|L14.50|
;;;987      {
;;;988        num_packets = (pdev->host.hc[hc_num].xfer_len + \
000016  f8b423b2          LDRH     r2,[r4,#0x3b2]
00001a  4410              ADD      r0,r0,r2
00001c  1e40              SUBS     r0,r0,#1
00001e  fbb0f0f2          UDIV     r0,r0,r2
000022  b280              UXTH     r0,r0
;;;989          pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
;;;990        
;;;991        if (num_packets > max_hc_pkt_count)
000024  42b8              CMP      r0,r7
000026  d905              BLS      |L14.52|
;;;992        {
;;;993          num_packets = max_hc_pkt_count;
;;;994          pdev->host.hc[hc_num].xfer_len = num_packets * \
000028  0212              LSLS     r2,r2,#8
00002a  4638              MOV      r0,r7                 ;993
00002c  f8c423bc          STR      r2,[r4,#0x3bc]
000030  e000              B        |L14.52|
                  |L14.50|
;;;995            pdev->host.hc[hc_num].max_packet;
;;;996        }
;;;997      }
;;;998      else
;;;999      {
;;;1000       num_packets = 1;
000032  2001              MOVS     r0,#1
                  |L14.52|
;;;1001     }
;;;1002     if (pdev->host.hc[hc_num].ep_is_in)
000034  f89423ae          LDRB     r2,[r4,#0x3ae]
000038  b1aa              CBZ      r2,|L14.102|
;;;1003     {
;;;1004       pdev->host.hc[hc_num].xfer_len = num_packets * \
00003a  f8b423b2          LDRH     r2,[r4,#0x3b2]
00003e  4342              MULS     r2,r0,r2
000040  f8c423bc          STR      r2,[r4,#0x3bc]
                  |L14.68|
;;;1005         pdev->host.hc[hc_num].max_packet;
;;;1006     }
;;;1007     /* Initialize the HCTSIZn register */
;;;1008     hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
000044  f3620312          BFI      r3,r2,#0,#19
;;;1009     hctsiz.b.pktcnt = num_packets;
000048  f36043dc          BFI      r3,r0,#19,#10
;;;1010     hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
00004c  f89403b4          LDRB     r0,[r4,#0x3b4]
;;;1011     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000050  eb050281          ADD      r2,r5,r1,LSL #2
000054  f360735e          BFI      r3,r0,#29,#2          ;1010
000058  f8d20090          LDR      r0,[r2,#0x90]
00005c  6103              STR      r3,[r0,#0x10]
;;;1012     
;;;1013     if (pdev->cfg.dma_enable == 1)
00005e  78e8              LDRB     r0,[r5,#3]
000060  2801              CMP      r0,#1
000062  d003              BEQ      |L14.108|
000064  e007              B        |L14.118|
                  |L14.102|
000066  f8d423bc          LDR      r2,[r4,#0x3bc]        ;1004
00006a  e7eb              B        |L14.68|
                  |L14.108|
;;;1014     {
;;;1015       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
00006c  f8d23090          LDR      r3,[r2,#0x90]
000070  f8d403b8          LDR      r0,[r4,#0x3b8]
000074  6158              STR      r0,[r3,#0x14]
                  |L14.118|
;;;1016     }
;;;1017     
;;;1018     
;;;1019     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
000076  f8520f90          LDR      r0,[r2,#0x90]!
00007a  6803              LDR      r3,[r0,#0]
;;;1020     hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       USB_OTG_IsEvenFrame
000082  f360735d          BFI      r3,r0,#29,#1
;;;1021     
;;;1022     /* Set host channel enable */
;;;1023     hcchar.b.chen = 1;
;;;1024     hcchar.b.chdis = 0;
;;;1025     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000086  6812              LDR      r2,[r2,#0]
000088  f0234080          BIC      r0,r3,#0x40000000     ;1023
00008c  f0404000          ORR      r0,r0,#0x80000000     ;1024
000090  6010              STR      r0,[r2,#0]
;;;1026     
;;;1027     if (pdev->cfg.dma_enable == 0) /* Slave mode */
000092  78e8              LDRB     r0,[r5,#3]
000094  bb98              CBNZ     r0,|L14.254|
;;;1028     {  
;;;1029       if((pdev->host.hc[hc_num].ep_is_in == 0) && 
000096  f89403ae          LDRB     r0,[r4,#0x3ae]
00009a  bb80              CBNZ     r0,|L14.254|
;;;1030          (pdev->host.hc[hc_num].xfer_len > 0))
00009c  f8d403bc          LDR      r0,[r4,#0x3bc]
0000a0  b368              CBZ      r0,|L14.254|
;;;1031       {
;;;1032         switch(pdev->host.hc[hc_num].ep_type) 
0000a2  f89423b1          LDRB     r2,[r4,#0x3b1]
0000a6  b132              CBZ      r2,|L14.182|
0000a8  2a01              CMP      r2,#1
0000aa  d011              BEQ      |L14.208|
0000ac  2a02              CMP      r2,#2
0000ae  d002              BEQ      |L14.182|
0000b0  2a03              CMP      r2,#3
0000b2  d11a              BNE      |L14.234|
0000b4  e00c              B        |L14.208|
                  |L14.182|
;;;1033         {
;;;1034           /* Non periodic transfer */
;;;1035         case EP_TYPE_CTRL:
;;;1036         case EP_TYPE_BULK:
;;;1037           
;;;1038           hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
0000b6  68ea              LDR      r2,[r5,#0xc]
0000b8  6ad3              LDR      r3,[r2,#0x2c]
0000ba  1cc0              ADDS     r0,r0,#3
;;;1039           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000bc  f3c0008f          UBFX     r0,r0,#2,#16
;;;1040           
;;;1041           /* check if there is enough space in FIFO space */
;;;1042           if(len_words > hnptxsts.b.nptxfspcavail)
0000c0  b29b              UXTH     r3,r3
0000c2  4283              CMP      r3,r0
0000c4  d211              BCS      |L14.234|
;;;1043           {
;;;1044             /* need to process data in nptxfempty interrupt */
;;;1045             intmsk.b.nptxfempty = 1;
;;;1046             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000c6  6990              LDR      r0,[r2,#0x18]
0000c8  f0400020          ORR      r0,r0,#0x20
0000cc  6190              STR      r0,[r2,#0x18]
0000ce  e00c              B        |L14.234|
                  |L14.208|
;;;1047           }
;;;1048           
;;;1049           break;
;;;1050           /* Periodic transfer */
;;;1051         case EP_TYPE_INTR:
;;;1052         case EP_TYPE_ISOC:
;;;1053           hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
0000d0  696a              LDR      r2,[r5,#0x14]
0000d2  6912              LDR      r2,[r2,#0x10]
0000d4  1cc0              ADDS     r0,r0,#3
;;;1054           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000d6  f3c0008f          UBFX     r0,r0,#2,#16
;;;1055           /* check if there is enough space in FIFO space */
;;;1056           if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
0000da  b292              UXTH     r2,r2
0000dc  4282              CMP      r2,r0
0000de  d204              BCS      |L14.234|
;;;1057           {
;;;1058             /* need to process data in ptxfempty interrupt */
;;;1059             intmsk.b.ptxfempty = 1;
;;;1060             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000e0  68e8              LDR      r0,[r5,#0xc]
0000e2  6982              LDR      r2,[r0,#0x18]
0000e4  f0426280          ORR      r2,r2,#0x4000000
0000e8  6182              STR      r2,[r0,#0x18]
                  |L14.234|
;;;1061           }
;;;1062           break;
;;;1063           
;;;1064         default:
;;;1065           break;
;;;1066         }
;;;1067         
;;;1068         /* Write packet into the Tx FIFO. */
;;;1069         USB_OTG_WritePacket(pdev, 
0000ea  f8b403bc          LDRH     r0,[r4,#0x3bc]
0000ee  460a              MOV      r2,r1
0000f0  b283              UXTH     r3,r0
0000f2  f8d403b8          LDR      r0,[r4,#0x3b8]
0000f6  4601              MOV      r1,r0
0000f8  4628              MOV      r0,r5
0000fa  f7fffffe          BL       USB_OTG_WritePacket
                  |L14.254|
;;;1070                             pdev->host.hc[hc_num].xfer_buff , 
;;;1071                             hc_num, pdev->host.hc[hc_num].xfer_len);
;;;1072       }
;;;1073     }
;;;1074     return status;
0000fe  4630              MOV      r0,r6
;;;1075   }
000100  bdf0              POP      {r4-r7,pc}
;;;1076   
                          ENDP


                          AREA ||i.USB_OTG_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitFSLSPClkSel PROC
;;;789    */
;;;790    void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
000000  6942              LDR      r2,[r0,#0x14]
;;;791    {
;;;792      USB_OTG_HCFG_TypeDef   hcfg;
;;;793      
;;;794      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000002  6810              LDR      r0,[r2,#0]
;;;795      hcfg.b.fslspclksel = freq;
000004  f3610001          BFI      r0,r1,#0,#2
;;;796      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000008  6010              STR      r0,[r2,#0]
;;;797    }
00000a  4770              BX       lr
;;;798    
                          ENDP


                          AREA ||i.USB_OTG_IsDeviceMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsDeviceMode PROC
;;;564    */
;;;565    uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
000002  6940              LDR      r0,[r0,#0x14]
000004  f0100f01          TST      r0,#1
;;;566    {
000008  d001              BEQ      |L16.14|
;;;567      return (USB_OTG_GetMode(pdev) != HOST_MODE);
00000a  2000              MOVS     r0,#0
;;;568    }
00000c  4770              BX       lr
                  |L16.14|
00000e  2001              MOVS     r0,#1                 ;567
000010  4770              BX       lr
;;;569    
                          ENDP


                          AREA ||i.USB_OTG_IsEvenFrame||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsEvenFrame PROC
;;;715    */
;;;716    uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
000000  6940              LDR      r0,[r0,#0x14]
;;;717    {
;;;718      return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
000002  6880              LDR      r0,[r0,#8]
000004  f3400000          SBFX     r0,r0,#0,#1
000008  1c40              ADDS     r0,r0,#1
;;;719    }
00000a  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.USB_OTG_IsHostMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsHostMode PROC
;;;575    */
;;;576    uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
000002  6940              LDR      r0,[r0,#0x14]
000004  f0100001          ANDS     r0,r0,#1
;;;577    {
000008  d000              BEQ      |L18.12|
;;;578      return (USB_OTG_GetMode(pdev) == HOST_MODE);
00000a  2001              MOVS     r0,#1
                  |L18.12|
;;;579    }
00000c  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.USB_OTG_ReadCoreItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadCoreItr PROC
;;;586    */
;;;587    uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;588    {
;;;589      uint32_t v = 0;
;;;590      v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
000002  6941              LDR      r1,[r0,#0x14]
;;;591      v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
000004  6980              LDR      r0,[r0,#0x18]
000006  4008              ANDS     r0,r0,r1
;;;592      return v;
;;;593    }
000008  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.USB_OTG_ReadHPRT0||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHPRT0 PROC
;;;804    */
;;;805    uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
000000  f8d000cc          LDR      r0,[r0,#0xcc]
;;;806    {
;;;807      USB_OTG_HPRT0_TypeDef  hprt0;
;;;808      
;;;809      hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
000004  6800              LDR      r0,[r0,#0]
;;;810      hprt0.b.prtena = 0;
;;;811      hprt0.b.prtconndet = 0;
;;;812      hprt0.b.prtenchng = 0;
;;;813      hprt0.b.prtovrcurrchng = 0;
000006  f020002e          BIC      r0,r0,#0x2e
;;;814      return hprt0.d32;
;;;815    }
00000a  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.USB_OTG_ReadHostAllChannels_intr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHostAllChannels_intr PROC
;;;822    */
;;;823    uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
000000  6940              LDR      r0,[r0,#0x14]
;;;824    {
;;;825      return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
000002  6940              LDR      r0,[r0,#0x14]
;;;826    }
000004  4770              BX       lr
;;;827    
                          ENDP


                          AREA ||i.USB_OTG_ReadOtgItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadOtgItr PROC
;;;600    */
;;;601    uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;602    {
;;;603      return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
000002  6840              LDR      r0,[r0,#4]
;;;604    }
000004  4770              BX       lr
;;;605    
                          ENDP


                          AREA ||i.USB_OTG_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadPacket PROC
;;;196    */
;;;197    void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
000000  4603              MOV      r3,r0
;;;198                             uint8_t *dest, 
;;;199                             uint16_t len)
;;;200    {
000002  b510              PUSH     {r4,lr}
;;;201      uint32_t i=0;
000004  2000              MOVS     r0,#0
000006  1cd2              ADDS     r2,r2,#3
;;;202      uint32_t count32b = (len + 3) / 4;
000008  0892              LSRS     r2,r2,#2
;;;203      
;;;204      __IO uint32_t *fifo = pdev->regs.DFIFO[0];
00000a  f8d330d0          LDR      r3,[r3,#0xd0]
00000e  e003              B        |L23.24|
                  |L23.16|
;;;205      
;;;206      for ( i = 0; i < count32b; i++, dest += 4 )
;;;207      {
;;;208        *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
000010  681c              LDR      r4,[r3,#0]
000012  f8414b04          STR      r4,[r1],#4
000016  1c40              ADDS     r0,r0,#1
                  |L23.24|
000018  4290              CMP      r0,r2                 ;206
00001a  d3f9              BCC      |L23.16|
;;;209        
;;;210      }
;;;211      return ((void *)dest);
00001c  4608              MOV      r0,r1
;;;212    }
00001e  bd10              POP      {r4,pc}
;;;213    
                          ENDP


                          AREA ||i.USB_OTG_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_OTG_ResetPort PROC
;;;835    */
;;;836    uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;837    {
000002  4604              MOV      r4,r0
;;;838      USB_OTG_HPRT0_TypeDef  hprt0;
;;;839      
;;;840      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
000004  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;841      hprt0.b.prtrst = 1;
000008  f4407580          ORR      r5,r0,#0x100
;;;842      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00000c  f8540fcc          LDR      r0,[r4,#0xcc]!
000010  6005              STR      r5,[r0,#0]
;;;843      USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
000012  200a              MOVS     r0,#0xa
000014  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;844      hprt0.b.prtrst = 0;
;;;845      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000018  6821              LDR      r1,[r4,#0]
00001a  f4257080          BIC      r0,r5,#0x100          ;844
00001e  6008              STR      r0,[r1,#0]
;;;846      USB_OTG_BSP_mDelay (20);   
000020  2014              MOVS     r0,#0x14
000022  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;847      return 1;
000026  2001              MOVS     r0,#1
;;;848    }
000028  bd70              POP      {r4-r6,pc}
;;;849    
                          ENDP


                          AREA ||i.USB_OTG_SelectCore||, CODE, READONLY, ALIGN=2

                  USB_OTG_SelectCore PROC
;;;220    */
;;;221    USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;222                                   USB_OTG_CORE_ID_TypeDef coreID)
;;;223    {
;;;224      uint32_t i , baseAddress = 0;
000002  2200              MOVS     r2,#0
;;;225      USB_OTG_STS status = USB_OTG_OK;
;;;226      
;;;227      pdev->cfg.dma_enable       = 0;
000004  70c2              STRB     r2,[r0,#3]
;;;228      
;;;229      /* at startup the core is in FS mode */
;;;230      pdev->cfg.speed            = USB_OTG_SPEED_FULL;
000006  2301              MOVS     r3,#1
000008  7083              STRB     r3,[r0,#2]
;;;231      pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
00000a  2640              MOVS     r6,#0x40
00000c  8086              STRH     r6,[r0,#4]
;;;232      
;;;233      /* initialize device cfg following its address */
;;;234      if (coreID == USB_OTG_FS_CORE_ID)
;;;235      {
;;;236        baseAddress                = USB_OTG_FS_BASE_ADDR;
;;;237        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
;;;238        pdev->cfg.host_channels    = 8 ;
;;;239        pdev->cfg.dev_endpoints    = 4 ;
;;;240        pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
;;;241        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
00000e  2602              MOVS     r6,#2
000010  4614              MOV      r4,r2                 ;225
000012  4615              MOV      r5,r2                 ;227
000014  2901              CMP      r1,#1                 ;234
000016  d001              BEQ      |L25.28|
;;;242        
;;;243    #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
;;;244        pdev->cfg.Sof_output       = 1;    
;;;245    #endif 
;;;246        
;;;247    #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
;;;248        pdev->cfg.low_power        = 1;    
;;;249    #endif     
;;;250      }
;;;251      else if (coreID == USB_OTG_HS_CORE_ID)
000018  b159              CBZ      r1,|L25.50|
00001a  e015              B        |L25.72|
                  |L25.28|
00001c  72c3              STRB     r3,[r0,#0xb]          ;237
00001e  2108              MOVS     r1,#8                 ;238
000020  7001              STRB     r1,[r0,#0]            ;238
000022  2104              MOVS     r1,#4                 ;239
000024  f04f42a0          MOV      r2,#0x50000000        ;236
000028  7041              STRB     r1,[r0,#1]            ;239
00002a  1591              ASRS     r1,r2,#22             ;240
00002c  80c1              STRH     r1,[r0,#6]            ;240
00002e  7206              STRB     r6,[r0,#8]            ;241
000030  e00a              B        |L25.72|
                  |L25.50|
;;;252      {
;;;253        baseAddress                = USB_OTG_HS_BASE_ADDR;
;;;254        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
000032  72c5              STRB     r5,[r0,#0xb]
;;;255        pdev->cfg.host_channels    = 12 ;
000034  210c              MOVS     r1,#0xc
000036  7001              STRB     r1,[r0,#0]
;;;256        pdev->cfg.dev_endpoints    = 6 ;
000038  2106              MOVS     r1,#6
00003a  7041              STRB     r1,[r0,#1]
;;;257        pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
00003c  f44f61a0          MOV      r1,#0x500
000040  80c1              STRH     r1,[r0,#6]
000042  4a1f              LDR      r2,|L25.192|
;;;258        
;;;259    #ifdef USB_OTG_ULPI_PHY_ENABLED
;;;260        pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
;;;261    #else    
;;;262    #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
;;;263        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
000044  7206              STRB     r6,[r0,#8]
;;;264    #endif  
;;;265    #endif      
;;;266        
;;;267    #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
;;;268        pdev->cfg.dma_enable       = 1;    
000046  70c3              STRB     r3,[r0,#3]
                  |L25.72|
;;;269    #endif
;;;270        
;;;271    #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
;;;272        pdev->cfg.Sof_output       = 1;    
;;;273    #endif 
;;;274        
;;;275    #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
;;;276        pdev->cfg.low_power        = 1;    
;;;277    #endif 
;;;278        
;;;279      }
;;;280      
;;;281      pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
;;;282        USB_OTG_CORE_GLOBAL_REGS_OFFSET);
;;;283      pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
000048  f5026100          ADD      r1,r2,#0x800
00004c  e9c02103          STRD     r2,r1,[r0,#0xc]
;;;284        USB_OTG_DEV_GLOBAL_REG_OFFSET);
;;;285      
;;;286      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
000050  2100              MOVS     r1,#0
000052  e00a              B        |L25.106|
                  |L25.84|
;;;287      {
;;;288        pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
000054  eb021341          ADD      r3,r2,r1,LSL #5
000058  f5036610          ADD      r6,r3,#0x900
00005c  eb000581          ADD      r5,r0,r1,LSL #2
000060  f5036330          ADD      r3,r3,#0xb00
;;;289          (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
;;;290            (i * USB_OTG_EP_REG_OFFSET));
;;;291        pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
000064  61ae              STR      r6,[r5,#0x18]
000066  1c49              ADDS     r1,r1,#1
000068  656b              STR      r3,[r5,#0x54]
                  |L25.106|
00006a  7843              LDRB     r3,[r0,#1]            ;286
00006c  428b              CMP      r3,r1                 ;286
00006e  d8f1              BHI      |L25.84|
;;;292          (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
;;;293            (i * USB_OTG_EP_REG_OFFSET));
;;;294      }
;;;295      pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
000070  f5026180          ADD      r1,r2,#0x400
;;;296        USB_OTG_HOST_GLOBAL_REG_OFFSET);
;;;297      pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
000074  6141              STR      r1,[r0,#0x14]
000076  3140              ADDS     r1,r1,#0x40
;;;298      
;;;299      for (i = 0; i < pdev->cfg.host_channels; i++)
000078  f8c010cc          STR      r1,[r0,#0xcc]
00007c  2100              MOVS     r1,#0
00007e  e008              B        |L25.146|
                  |L25.128|
;;;300      {
;;;301        pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
000080  eb021341          ADD      r3,r2,r1,LSL #5
000084  eb000581          ADD      r5,r0,r1,LSL #2
000088  f50363a0          ADD      r3,r3,#0x500
00008c  1c49              ADDS     r1,r1,#1
00008e  f8c53090          STR      r3,[r5,#0x90]
                  |L25.146|
000092  7803              LDRB     r3,[r0,#0]            ;299
000094  428b              CMP      r3,r1                 ;299
000096  d8f3              BHI      |L25.128|
;;;302          USB_OTG_HOST_CHAN_REGS_OFFSET + \
;;;303            (i * USB_OTG_CHAN_REGS_OFFSET));
;;;304      }
;;;305      for (i = 0; i < pdev->cfg.host_channels; i++)
000098  2100              MOVS     r1,#0
00009a  e008              B        |L25.174|
                  |L25.156|
;;;306      {
;;;307        pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
00009c  eb023301          ADD      r3,r2,r1,LSL #12
0000a0  eb000581          ADD      r5,r0,r1,LSL #2
0000a4  f5035380          ADD      r3,r3,#0x1000
0000a8  1c49              ADDS     r1,r1,#1
0000aa  f8c530d0          STR      r3,[r5,#0xd0]
                  |L25.174|
0000ae  7803              LDRB     r3,[r0,#0]            ;305
0000b0  428b              CMP      r3,r1                 ;305
0000b2  d8f3              BHI      |L25.156|
0000b4  f5026260          ADD      r2,r2,#0xe00          ;305
;;;308          (i * USB_OTG_DATA_FIFO_SIZE));
;;;309      }
;;;310      pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
;;;311      
;;;312      return status;
0000b8  f8c0210c          STR      r2,[r0,#0x10c]
0000bc  4620              MOV      r0,r4
;;;313    }
0000be  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

                  |L25.192|
                          DCD      0x40040000

                          AREA ||i.USB_OTG_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetCurrentMode PROC
;;;523    */
;;;524    USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
000000  b510              PUSH     {r4,lr}
;;;525    {
;;;526      USB_OTG_STS status = USB_OTG_OK;
;;;527      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;528      
;;;529      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
000002  68c0              LDR      r0,[r0,#0xc]
000004  2400              MOVS     r4,#0                 ;526
000006  68c2              LDR      r2,[r0,#0xc]
;;;530      
;;;531      usbcfg.b.force_host = 0;
;;;532      usbcfg.b.force_dev = 0;
;;;533      
;;;534      if ( mode == HOST_MODE)
000008  2901              CMP      r1,#1
00000a  f02242c0          BIC      r2,r2,#0x60000000     ;532
00000e  d001              BEQ      |L26.20|
;;;535      {
;;;536        usbcfg.b.force_host = 1;
;;;537      }
;;;538      else if ( mode == DEVICE_MODE)
000010  b119              CBZ      r1,|L26.26|
000012  e004              B        |L26.30|
                  |L26.20|
000014  f0425200          ORR      r2,r2,#0x20000000     ;536
000018  e001              B        |L26.30|
                  |L26.26|
;;;539      {
;;;540        usbcfg.b.force_dev = 1;
00001a  f0424280          ORR      r2,r2,#0x40000000
                  |L26.30|
;;;541      }
;;;542      
;;;543      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00001e  60c2              STR      r2,[r0,#0xc]
;;;544      USB_OTG_BSP_mDelay(50);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;545      return status;
000026  4620              MOV      r0,r4
;;;546    }
000028  bd10              POP      {r4,pc}
;;;547    
                          ENDP


                          AREA ||i.USB_OTG_StopHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_StopHost PROC
;;;1145   */
;;;1146   void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;1147   {
000002  4604              MOV      r4,r0
;;;1148     USB_OTG_HCCHAR_TypeDef  hcchar;
;;;1149     uint32_t                i;
;;;1150     
;;;1151     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
000004  2000              MOVS     r0,#0
000006  6961              LDR      r1,[r4,#0x14]
000008  6188              STR      r0,[r1,#0x18]
;;;1152     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
00000a  6961              LDR      r1,[r4,#0x14]
00000c  1e40              SUBS     r0,r0,#1
00000e  6148              STR      r0,[r1,#0x14]
;;;1153     /* Flush out any leftover queued requests. */
;;;1154     
;;;1155     for (i = 0; i < pdev->cfg.host_channels; i++)
000010  2000              MOVS     r0,#0
000012  e00a              B        |L27.42|
                  |L27.20|
;;;1156     {
;;;1157       hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
000014  eb040180          ADD      r1,r4,r0,LSL #2
000018  f8d11090          LDR      r1,[r1,#0x90]
00001c  680a              LDR      r2,[r1,#0]
;;;1158       hcchar.b.chen = 0;
;;;1159       hcchar.b.chdis = 1;
00001e  f0222280          BIC      r2,r2,#0x80008000
;;;1160       hcchar.b.epdir = 0;
000022  f0424280          ORR      r2,r2,#0x40000000
;;;1161       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
000026  600a              STR      r2,[r1,#0]
000028  1c40              ADDS     r0,r0,#1
                  |L27.42|
00002a  7821              LDRB     r1,[r4,#0]            ;1155
00002c  4281              CMP      r1,r0                 ;1155
00002e  d8f1              BHI      |L27.20|
;;;1162     }
;;;1163     
;;;1164     /* Flush the FIFO */
;;;1165     USB_OTG_FlushRxFifo(pdev);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;1166     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
000036  4620              MOV      r0,r4
000038  e8bd4010          POP      {r4,lr}
00003c  2110              MOVS     r1,#0x10
00003e  f7ffbffe          B.W      USB_OTG_FlushTxFifo
;;;1167   }
;;;1168   #endif
                          ENDP


                          AREA ||i.USB_OTG_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_WritePacket PROC
;;;167    */
;;;168    USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b530              PUSH     {r4,r5,lr}
;;;169                                    uint8_t             *src, 
;;;170                                    uint8_t             ch_ep_num, 
;;;171                                    uint16_t            len)
;;;172    {
;;;173      USB_OTG_STS status = USB_OTG_OK;
;;;174      if (pdev->cfg.dma_enable == 0)
000002  78c4              LDRB     r4,[r0,#3]
000004  2500              MOVS     r5,#0                 ;173
000006  b96c              CBNZ     r4,|L28.36|
;;;175      {
;;;176        uint32_t count32b= 0 , i= 0;
;;;177        __IO uint32_t *fifo;
;;;178        
;;;179        count32b =  (len + 3) / 4;
;;;180        fifo = pdev->regs.DFIFO[ch_ep_num];
000008  eb000082          ADD      r0,r0,r2,LSL #2
00000c  2400              MOVS     r4,#0                 ;176
00000e  1cdb              ADDS     r3,r3,#3              ;176
000010  089b              LSRS     r3,r3,#2              ;179
000012  f8d000d0          LDR      r0,[r0,#0xd0]
;;;181        for (i = 0; i < count32b; i++, src+=4)
000016  e003              B        |L28.32|
                  |L28.24|
;;;182        {
;;;183          USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
000018  f8512b04          LDR      r2,[r1],#4
00001c  6002              STR      r2,[r0,#0]
00001e  1c64              ADDS     r4,r4,#1
                  |L28.32|
000020  429c              CMP      r4,r3                 ;181
000022  d3f9              BCC      |L28.24|
                  |L28.36|
;;;184        }
;;;185      }
;;;186      return status;
000024  4628              MOV      r0,r5
;;;187    }
000026  bd30              POP      {r4,r5,pc}
;;;188    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_OTG_Driver\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_core_c_0d2ec05c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REVSH|
#line 144
|__asm___10_usb_core_c_0d2ec05c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
