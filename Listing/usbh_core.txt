; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usbh_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usbh_core.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=537 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\usbh_core.crf --no_multibyte_chars ..\USB\STM32_USB_HOST_Library\Core\src\usbh_core.c]
                          THUMB

                          AREA ||i.USBH_Connected||, CODE, READONLY, ALIGN=1

                  USBH_Connected PROC
;;;117    */
;;;118    uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
000000  2101              MOVS     r1,#1
;;;119    {
;;;120      pdev->host.ConnSts = 1;
000002  f8c01310          STR      r1,[r0,#0x310]
;;;121      return 0;
000006  2000              MOVS     r0,#0
;;;122    }
000008  4770              BX       lr
;;;123    
                          ENDP


                          AREA ||i.USBH_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_DeInit PROC
;;;192      */
;;;193    USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  460c              MOV      r4,r1
;;;195      /* Software Init */
;;;196      
;;;197      phost->gState = HOST_IDLE;
000004  2100              MOVS     r1,#0
000006  7021              STRB     r1,[r4,#0]
;;;198      phost->gStateBkp = HOST_IDLE; 
000008  7061              STRB     r1,[r4,#1]
;;;199      phost->EnumState = ENUM_IDLE;
00000a  70a1              STRB     r1,[r4,#2]
;;;200      phost->RequestState = CMD_SEND;  
00000c  2201              MOVS     r2,#1
00000e  4605              MOV      r5,r0                 ;194
000010  70e2              STRB     r2,[r4,#3]
;;;201      
;;;202      phost->Control.state = CTRL_SETUP;
000012  7722              STRB     r2,[r4,#0x1c]
;;;203      phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
000014  2040              MOVS     r0,#0x40
000016  71a0              STRB     r0,[r4,#6]
;;;204      
;;;205      phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
000018  f8841020          STRB     r1,[r4,#0x20]
;;;206      phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
00001c  f8842021          STRB     r2,[r4,#0x21]
;;;207      
;;;208      USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
000020  7921              LDRB     r1,[r4,#4]
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USBH_Free_Channel
;;;209      USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
000028  7961              LDRB     r1,[r4,#5]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       USBH_Free_Channel
;;;210      return USBH_OK;
000030  2000              MOVS     r0,#0
;;;211    }
000032  bd70              POP      {r4-r6,pc}
;;;212    
                          ENDP


                          AREA ||i.USBH_Disconnected||, CODE, READONLY, ALIGN=1

                  USBH_Disconnected PROC
;;;130    
;;;131    uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
000000  2100              MOVS     r1,#0
;;;132    {
;;;133      pdev->host.ConnSts = 0;
000002  f8c01310          STR      r1,[r0,#0x310]
;;;134      return 0;  
000006  4608              MOV      r0,r1
;;;135    }
000008  4770              BX       lr
;;;136    
                          ENDP


                          AREA ||i.USBH_ErrorHandle||, CODE, READONLY, ALIGN=1

                  USBH_ErrorHandle PROC
;;;370      */
;;;371    void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
;;;373      /* Error unrecovered or not supported device speed */
;;;374      if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
;;;375           (errType == USBH_UNRECOVERED_ERROR) )
;;;376      {
;;;377        phost->usr_cb->UnrecoveredError(); 
;;;378        phost->gState = HOST_ERROR_STATE;   
000002  250a              MOVS     r5,#0xa
000004  4604              MOV      r4,r0                 ;372
000006  2905              CMP      r1,#5                 ;374
000008  d00a              BEQ      |L4.32|
00000a  2904              CMP      r1,#4                 ;375
00000c  d008              BEQ      |L4.32|
;;;379      }  
;;;380      /* USB host restart requested from application layer */
;;;381      else if(errType == USBH_APPLY_DEINIT)
00000e  2906              CMP      r1,#6
000010  d10b              BNE      |L4.42|
;;;382      {
;;;383        phost->gState = HOST_ERROR_STATE;  
000012  7025              STRB     r5,[r4,#0]
;;;384        /* user callback for initalization */
;;;385        phost->usr_cb->Init();
000014  f8d00080          LDR      r0,[r0,#0x80]
000018  6800              LDR      r0,[r0,#0]
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  4700              BX       r0
                  |L4.32|
000020  f8d40080          LDR      r0,[r4,#0x80]         ;377
000024  6c40              LDR      r0,[r0,#0x44]         ;377
000026  4780              BLX      r0                    ;377
000028  7025              STRB     r5,[r4,#0]            ;378
                  |L4.42|
;;;386      } 
;;;387    }
00002a  bd70              POP      {r4-r6,pc}
;;;388    
                          ENDP


                          AREA ||i.USBH_HandleControl||, CODE, READONLY, ALIGN=2

                  USBH_HandleControl PROC
;;;586      */
;;;587    USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;588    {
;;;589      uint8_t direction;  
;;;590      static uint16_t timeout = 0;
;;;591      USBH_Status status = USBH_OK;
000004  2600              MOVS     r6,#0
000006  4680              MOV      r8,r0                 ;588
;;;592      URB_STATE URB_Status = URB_IDLE;
;;;593      
;;;594      phost->Control.status = CTRL_START;
000008  748e              STRB     r6,[r1,#0x12]
00000a  460c              MOV      r4,r1                 ;588
;;;595    
;;;596      
;;;597      switch (phost->Control.state)
00000c  7f08              LDRB     r0,[r1,#0x1c]
00000e  250b              MOVS     r5,#0xb
000010  2709              MOVS     r7,#9
000012  2101              MOVS     r1,#1
;;;598      {
;;;599      case CTRL_SETUP:
;;;600        /* send a SETUP packet */
;;;601        USBH_CtlSendSetup     (pdev, 
;;;602    	                   phost->Control.setup.d8 , 
;;;603    	                   phost->Control.hc_num_out);  
;;;604        phost->Control.state = CTRL_SETUP_WAIT;  
;;;605        break; 
;;;606        
;;;607      case CTRL_SETUP_WAIT:
;;;608        
;;;609        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
;;;610        /* case SETUP packet sent successfully */
;;;611        if(URB_Status == URB_DONE)
;;;612        { 
;;;613          direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
;;;614          
;;;615          /* check if there is a data stage */
;;;616          if (phost->Control.setup.b.wLength.w != 0 )
;;;617          {        
;;;618            timeout = DATA_STAGE_TIMEOUT;
000014  f8df91b8          LDR      r9,|L5.464|
000018  f04f0b08          MOV      r11,#8                ;597
00001c  f04f0a05          MOV      r10,#5                ;597
000020  280c              CMP      r0,#0xc               ;597
000022  d217              BCS      |L5.84|
000024  e8dff000          TBB      [pc,r0]               ;597
000028  d1060e39          DCB      0xd1,0x06,0x0e,0x39
00002c  415a677b          DCB      0x41,0x5a,0x67,0x7b
000030  849eafc4          DCB      0x84,0x9e,0xaf,0xc4
000034  7962              LDRB     r2,[r4,#5]            ;601
000036  f1040114          ADD      r1,r4,#0x14           ;601
00003a  4640              MOV      r0,r8                 ;601
00003c  f7fffffe          BL       USBH_CtlSendSetup
000040  2002              MOVS     r0,#2                 ;604
000042  e0ae              B        |L5.418|
000044  7961              LDRB     r1,[r4,#5]            ;609
000046  4640              MOV      r0,r8                 ;609
000048  f7fffffe          BL       HCD_GetURB_State
00004c  2801              CMP      r0,#1                 ;611
00004e  d002              BEQ      |L5.86|
;;;619            if (direction == USB_D2H)
;;;620            {
;;;621              /* Data Direction is IN */
;;;622              phost->Control.state = CTRL_DATA_IN;
;;;623            }
;;;624            else
;;;625            {
;;;626              /* Data Direction is OUT */
;;;627              phost->Control.state = CTRL_DATA_OUT;
;;;628            } 
;;;629          }
;;;630          /* No DATA stage */
;;;631          else
;;;632          {
;;;633            timeout = NODATA_STAGE_TIMEOUT;
;;;634            
;;;635            /* If there is No Data Transfer Stage */
;;;636            if (direction == USB_D2H)
;;;637            {
;;;638              /* Data Direction is IN */
;;;639              phost->Control.state = CTRL_STATUS_OUT;
;;;640            }
;;;641            else
;;;642            {
;;;643              /* Data Direction is OUT */
;;;644              phost->Control.state = CTRL_STATUS_IN;
;;;645            } 
;;;646          }          
;;;647          /* Set the delay timer to enable timeout for data stage completion */
;;;648          phost->Control.timer = HCD_GetCurrentFrame(pdev);
;;;649        }
;;;650        else if(URB_Status == URB_ERROR)
000050  2803              CMP      r0,#3
000052  d01e              BEQ      |L5.146|
                  |L5.84|
000054  e0b9              B        |L5.458|
                  |L5.86|
000056  7d20              LDRB     r0,[r4,#0x14]         ;613
000058  8b61              LDRH     r1,[r4,#0x1a]         ;616
00005a  f0000080          AND      r0,r0,#0x80           ;613
00005e  b151              CBZ      r1,|L5.118|
000060  f2413288          MOV      r2,#0x1388            ;618
000064  f8a92000          STRH     r2,[r9,#0]            ;618
000068  2880              CMP      r0,#0x80              ;619
00006a  d002              BEQ      |L5.114|
00006c  f884a01c          STRB     r10,[r4,#0x1c]        ;627
000070  e008              B        |L5.132|
                  |L5.114|
000072  2003              MOVS     r0,#3                 ;622
000074  e005              B        |L5.130|
                  |L5.118|
000076  2232              MOVS     r2,#0x32              ;633
000078  f8a92000          STRH     r2,[r9,#0]            ;633
00007c  2880              CMP      r0,#0x80              ;636
00007e  d006              BEQ      |L5.142|
000080  2007              MOVS     r0,#7                 ;644
                  |L5.130|
000082  7720              STRB     r0,[r4,#0x1c]         ;644
                  |L5.132|
000084  4640              MOV      r0,r8                 ;648
000086  f7fffffe          BL       HCD_GetCurrentFrame
00008a  8220              STRH     r0,[r4,#0x10]         ;648
00008c  e09d              B        |L5.458|
                  |L5.142|
00008e  7727              STRB     r7,[r4,#0x1c]         ;639
000090  e7f8              B        |L5.132|
                  |L5.146|
;;;651        {
;;;652          phost->Control.state = CTRL_ERROR;     
000092  7725              STRB     r5,[r4,#0x1c]
;;;653          phost->Control.status = CTRL_XACTERR;
000094  f884a012          STRB     r10,[r4,#0x12]
000098  e097              B        |L5.458|
;;;654        }    
;;;655        break;
;;;656        
;;;657      case CTRL_DATA_IN:  
;;;658        /* Issue an IN token */ 
;;;659        USBH_CtlReceiveData(pdev,
00009a  7923              LDRB     r3,[r4,#4]
00009c  89a2              LDRH     r2,[r4,#0xc]
00009e  4640              MOV      r0,r8
0000a0  68a1              LDR      r1,[r4,#8]
0000a2  f7fffffe          BL       USBH_CtlReceiveData
;;;660                            phost->Control.buff, 
;;;661                            phost->Control.length,
;;;662                            phost->Control.hc_num_in);
;;;663     
;;;664        phost->Control.state = CTRL_DATA_IN_WAIT;
0000a6  2004              MOVS     r0,#4
;;;665        break;    
0000a8  e07b              B        |L5.418|
;;;666        
;;;667      case CTRL_DATA_IN_WAIT:
;;;668        
;;;669        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
0000aa  7921              LDRB     r1,[r4,#4]
0000ac  4640              MOV      r0,r8
0000ae  f7fffffe          BL       HCD_GetURB_State
;;;670        
;;;671        /* check is DATA packet transfered successfully */
;;;672        if  (URB_Status == URB_DONE)
0000b2  2801              CMP      r0,#1
0000b4  d00d              BEQ      |L5.210|
;;;673        { 
;;;674          phost->Control.state = CTRL_STATUS_OUT;
;;;675        }
;;;676       
;;;677        /* manage error cases*/
;;;678        if  (URB_Status == URB_STALL) 
0000b6  2804              CMP      r0,#4
0000b8  d00d              BEQ      |L5.214|
;;;679        { 
;;;680          /* In stall case, return to previous machine state*/
;;;681          phost->gState =   phost->gStateBkp;
;;;682        }   
;;;683        else if (URB_Status == URB_ERROR)
0000ba  2803              CMP      r0,#3
0000bc  d076              BEQ      |L5.428|
                  |L5.190|
;;;684        {
;;;685          /* Device error */
;;;686          phost->Control.state = CTRL_ERROR;    
;;;687        }
;;;688        else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
0000be  4640              MOV      r0,r8
0000c0  f7fffffe          BL       HCD_GetCurrentFrame
0000c4  8a21              LDRH     r1,[r4,#0x10]
0000c6  1a41              SUBS     r1,r0,r1
0000c8  f8b90000          LDRH     r0,[r9,#0]  ; timeout
0000cc  4281              CMP      r1,r0
0000ce  d86d              BHI      |L5.428|
0000d0  e07b              B        |L5.458|
                  |L5.210|
0000d2  7727              STRB     r7,[r4,#0x1c]         ;674
0000d4  e7f3              B        |L5.190|
                  |L5.214|
0000d6  7860              LDRB     r0,[r4,#1]            ;681
0000d8  7020              STRB     r0,[r4,#0]            ;681
0000da  e076              B        |L5.458|
;;;689        {
;;;690          /* timeout for IN transfer */
;;;691          phost->Control.state = CTRL_ERROR; 
;;;692        }   
;;;693        break;
;;;694        
;;;695      case CTRL_DATA_OUT:
;;;696        /* Start DATA out transfer (only one DATA packet)*/
;;;697        pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
0000dc  7962              LDRB     r2,[r4,#5]
0000de  eb081042          ADD      r0,r8,r2,LSL #5
0000e2  f88013c5          STRB     r1,[r0,#0x3c5]
;;;698            
;;;699        USBH_CtlSendData (pdev,
0000e6  7963              LDRB     r3,[r4,#5]
0000e8  89a2              LDRH     r2,[r4,#0xc]
0000ea  4640              MOV      r0,r8
0000ec  68a1              LDR      r1,[r4,#8]
0000ee  f7fffffe          BL       USBH_CtlSendData
;;;700                          phost->Control.buff, 
;;;701                          phost->Control.length , 
;;;702                          phost->Control.hc_num_out);
;;;703        
;;;704    
;;;705    
;;;706    
;;;707        
;;;708        phost->Control.state = CTRL_DATA_OUT_WAIT;
0000f2  2006              MOVS     r0,#6
;;;709        break;
0000f4  e055              B        |L5.418|
;;;710        
;;;711      case CTRL_DATA_OUT_WAIT:
;;;712        
;;;713        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
0000f6  7961              LDRB     r1,[r4,#5]
0000f8  4640              MOV      r0,r8
0000fa  f7fffffe          BL       HCD_GetURB_State
;;;714        if  (URB_Status == URB_DONE)
0000fe  2801              CMP      r0,#1
000100  d004              BEQ      |L5.268|
;;;715        { /* If the Setup Pkt is sent successful, then change the state */
;;;716          phost->Control.state = CTRL_STATUS_IN;
;;;717        }
;;;718        
;;;719        /* handle error cases */
;;;720        else if  (URB_Status == URB_STALL) 
000102  2804              CMP      r0,#4
000104  d004              BEQ      |L5.272|
;;;721        { 
;;;722          /* In stall case, return to previous machine state*/
;;;723          phost->gState =   phost->gStateBkp;
;;;724          phost->Control.state = CTRL_STALLED;  
;;;725        } 
;;;726        else if  (URB_Status == URB_NOTREADY)
000106  2802              CMP      r0,#2
000108  d006              BEQ      |L5.280|
00010a  e044              B        |L5.406|
                  |L5.268|
00010c  2007              MOVS     r0,#7                 ;716
00010e  e048              B        |L5.418|
                  |L5.272|
000110  7860              LDRB     r0,[r4,#1]            ;723
000112  7020              STRB     r0,[r4,#0]            ;723
000114  200c              MOVS     r0,#0xc               ;724
000116  e044              B        |L5.418|
                  |L5.280|
;;;727        { 
;;;728          /* Nack received from device */
;;;729          phost->Control.state = CTRL_DATA_OUT;
000118  f884a01c          STRB     r10,[r4,#0x1c]
00011c  e055              B        |L5.458|
;;;730        }    
;;;731        else if (URB_Status == URB_ERROR)
;;;732        {
;;;733          /* device error */
;;;734          phost->Control.state = CTRL_ERROR;      
;;;735        } 
;;;736        break;
;;;737        
;;;738        
;;;739      case CTRL_STATUS_IN:
;;;740        /* Send 0 bytes out packet */
;;;741        USBH_CtlReceiveData (pdev,
00011e  2200              MOVS     r2,#0
000120  7923              LDRB     r3,[r4,#4]
000122  4611              MOV      r1,r2
000124  4640              MOV      r0,r8
000126  f7fffffe          BL       USBH_CtlReceiveData
;;;742                             0,
;;;743                             0,
;;;744                             phost->Control.hc_num_in);
;;;745        
;;;746        phost->Control.state = CTRL_STATUS_IN_WAIT;
00012a  f884b01c          STRB     r11,[r4,#0x1c]
;;;747        
;;;748        break;
00012e  e04c              B        |L5.458|
;;;749        
;;;750      case CTRL_STATUS_IN_WAIT:
;;;751        
;;;752        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
000130  7921              LDRB     r1,[r4,#4]
000132  4640              MOV      r0,r8
000134  f7fffffe          BL       HCD_GetURB_State
000138  4607              MOV      r7,r0
;;;753        
;;;754        if  ( URB_Status == URB_DONE)
00013a  2801              CMP      r0,#1
00013c  d02e              BEQ      |L5.412|
;;;755        { /* Control transfers completed, Exit the State Machine */
;;;756          phost->gState =   phost->gStateBkp;
;;;757          phost->Control.state = CTRL_COMPLETE;
;;;758        }
;;;759        
;;;760        else if (URB_Status == URB_ERROR)
00013e  2f03              CMP      r7,#3
000140  d034              BEQ      |L5.428|
;;;761        {
;;;762          phost->Control.state = CTRL_ERROR;  
;;;763        }
;;;764        
;;;765        else if((HCD_GetCurrentFrame(pdev)\
000142  4640              MOV      r0,r8
000144  f7fffffe          BL       HCD_GetCurrentFrame
000148  8a21              LDRH     r1,[r4,#0x10]
00014a  1a41              SUBS     r1,r0,r1
00014c  f8b90000          LDRH     r0,[r9,#0]  ; timeout
000150  4281              CMP      r1,r0
000152  d82b              BHI      |L5.428|
;;;766          - phost->Control.timer) > timeout)
;;;767        {
;;;768          phost->Control.state = CTRL_ERROR; 
;;;769        }
;;;770         else if(URB_Status == URB_STALL)
000154  2f04              CMP      r7,#4
000156  d138              BNE      |L5.458|
;;;771        {
;;;772          /* Control transfers completed, Exit the State Machine */
;;;773          phost->gState =   phost->gStateBkp;
000158  7860              LDRB     r0,[r4,#1]
00015a  7020              STRB     r0,[r4,#0]
;;;774          phost->Control.status = CTRL_STALL;
00015c  2004              MOVS     r0,#4
00015e  74a0              STRB     r0,[r4,#0x12]
;;;775          status = USBH_NOT_SUPPORTED;
000160  2603              MOVS     r6,#3
000162  e032              B        |L5.458|
;;;776        }
;;;777        break;
;;;778        
;;;779      case CTRL_STATUS_OUT:
;;;780        pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
000164  7961              LDRB     r1,[r4,#5]
;;;781        USBH_CtlSendData (pdev,
000166  2200              MOVS     r2,#0
000168  eb081041          ADD      r0,r8,r1,LSL #5       ;780
00016c  f89013c5          LDRB     r1,[r0,#0x3c5]        ;780
000170  f0810101          EOR      r1,r1,#1              ;780
000174  f88013c5          STRB     r1,[r0,#0x3c5]        ;780
000178  7963              LDRB     r3,[r4,#5]
00017a  4611              MOV      r1,r2
00017c  4640              MOV      r0,r8
00017e  f7fffffe          BL       USBH_CtlSendData
;;;782                          0,
;;;783                          0,
;;;784                          phost->Control.hc_num_out);
;;;785        
;;;786        phost->Control.state = CTRL_STATUS_OUT_WAIT;
000182  200a              MOVS     r0,#0xa
;;;787        break;
000184  e00d              B        |L5.418|
;;;788        
;;;789      case CTRL_STATUS_OUT_WAIT: 
;;;790        
;;;791        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
000186  7961              LDRB     r1,[r4,#5]
000188  4640              MOV      r0,r8
00018a  f7fffffe          BL       HCD_GetURB_State
;;;792        if  (URB_Status == URB_DONE)
00018e  2801              CMP      r0,#1
000190  d004              BEQ      |L5.412|
;;;793        { 
;;;794          phost->gState =   phost->gStateBkp; 
;;;795          phost->Control.state = CTRL_COMPLETE; 
;;;796        }
;;;797        else if  (URB_Status == URB_NOTREADY)
000192  2802              CMP      r0,#2
000194  d008              BEQ      |L5.424|
                  |L5.406|
;;;798        { 
;;;799          phost->Control.state = CTRL_STATUS_OUT;
;;;800        }      
;;;801        else if (URB_Status == URB_ERROR)
000196  2803              CMP      r0,#3
000198  d008              BEQ      |L5.428|
00019a  e016              B        |L5.458|
                  |L5.412|
00019c  7860              LDRB     r0,[r4,#1]            ;794
00019e  7020              STRB     r0,[r4,#0]            ;794
0001a0  200d              MOVS     r0,#0xd               ;795
                  |L5.418|
0001a2  7720              STRB     r0,[r4,#0x1c]         ;795
0001a4  e011              B        |L5.458|
0001a6  e001              B        |L5.428|
                  |L5.424|
0001a8  7727              STRB     r7,[r4,#0x1c]         ;799
0001aa  e00e              B        |L5.458|
                  |L5.428|
;;;802        {
;;;803          phost->Control.state = CTRL_ERROR;      
0001ac  7725              STRB     r5,[r4,#0x1c]
0001ae  e00c              B        |L5.458|
;;;804        }
;;;805        break;
;;;806        
;;;807      case CTRL_ERROR:
;;;808        /* 
;;;809        After a halt condition is encountered or an error is detected by the 
;;;810        host, a control endpoint is allowed to recover by accepting the next Setup 
;;;811        PID; i.e., recovery actions via some other pipe are not required for control
;;;812        endpoints. For the Default Control Pipe, a device reset will ultimately be 
;;;813        required to clear the halt or error condition if the next Setup PID is not 
;;;814        accepted.
;;;815        */
;;;816        if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
0001b0  7ba0              LDRB     r0,[r4,#0xe]
0001b2  1c40              ADDS     r0,r0,#1
0001b4  b2c0              UXTB     r0,r0
0001b6  73a0              STRB     r0,[r4,#0xe]
0001b8  2802              CMP      r0,#2
0001ba  d801              BHI      |L5.448|
;;;817        {
;;;818          /* Do the transmission again, starting from SETUP Packet */
;;;819          phost->Control.state = CTRL_SETUP; 
0001bc  7721              STRB     r1,[r4,#0x1c]
0001be  e004              B        |L5.458|
                  |L5.448|
;;;820        }
;;;821        else
;;;822        {
;;;823          phost->Control.status = CTRL_FAIL;
0001c0  f884b012          STRB     r11,[r4,#0x12]
;;;824          phost->gState =   phost->gStateBkp;
0001c4  7860              LDRB     r0,[r4,#1]
0001c6  7020              STRB     r0,[r4,#0]
;;;825          
;;;826          status = USBH_FAIL;
0001c8  2602              MOVS     r6,#2
                  |L5.458|
;;;827        }
;;;828        break;
;;;829        
;;;830      default:
;;;831        break;
;;;832      }
;;;833      return status;
0001ca  4630              MOV      r0,r6
;;;834    }
0001cc  e8bd9ff0          POP      {r4-r12,pc}
;;;835    
                          ENDP

                  |L5.464|
                          DCD      ||area_number.14||

                          AREA ||i.USBH_HandleEnum||, CODE, READONLY, ALIGN=2

                  USBH_HandleEnum PROC
;;;395      */
;;;396    static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;397    {
000004  460c              MOV      r4,r1
000006  4680              MOV      r8,r0
;;;398      USBH_Status Status = USBH_BUSY;  
000008  2501              MOVS     r5,#1
;;;399      uint8_t Local_Buffer[64];
;;;400      
;;;401      switch (phost->EnumState)
00000a  7889              LDRB     r1,[r1,#2]
00000c  2600              MOVS     r6,#0
;;;402      {
;;;403      case ENUM_IDLE:  
;;;404        /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
;;;405        if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
;;;406        {
;;;407          phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
;;;408          
;;;409          /* Issue Reset  */
;;;410          HCD_ResetPort(pdev);
;;;411          phost->EnumState = ENUM_GET_FULL_DEV_DESC;
;;;412          
;;;413          /* modify control channels configuration for MaxPacket size */
;;;414          USBH_Modify_Channel (pdev,
;;;415                               phost->Control.hc_num_out,
;;;416                               0,
;;;417                               0,
;;;418                               0,
;;;419                               phost->Control.ep0size);
;;;420          
;;;421          USBH_Modify_Channel (pdev,
;;;422                               phost->Control.hc_num_in,
;;;423                               0,
;;;424                               0,
;;;425                               0,
;;;426                               phost->Control.ep0size);      
;;;427        }
;;;428        break;
;;;429        
;;;430      case ENUM_GET_FULL_DEV_DESC:  
;;;431        /* Get FULL Device Desc  */
;;;432        if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
;;;433          == USBH_OK)
;;;434        {
;;;435          /* user callback for device descriptor available */
;;;436          phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
;;;437          phost->EnumState = ENUM_SET_ADDR;
;;;438        }
;;;439        break;
;;;440       
;;;441      case ENUM_SET_ADDR: 
;;;442        /* set address */
;;;443        if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
;;;444        {
;;;445          USB_OTG_BSP_mDelay(2);
;;;446          phost->device_prop.address = USBH_DEVICE_ADDRESS;
;;;447          
;;;448          /* user callback for device address assigned */
;;;449          phost->usr_cb->DeviceAddressAssigned();
;;;450          phost->EnumState = ENUM_GET_CFG_DESC;
;;;451          
;;;452          /* modify control channels to update device address */
;;;453          USBH_Modify_Channel (pdev,
;;;454                               phost->Control.hc_num_in,
;;;455                               phost->device_prop.address,
;;;456                               0,
;;;457                               0,
;;;458                               0);
;;;459          
;;;460          USBH_Modify_Channel (pdev,
;;;461                               phost->Control.hc_num_out,
;;;462                               phost->device_prop.address,
;;;463                               0,
;;;464                               0,
;;;465                               0);         
;;;466        }
;;;467        break;
;;;468        
;;;469      case ENUM_GET_CFG_DESC:  
;;;470        /* get standard configuration descriptor */
;;;471        if ( USBH_Get_CfgDesc(pdev, 
;;;472                              phost,
;;;473                              USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
;;;474        {
;;;475          phost->EnumState = ENUM_GET_FULL_CFG_DESC;
;;;476        }
;;;477        break;
;;;478        
;;;479      case ENUM_GET_FULL_CFG_DESC:  
;;;480        /* get FULL config descriptor (config, interface, endpoints) */
;;;481        if (USBH_Get_CfgDesc(pdev, 
;;;482                             phost,
;;;483                             phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
;;;484        {
;;;485          /* User callback for configuration descriptors available */
;;;486          phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
;;;487                                                          phost->device_prop.Itf_Desc,
;;;488                                                          phost->device_prop.Ep_Desc[0]);
;;;489          
;;;490          phost->EnumState = ENUM_GET_MFC_STRING_DESC;
;;;491        }
;;;492        break;
;;;493        
;;;494      case ENUM_GET_MFC_STRING_DESC:  
;;;495        if (phost->device_prop.Dev_Desc.iManufacturer != 0)
;;;496        { /* Check that Manufacturer String is available */
;;;497          
;;;498          if ( USBH_Get_StringDesc(pdev,
00000e  20ff              MOVS     r0,#0xff
000010  b092              SUB      sp,sp,#0x48           ;397
000012  462f              MOV      r7,r5                 ;398
000014  290a              CMP      r1,#0xa               ;401
000016  d256              BCS      |L6.198|
000018  e8dff001          TBB      [pc,r1]               ;401
00001c  05233256          DCB      0x05,0x23,0x32,0x56
000020  5f71849b          DCB      0x5f,0x71,0x84,0x9b
000024  aeb8              DCB      0xae,0xb8
000026  2208              MOVS     r2,#8                 ;405
000028  4621              MOV      r1,r4                 ;405
00002a  4640              MOV      r0,r8                 ;405
00002c  f7fffffe          BL       USBH_Get_DevDesc
000030  2800              CMP      r0,#0                 ;405
000032  d148              BNE      |L6.198|
000034  f8940029          LDRB     r0,[r4,#0x29]         ;407
000038  71a0              STRB     r0,[r4,#6]            ;407
00003a  4640              MOV      r0,r8                 ;410
00003c  f7fffffe          BL       HCD_ResetPort
000040  70a7              STRB     r7,[r4,#2]            ;411
000042  79a0              LDRB     r0,[r4,#6]            ;414
000044  2300              MOVS     r3,#0                 ;414
000046  e9cd6000          STRD     r6,r0,[sp,#0]         ;414
00004a  7961              LDRB     r1,[r4,#5]            ;414
00004c  461a              MOV      r2,r3                 ;414
00004e  4640              MOV      r0,r8                 ;414
000050  f7fffffe          BL       USBH_Modify_Channel
000054  79a0              LDRB     r0,[r4,#6]            ;421
000056  2300              MOVS     r3,#0                 ;421
000058  e9cd6000          STRD     r6,r0,[sp,#0]         ;421
00005c  7921              LDRB     r1,[r4,#4]            ;421
00005e  461a              MOV      r2,r3                 ;421
000060  e02e              B        |L6.192|
000062  2212              MOVS     r2,#0x12              ;432
000064  4621              MOV      r1,r4                 ;432
000066  4640              MOV      r0,r8                 ;432
000068  f7fffffe          BL       USBH_Get_DevDesc
00006c  2800              CMP      r0,#0                 ;432
00006e  d12a              BNE      |L6.198|
000070  f8d40080          LDR      r0,[r4,#0x80]         ;436
000074  69c1              LDR      r1,[r0,#0x1c]         ;436
000076  f1040022          ADD      r0,r4,#0x22           ;436
00007a  4788              BLX      r1                    ;436
00007c  2002              MOVS     r0,#2                 ;437
00007e  e083              B        |L6.392|
000080  2201              MOVS     r2,#1                 ;443
000082  4621              MOV      r1,r4                 ;443
000084  4640              MOV      r0,r8                 ;443
000086  f7fffffe          BL       USBH_SetAddress
00008a  2800              CMP      r0,#0                 ;443
00008c  d17f              BNE      |L6.398|
00008e  2002              MOVS     r0,#2                 ;445
000090  f7fffffe          BL       USB_OTG_BSP_mDelay
000094  f8847020          STRB     r7,[r4,#0x20]         ;446
000098  f8d40080          LDR      r0,[r4,#0x80]         ;449
00009c  1ca4              ADDS     r4,r4,#2              ;449
00009e  6a00              LDR      r0,[r0,#0x20]         ;449
0000a0  4780              BLX      r0                    ;449
0000a2  2003              MOVS     r0,#3                 ;450
0000a4  7020              STRB     r0,[r4,#0]            ;450
0000a6  9600              STR      r6,[sp,#0]            ;453
0000a8  9601              STR      r6,[sp,#4]            ;453
0000aa  7fa2              LDRB     r2,[r4,#0x1e]         ;453
0000ac  78a1              LDRB     r1,[r4,#2]            ;453
0000ae  2300              MOVS     r3,#0                 ;453
0000b0  4640              MOV      r0,r8                 ;453
0000b2  f7fffffe          BL       USBH_Modify_Channel
0000b6  9600              STR      r6,[sp,#0]            ;460
0000b8  9601              STR      r6,[sp,#4]            ;460
0000ba  7fa2              LDRB     r2,[r4,#0x1e]         ;460
0000bc  78e1              LDRB     r1,[r4,#3]            ;460
0000be  2300              MOVS     r3,#0                 ;460
                  |L6.192|
0000c0  4640              MOV      r0,r8                 ;460
0000c2  f7fffffe          BL       USBH_Modify_Channel
                  |L6.198|
0000c6  e062              B        |L6.398|
0000c8  2209              MOVS     r2,#9                 ;471
0000ca  4621              MOV      r1,r4                 ;471
0000cc  4640              MOV      r0,r8                 ;471
0000ce  f7fffffe          BL       USBH_Get_CfgDesc
0000d2  2800              CMP      r0,#0                 ;471
0000d4  d15b              BNE      |L6.398|
0000d6  2004              MOVS     r0,#4                 ;475
0000d8  e056              B        |L6.392|
0000da  8ee2              LDRH     r2,[r4,#0x36]         ;481
0000dc  4621              MOV      r1,r4                 ;481
0000de  4640              MOV      r0,r8                 ;481
0000e0  f7fffffe          BL       USBH_Get_CfgDesc
0000e4  bba0              CBNZ     r0,|L6.336|
0000e6  f8d40080          LDR      r0,[r4,#0x80]         ;486
0000ea  f1040250          ADD      r2,r4,#0x50           ;486
0000ee  f104013e          ADD      r1,r4,#0x3e           ;486
0000f2  6a43              LDR      r3,[r0,#0x24]         ;486
0000f4  f1040034          ADD      r0,r4,#0x34           ;486
0000f8  4798              BLX      r3                    ;486
0000fa  2005              MOVS     r0,#5                 ;490
0000fc  e044              B        |L6.392|
0000fe  f8942030          LDRB     r2,[r4,#0x30]         ;495
000102  2606              MOVS     r6,#6                 ;401
000104  b152              CBZ      r2,|L6.284|
000106  9000              STR      r0,[sp,#0]
000108  ab02              ADD      r3,sp,#8
00010a  4621              MOV      r1,r4
00010c  4640              MOV      r0,r8
00010e  f7fffffe          BL       USBH_Get_StringDesc
000112  b9e8              CBNZ     r0,|L6.336|
;;;499                                   phost,
;;;500                                   phost->device_prop.Dev_Desc.iManufacturer, 
;;;501                                   Local_Buffer , 
;;;502                                   0xff) == USBH_OK)
;;;503          {
;;;504            /* User callback for Manufacturing string */
;;;505            phost->usr_cb->ManufacturerString(Local_Buffer);
000114  f8d40080          LDR      r0,[r4,#0x80]
;;;506            phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000118  6a81              LDR      r1,[r0,#0x28]
00011a  e011              B        |L6.320|
                  |L6.284|
;;;507          }
;;;508        }
;;;509        else
;;;510        {
;;;511          phost->usr_cb->ManufacturerString("N/A");      
00011c  f8d40080          LDR      r0,[r4,#0x80]
;;;512          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000120  6a81              LDR      r1,[r0,#0x28]
000122  e012              B        |L6.330|
;;;513        }
;;;514        break;
;;;515        
;;;516      case ENUM_GET_PRODUCT_STRING_DESC:   
;;;517        if (phost->device_prop.Dev_Desc.iProduct != 0)
000124  f8942031          LDRB     r2,[r4,#0x31]
000128  2607              MOVS     r6,#7                 ;401
00012a  b15a              CBZ      r2,|L6.324|
;;;518        { /* Check that Product string is available */
;;;519          if ( USBH_Get_StringDesc(pdev,
00012c  9000              STR      r0,[sp,#0]
00012e  ab02              ADD      r3,sp,#8
000130  4621              MOV      r1,r4
000132  4640              MOV      r0,r8
000134  f7fffffe          BL       USBH_Get_StringDesc
000138  b950              CBNZ     r0,|L6.336|
;;;520                                   phost,
;;;521                                   phost->device_prop.Dev_Desc.iProduct, 
;;;522                                   Local_Buffer, 
;;;523                                   0xff) == USBH_OK)
;;;524          {
;;;525            /* User callback for Product string */
;;;526            phost->usr_cb->ProductString(Local_Buffer);
00013a  f8d40080          LDR      r0,[r4,#0x80]
00013e  6ac1              LDR      r1,[r0,#0x2c]
                  |L6.320|
000140  a802              ADD      r0,sp,#8              ;505
000142  e003              B        |L6.332|
                  |L6.324|
;;;527            phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
;;;528          }
;;;529        }
;;;530        else
;;;531        {
;;;532          phost->usr_cb->ProductString("N/A");
000144  f8d40080          LDR      r0,[r4,#0x80]
000148  6ac1              LDR      r1,[r0,#0x2c]
                  |L6.330|
00014a  a013              ADR      r0,|L6.408|
                  |L6.332|
;;;533          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
;;;534        } 
;;;535        break;
;;;536        
;;;537      case ENUM_GET_SERIALNUM_STRING_DESC:   
;;;538        if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
;;;539        { /* Check that Serial number string is available */    
;;;540          if ( USBH_Get_StringDesc(pdev, 
;;;541                                   phost,
;;;542                                   phost->device_prop.Dev_Desc.iSerialNumber, 
;;;543                                   Local_Buffer, 
;;;544                                   0xff) == USBH_OK)
;;;545          {
;;;546            /* User callback for Serial number string */
;;;547            phost->usr_cb->SerialNumString(Local_Buffer);
;;;548            phost->EnumState = ENUM_SET_CONFIGURATION;
;;;549          }
;;;550        }
;;;551        else
;;;552        {
;;;553          phost->usr_cb->SerialNumString("N/A");      
00014c  4788              BLX      r1
;;;554          phost->EnumState = ENUM_SET_CONFIGURATION;
00014e  70a6              STRB     r6,[r4,#2]
                  |L6.336|
000150  e01d              B        |L6.398|
000152  f8942032          LDRB     r2,[r4,#0x32]         ;538
000156  2608              MOVS     r6,#8                 ;401
000158  b152              CBZ      r2,|L6.368|
00015a  9000              STR      r0,[sp,#0]            ;540
00015c  ab02              ADD      r3,sp,#8              ;540
00015e  4621              MOV      r1,r4                 ;540
000160  4640              MOV      r0,r8                 ;540
000162  f7fffffe          BL       USBH_Get_StringDesc
000166  b990              CBNZ     r0,|L6.398|
000168  f8d40080          LDR      r0,[r4,#0x80]         ;547
00016c  6b01              LDR      r1,[r0,#0x30]         ;548
00016e  e7e7              B        |L6.320|
                  |L6.368|
000170  f8d40080          LDR      r0,[r4,#0x80]         ;553
000174  6b01              LDR      r1,[r0,#0x30]
000176  e7e8              B        |L6.330|
;;;555        }  
;;;556        break;
;;;557          
;;;558      case ENUM_SET_CONFIGURATION:
;;;559        /* set configuration  (default config) */
;;;560        if (USBH_SetCfg(pdev, 
000178  f8942039          LDRB     r2,[r4,#0x39]
00017c  4621              MOV      r1,r4
00017e  4640              MOV      r0,r8
000180  f7fffffe          BL       USBH_SetCfg
000184  b918              CBNZ     r0,|L6.398|
;;;561                        phost,
;;;562                        phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
;;;563        {
;;;564          phost->EnumState = ENUM_DEV_CONFIGURED;
000186  2009              MOVS     r0,#9
                  |L6.392|
000188  70a0              STRB     r0,[r4,#2]
00018a  e000              B        |L6.398|
;;;565        }
;;;566        break;
;;;567    
;;;568        
;;;569      case ENUM_DEV_CONFIGURED:
;;;570        /* user callback for enumeration done */
;;;571        Status = USBH_OK;
00018c  2500              MOVS     r5,#0
                  |L6.398|
;;;572        break;
;;;573        
;;;574      default:
;;;575        break;
;;;576      }  
;;;577      return Status;
;;;578    }
00018e  b012              ADD      sp,sp,#0x48
000190  4628              MOV      r0,r5                 ;577
000192  e8bd81f0          POP      {r4-r8,pc}
;;;579    
                          ENDP

000196  0000              DCW      0x0000
                  |L6.408|
000198  4e2f4100          DCB      "N/A",0

                          AREA ||i.USBH_Init||, CODE, READONLY, ALIGN=1

                  USBH_Init PROC
;;;155      */
;;;156    void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;157                   USB_OTG_CORE_ID_TypeDef coreID,
;;;158                   USBH_HOST *phost,               
;;;159                   USBH_Class_cb_TypeDef *class_cb, 
;;;160                   USBH_Usr_cb_TypeDef *usr_cb)
;;;161    {
000004  461d              MOV      r5,r3
000006  4614              MOV      r4,r2
000008  460f              MOV      r7,r1
00000a  4680              MOV      r8,r0
;;;162         
;;;163      /* Hardware Init */
;;;164      USB_OTG_BSP_Init(pdev);  
00000c  9e06              LDR      r6,[sp,#0x18]
00000e  f7fffffe          BL       USB_OTG_BSP_Init
;;;165      
;;;166      /* configure GPIO pin used for switching VBUS power */
;;;167      USB_OTG_BSP_ConfigVBUS(0);  
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;168      
;;;169      
;;;170      /* Host de-initializations */
;;;171      USBH_DeInit(pdev, phost);
000018  4621              MOV      r1,r4
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       USBH_DeInit
;;;172      
;;;173      /*Register class and user callbacks */
;;;174      phost->class_cb = class_cb;
;;;175      phost->usr_cb = usr_cb;  
;;;176        
;;;177      /* Start the USB OTG core */     
;;;178       HCD_Init(pdev , coreID);
000020  e9e4561f          STRD     r5,r6,[r4,#0x7c]!
000024  4639              MOV      r1,r7
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       HCD_Init
;;;179       
;;;180      /* Upon Init call usr call back */
;;;181      phost->usr_cb->Init();
00002c  6860              LDR      r0,[r4,#4]
00002e  6800              LDR      r0,[r0,#0]
000030  4780              BLX      r0
;;;182      
;;;183      /* Enable Interrupts */
;;;184      USB_OTG_BSP_EnableInterrupt(pdev);
000032  4640              MOV      r0,r8
000034  e8bd41f0          POP      {r4-r8,lr}
000038  f7ffbffe          B.W      USB_OTG_BSP_EnableInterrupt
;;;185    }
;;;186    
                          ENDP


                          AREA ||i.USBH_Process||, CODE, READONLY, ALIGN=1

                  USBH_Process PROC
;;;218    */
;;;219    void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;220    {
;;;221      volatile USBH_Status status = USBH_FAIL;
000004  2602              MOVS     r6,#2
000006  460c              MOV      r4,r1                 ;220
000008  4605              MOV      r5,r0                 ;220
00000a  f88d6000          STRB     r6,[sp,#0]
;;;222      
;;;223      
;;;224      /* check for Host port events */
;;;225      if ((HCD_IsDeviceConnected(pdev) == 0)&& (phost->gState != HOST_IDLE)) 
00000e  f7fffffe          BL       HCD_IsDeviceConnected
000012  b920              CBNZ     r0,|L8.30|
000014  7820              LDRB     r0,[r4,#0]
000016  b110              CBZ      r0,|L8.30|
;;;226      {
;;;227        if(phost->gState != HOST_DEV_DISCONNECTED) 
000018  2802              CMP      r0,#2
00001a  d000              BEQ      |L8.30|
;;;228        {
;;;229          phost->gState = HOST_DEV_DISCONNECTED;
00001c  7026              STRB     r6,[r4,#0]
                  |L8.30|
;;;230        }
;;;231      }
;;;232        
;;;233      switch (phost->gState)
00001e  7820              LDRB     r0,[r4,#0]
000020  2600              MOVS     r6,#0
;;;234      {
;;;235      
;;;236      case HOST_IDLE :
;;;237        
;;;238        if (HCD_IsDeviceConnected(pdev))  
;;;239        {
;;;240          phost->gState = HOST_DEV_ATTACHED;
;;;241          USB_OTG_BSP_mDelay(100);
;;;242        }
;;;243        break;
;;;244       
;;;245      case HOST_DEV_ATTACHED :
;;;246        
;;;247        phost->usr_cb->DeviceAttached();
;;;248        phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
;;;249        phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
;;;250      
;;;251        /* Reset USB Device */
;;;252        if ( HCD_ResetPort(pdev) == 0)
;;;253        {
;;;254          phost->usr_cb->ResetDevice();
;;;255          /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
;;;256          Host is Now ready to start the Enumeration 
;;;257          */
;;;258          
;;;259          phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
;;;260          
;;;261          phost->gState = HOST_ENUMERATION;
;;;262          phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
;;;263            
;;;264          /* Open Control pipes */
;;;265          USBH_Open_Channel (pdev,
;;;266                               phost->Control.hc_num_in,
;;;267                               phost->device_prop.address,
;;;268                               phost->device_prop.speed,
;;;269                               EP_TYPE_CTRL,
;;;270                               phost->Control.ep0size); 
;;;271          
;;;272          /* Open Control pipes */
;;;273          USBH_Open_Channel (pdev,
;;;274                               phost->Control.hc_num_out,
;;;275                               phost->device_prop.address,
;;;276                               phost->device_prop.speed,
;;;277                               EP_TYPE_CTRL,
;;;278                               phost->Control.ep0size);          
;;;279       }
;;;280        break;
;;;281        
;;;282      case HOST_ENUMERATION:     
;;;283        /* Check for enumeration status */  
;;;284        if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
;;;285        { 
;;;286          /* The function shall return USBH_OK when full enumeration is complete */
;;;287          
;;;288          /* user callback for end of device basic enumeration */
;;;289          phost->usr_cb->EnumerationDone();
;;;290          
;;;291          phost->gState  = HOST_USR_INPUT;    
;;;292        }
;;;293        break;
;;;294        
;;;295      case HOST_USR_INPUT:    
;;;296        /*The function should return user response true to move to class state */
;;;297        if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
;;;298        {
;;;299          if((phost->class_cb->Init(pdev, phost))\
;;;300            == USBH_OK)
;;;301          {
;;;302            phost->gState  = HOST_CLASS_REQUEST;     
;;;303          }     
;;;304        }   
;;;305        break;
;;;306        
;;;307      case HOST_CLASS_REQUEST:  
;;;308        /* process class standard contol requests state machine */ 
;;;309        status = phost->class_cb->Requests(pdev, phost);
;;;310        
;;;311         if(status == USBH_OK)
;;;312         {
;;;313           phost->gState  = HOST_CLASS;
;;;314         }  
;;;315         
;;;316         else
;;;317         {
;;;318           USBH_ErrorHandle(phost, status);
;;;319         }
;;;320     
;;;321        
;;;322        break;    
;;;323      case HOST_CLASS:   
;;;324        /* process class state machine */
;;;325        status = phost->class_cb->Machine(pdev, phost);
;;;326        USBH_ErrorHandle(phost, status);
;;;327        break;       
;;;328        
;;;329      case HOST_CTRL_XFER:
;;;330        /* process control transfer state machine */
;;;331        USBH_HandleControl(pdev, phost);    
;;;332        break;
;;;333        
;;;334      case HOST_SUSPENDED:
;;;335        break;
;;;336      
;;;337      case HOST_ERROR_STATE:
;;;338        /* Re-Initilaize Host for new Enumeration */
;;;339        USBH_DeInit(pdev, phost);
;;;340        phost->usr_cb->DeInit();
;;;341        phost->class_cb->DeInit(pdev, &phost->device_prop);
000022  f1040720          ADD      r7,r4,#0x20
000026  280b              CMP      r0,#0xb               ;233
000028  d248              BCS      |L8.188|
00002a  e8dff000          TBB      [pc,r0]               ;233
00002e  0612              DCB      0x06,0x12
000030  96474965          DCB      0x96,0x47,0x49,0x65
000034  78805547          DCB      0x78,0x80,0x55,0x47
000038  8600              DCB      0x86,0x00
00003a  4628              MOV      r0,r5                 ;238
00003c  f7fffffe          BL       HCD_IsDeviceConnected
000040  2800              CMP      r0,#0                 ;238
000042  d03b              BEQ      |L8.188|
000044  2001              MOVS     r0,#1                 ;240
000046  7020              STRB     r0,[r4,#0]            ;240
000048  e8bd41fc          POP      {r2-r8,lr}            ;241
00004c  2064              MOVS     r0,#0x64              ;241
00004e  f7ffbffe          B.W      USB_OTG_BSP_mDelay
000052  f8d40080          LDR      r0,[r4,#0x80]         ;247
000056  6880              LDR      r0,[r0,#8]            ;247
000058  4780              BLX      r0                    ;247
00005a  2100              MOVS     r1,#0                 ;248
00005c  4628              MOV      r0,r5                 ;248
00005e  f7fffffe          BL       USBH_Alloc_Channel
000062  7160              STRB     r0,[r4,#5]            ;248
000064  2180              MOVS     r1,#0x80              ;249
000066  4628              MOV      r0,r5                 ;249
000068  f7fffffe          BL       USBH_Alloc_Channel
00006c  7120              STRB     r0,[r4,#4]            ;249
00006e  4628              MOV      r0,r5                 ;252
000070  f7fffffe          BL       HCD_ResetPort
000074  2800              CMP      r0,#0                 ;252
000076  d121              BNE      |L8.188|
000078  f8d40080          LDR      r0,[r4,#0x80]         ;254
00007c  1d24              ADDS     r4,r4,#4              ;254
00007e  68c0              LDR      r0,[r0,#0xc]          ;254
000080  4780              BLX      r0                    ;254
000082  4628              MOV      r0,r5                 ;259
000084  f7fffffe          BL       HCD_GetCurrentSpeed
000088  b2c0              UXTB     r0,r0                 ;259
00008a  7760              STRB     r0,[r4,#0x1d]         ;259
00008c  2104              MOVS     r1,#4                 ;261
00008e  f8041c04          STRB     r1,[r4,#-4]           ;261
000092  6fe1              LDR      r1,[r4,#0x7c]         ;262
000094  6989              LDR      r1,[r1,#0x18]         ;262
000096  4788              BLX      r1                    ;262
000098  78a0              LDRB     r0,[r4,#2]            ;265
00009a  e9cd6000          STRD     r6,r0,[sp,#0]         ;265
00009e  7f63              LDRB     r3,[r4,#0x1d]         ;265
0000a0  7f22              LDRB     r2,[r4,#0x1c]         ;265
0000a2  7821              LDRB     r1,[r4,#0]            ;265
0000a4  4628              MOV      r0,r5                 ;265
0000a6  f7fffffe          BL       USBH_Open_Channel
0000aa  78a0              LDRB     r0,[r4,#2]            ;273
0000ac  e9cd6000          STRD     r6,r0,[sp,#0]         ;273
0000b0  7f63              LDRB     r3,[r4,#0x1d]         ;273
0000b2  7f22              LDRB     r2,[r4,#0x1c]         ;273
0000b4  7861              LDRB     r1,[r4,#1]            ;273
0000b6  4628              MOV      r0,r5                 ;273
0000b8  f7fffffe          BL       USBH_Open_Channel
                  |L8.188|
;;;342        break;
;;;343        
;;;344      case HOST_DEV_DISCONNECTED :
;;;345        
;;;346        /* Manage User disconnect operations*/
;;;347        phost->usr_cb->DeviceDisconnected();
;;;348        
;;;349        /* Re-Initilaize Host for new Enumeration */
;;;350        USBH_DeInit(pdev, phost);
;;;351        phost->usr_cb->DeInit();
;;;352        phost->class_cb->DeInit(pdev, &phost->device_prop); 
;;;353        USBH_DeAllocate_AllChannel(pdev);  
;;;354        phost->gState = HOST_IDLE;
;;;355        
;;;356        break;
;;;357        
;;;358      default :
;;;359        break;
;;;360      }
;;;361    
;;;362    }
0000bc  e8bd81fc          POP      {r2-r8,pc}
0000c0  4621              MOV      r1,r4                 ;284
0000c2  4628              MOV      r0,r5                 ;284
0000c4  f7fffffe          BL       USBH_HandleEnum
0000c8  2800              CMP      r0,#0                 ;284
0000ca  d1f7              BNE      |L8.188|
0000cc  f8d40080          LDR      r0,[r4,#0x80]         ;289
0000d0  6b40              LDR      r0,[r0,#0x34]         ;289
0000d2  4780              BLX      r0                    ;289
0000d4  2008              MOVS     r0,#8                 ;291
0000d6  e00d              B        |L8.244|
0000d8  f8d40080          LDR      r0,[r4,#0x80]         ;297
0000dc  6b80              LDR      r0,[r0,#0x38]         ;297
0000de  4780              BLX      r0                    ;297
0000e0  2801              CMP      r0,#1                 ;297
0000e2  d1eb              BNE      |L8.188|
0000e4  6fe0              LDR      r0,[r4,#0x7c]         ;299
0000e6  4621              MOV      r1,r4                 ;299
0000e8  6802              LDR      r2,[r0,#0]            ;299
0000ea  4628              MOV      r0,r5                 ;299
0000ec  4790              BLX      r2                    ;299
0000ee  2800              CMP      r0,#0                 ;299
0000f0  d1e4              BNE      |L8.188|
0000f2  2005              MOVS     r0,#5                 ;302
                  |L8.244|
0000f4  7020              STRB     r0,[r4,#0]            ;291
0000f6  e7e1              B        |L8.188|
0000f8  6fe0              LDR      r0,[r4,#0x7c]         ;309
0000fa  4621              MOV      r1,r4                 ;309
0000fc  6882              LDR      r2,[r0,#8]            ;309
0000fe  4628              MOV      r0,r5                 ;309
000100  4790              BLX      r2                    ;309
000102  f88d0000          STRB     r0,[sp,#0]            ;309
000106  f89d0000          LDRB     r0,[sp,#0]            ;311
00010a  b908              CBNZ     r0,|L8.272|
00010c  2006              MOVS     r0,#6                 ;313
00010e  e7f1              B        |L8.244|
                  |L8.272|
000110  f89d1000          LDRB     r1,[sp,#0]            ;318
000114  4620              MOV      r0,r4                 ;318
000116  e8bd41fc          POP      {r2-r8,lr}            ;318
00011a  f7ffbffe          B.W      USBH_ErrorHandle
00011e  6fe0              LDR      r0,[r4,#0x7c]         ;325
000120  4621              MOV      r1,r4                 ;325
000122  68c2              LDR      r2,[r0,#0xc]          ;325
000124  4628              MOV      r0,r5                 ;325
000126  4790              BLX      r2                    ;325
000128  f88d0000          STRB     r0,[sp,#0]            ;325
00012c  e7f0              B        |L8.272|
00012e  4621              MOV      r1,r4                 ;331
000130  4628              MOV      r0,r5                 ;331
000132  e8bd41fc          POP      {r2-r8,lr}            ;331
000136  f7ffbffe          B.W      USBH_HandleControl
00013a  4621              MOV      r1,r4                 ;339
00013c  4628              MOV      r0,r5                 ;339
00013e  f7fffffe          BL       USBH_DeInit
000142  f8d40080          LDR      r0,[r4,#0x80]         ;340
000146  6840              LDR      r0,[r0,#4]            ;340
000148  4780              BLX      r0                    ;340
00014a  6fe0              LDR      r0,[r4,#0x7c]         ;341
00014c  4639              MOV      r1,r7                 ;341
00014e  6842              LDR      r2,[r0,#4]            ;341
000150  b002              ADD      sp,sp,#8              ;341
000152  4628              MOV      r0,r5                 ;341
000154  e8bd41f0          POP      {r4-r8,lr}            ;341
000158  4710              BX       r2                    ;341
00015a  f8d40080          LDR      r0,[r4,#0x80]         ;347
00015e  6900              LDR      r0,[r0,#0x10]         ;347
000160  4780              BLX      r0                    ;347
000162  4621              MOV      r1,r4                 ;350
000164  4628              MOV      r0,r5                 ;350
000166  f7fffffe          BL       USBH_DeInit
00016a  f8d40080          LDR      r0,[r4,#0x80]         ;351
00016e  6840              LDR      r0,[r0,#4]            ;351
000170  4780              BLX      r0                    ;351
000172  6fe0              LDR      r0,[r4,#0x7c]         ;352
000174  4639              MOV      r1,r7                 ;352
000176  6842              LDR      r2,[r0,#4]            ;352
000178  4628              MOV      r0,r5                 ;352
00017a  4790              BLX      r2                    ;352
00017c  4628              MOV      r0,r5                 ;353
00017e  f7fffffe          BL       USBH_DeAllocate_AllChannel
000182  7026              STRB     r6,[r4,#0]            ;354
000184  e79a              B        |L8.188|
;;;363    
                          ENDP


                          AREA ||i.USBH_SOF||, CODE, READONLY, ALIGN=1

                  USBH_SOF PROC
;;;143    
;;;144    uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
000000  2000              MOVS     r0,#0
;;;145    {
;;;146      /* This callback could be used to implement a scheduler process */
;;;147      return 0;  
;;;148    }
000002  4770              BX       lr
;;;149    /**
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  USBH_HCD_INT_cb
                          DCD      USBH_SOF
                          DCD      USBH_Connected
                          DCD      USBH_Disconnected

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  USBH_HCD_INT_fops
                          DCD      USBH_HCD_INT_cb

                          AREA ||area_number.14||, DATA, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.data||
                  timeout
000000  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_HOST_Library\\Core\\src\\usbh_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_usbh_core_c_2210222f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REVSH|
#line 144
|__asm___11_usbh_core_c_2210222f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
